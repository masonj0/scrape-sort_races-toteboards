{
    "python_service/cache_manager.py": "# python_service/cache_manager.py\nfrom functools import wraps\nimport json\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom typing import Any, Callable\nimport os\nimport structlog\n\ntry:\n    import redis\n    REDIS_AVAILABLE = True\nexcept ImportError:\n    REDIS_AVAILABLE = False\n\nlog = structlog.get_logger(__name__)\n\nclass CacheManager:\n    def __init__(self, redis_url: str = None):\n        self.redis_client = None\n        self.memory_cache = {}\n        if REDIS_AVAILABLE and redis_url:\n            try:\n                self.redis_client = redis.from_url(redis_url, decode_responses=True)\n                log.info(\"Redis cache connected successfully.\")\n            except Exception as e:\n                log.warning(f\"Failed to connect to Redis: {e}. Falling back to in-memory cache.\")\n\n    def _generate_key(self, prefix: str, *args, **kwargs) -> str:\n        key_data = f\"{prefix}:{args}:{sorted(kwargs.items())}\"\n        return hashlib.md5(key_data.encode()).hexdigest()\n\n    def get(self, key: str) -> Any | None:\n        if self.redis_client:\n            try:\n                value = self.redis_client.get(key)\n                return json.loads(value) if value else None\n            except Exception as e:\n                log.warning(f\"Redis GET failed: {e}\")\n        \n        entry = self.memory_cache.get(key)\n        if entry and entry[\"expires_at\"] > datetime.now():\n            return entry[\"value\"]\n        return None\n\n    def set(self, key: str, value: Any, ttl_seconds: int = 300):\n        serialized = json.dumps(value, default=str)\n        if self.redis_client:\n            try:\n                self.redis_client.setex(key, ttl_seconds, serialized)\n                return\n            except Exception as e:\n                log.warning(f\"Redis SET failed: {e}\")\n        \n        self.memory_cache[key] = {\n            \"value\": value,\n            \"expires_at\": datetime.now() + timedelta(seconds=ttl_seconds)\n        }\n\n# --- Singleton Instance & Decorator ---\ncache_manager = CacheManager(redis_url=os.getenv(\"REDIS_URL\"))\n\ndef cache_async_result(ttl_seconds: int = 300, key_prefix: str = \"cache\"):\n    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            instance_args = args[1:] if args and hasattr(args[0], func.__name__) else args\n            cache_key = cache_manager._generate_key(f\"{key_prefix}:{func.__name__}\", *instance_args, **kwargs)\n            \n            cached_result = cache_manager.get(cache_key)\n            if cached_result is not None:\n                log.debug(\"Cache hit\", function=func.__name__)\n                return cached_result\n\n            log.debug(\"Cache miss\", function=func.__name__)\n            result = await func(*args, **kwargs)\n            cache_manager.set(cache_key, result, ttl_seconds)\n            return result\n        return wrapper\n    return decorator\n",
    "python_service/middleware/error_handler.py": "# python_service/middleware/error_handler.py\nfrom fastapi import Request, status\nfrom fastapi.responses import JSONResponse\nimport structlog\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any\n\nlog = structlog.get_logger(__name__)\n\nclass ErrorRecoveryMiddleware:\n    def __init__(self, app):\n        self.app = app\n        self.error_counts = {}\n        self.circuit_breaker_open = {}\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        # Correctly extract adapter from raw scope without consuming the request body\n        adapter_name = self._extract_adapter_from_scope(scope)\n\n        if adapter_name and self._is_circuit_open(adapter_name):\n            log.warning(\"Circuit breaker is open for adapter\", adapter=adapter_name)\n            response = JSONResponse(\n                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,\n                content={\"error\": f\"Service temporarily unavailable for adapter '{adapter_name}' due to repeated failures.\"}\n            )\n            await response(scope, receive, send)\n            return\n\n        try:\n            await self.app(scope, receive, send)\n        except Exception as exc:\n            # The error handler needs a request object, but we must be careful.\n            # We create it here, knowing that for GET requests this is safe.\n            # A more advanced implementation might be needed for POST requests if they\n            # were to trigger adapter-specific errors.\n            request_on_error = Request(scope, receive)\n            await self._handle_error(request_on_error, exc, send)\n\n    async def _handle_error(self, request: Request, exc: Exception, send):\n        error_id = f\"{type(exc).__name__}_{datetime.now().timestamp()}\"\n        log.error(\"Unhandled error\", error_id=error_id, path=request.url.path, error_type=type(exc).__name__, exc_info=True)\n\n        adapter_name = self._extract_adapter_from_request(request)\n        if adapter_name:\n            self._increment_error_count(adapter_name)\n            if self._should_open_circuit(adapter_name):\n                log.warning(\"Circuit breaker opened for adapter\", adapter=adapter_name)\n                self.circuit_breaker_open[adapter_name] = datetime.now()\n\n        response = JSONResponse(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            content={\"error\": \"Internal Server Error\", \"error_id\": error_id}\n        )\n        # The response must be awaited with the original scope, receive, and send callables\n        await response(request.scope, request.receive, send)\n\n    def _extract_adapter_from_scope(self, scope: Dict[str, Any]) -> str | None:\n        \"\"\"Extracts the adapter name from the 'source' query parameter in the raw scope.\"\"\"\n        query_string = scope.get(\"query_string\", b\"\").decode()\n        if \"source=\" in query_string:\n            params = dict(param.split(\"=\") for param in query_string.split(\"&\"))\n            return params.get(\"source\")\n        return None\n\n    def _increment_error_count(self, adapter_name: str):\n        if adapter_name not in self.error_counts:\n            self.error_counts[adapter_name] = []\n        self.error_counts[adapter_name].append(datetime.now())\n        cutoff = datetime.now() - timedelta(minutes=5)\n        self.error_counts[adapter_name] = [t for t in self.error_counts[adapter_name] if t > cutoff]\n\n    def _should_open_circuit(self, adapter_name: str) -> bool:\n        return len(self.error_counts.get(adapter_name, [])) > 5\n\n    def _is_circuit_open(self, adapter_name: str) -> bool:\n        if adapter_name not in self.circuit_breaker_open:\n            return False\n        opened_at = self.circuit_breaker_open[adapter_name]\n        if (datetime.now() - opened_at) > timedelta(minutes=10):\n            del self.circuit_breaker_open[adapter_name]\n            log.info(\"Circuit breaker auto-closed for adapter\", adapter=adapter_name)\n            return False\n        return True\n",
    "python_service/models_v3.py": "# python_service/models_v3.py\n# Defines the data structures for the V3 adapter architecture.\n\nfrom dataclasses import dataclass, field\nfrom typing import List\n\n@dataclass\nclass NormalizedRunner:\n    runner_id: str\n    name: str\n    saddle_cloth: str\n    odds_decimal: float\n\n@dataclass\nclass NormalizedRace:\n    race_key: str\n    track_key: str\n    start_time_iso: str\n    race_name: str\n    runners: List[NormalizedRunner] = field(default_factory=list)\n    source_ids: List[str] = field(default_factory=list)\n"
}