{"content": "import pytest\nfrom pathlib import Path\nfrom unittest.mock import patch\nfrom paddock_parser.adapters.skysports_adapter import SkySportsAdapter\n\n@pytest.mark.anyio\n@patch(\"paddock_parser.forager.http_client.ForagerClient.fetch\")\nasync def test_skysports_adapter_fetches_and_parses(mock_fetch):\n    \"\"\"\n    Tests the full end-to-end fetch and parse process for SkySportsAdapter,\n    with the fetch mechanism mocked.\n    \"\"\"\n    # --- Setup ---\n    adapter = SkySportsAdapter()\n\n    # Load the sample HTML from a fixture file for the test\n    fixture_path = Path(__file__).parent / \"fixtures\" / \"skysports_racecards_sample.html\"\n    sample_html = fixture_path.read_text(encoding=\"utf-8\")\n\n    # Configure the mock to return our sample HTML\n    # Since the mocked function is async, the mock's return value will be awaited\n    mock_fetch.return_value = sample_html\n\n    # --- Run ---\n    # Run the fetch method, which will use the mocked fetch_html_content\n    races = await adapter.fetch()\n\n    # --- Assertions ---\n    assert races is not None\n    assert len(races) == 113\n\n    # Find a specific, known race in the results for a deep check\n    target_race = None\n    for race in races:\n        if race.track_name == \"Chelmsford City\" and race.post_time and race.post_time.strftime(\"%H:%M\") == \"14:20\":\n            target_race = race\n            break\n\n    assert target_race is not None, \"Could not find the target Chelmsford City 14:20 race\"\n    assert target_race.race_number == 1\n    assert target_race.number_of_runners == 8\n    # source_id is not part of the NormalizedRace model, so this assertion is removed.\n    # assert target_race.source_id == \"skysports\"\n"}
