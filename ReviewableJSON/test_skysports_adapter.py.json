{
    "filepath": "./paddock-parser-ng/src/paddock_parser/tests/test_skysports_adapter.py",
    "content": "import pytest\nfrom unittest.mock import patch\nfrom paddock_parser.adapters.skysports_adapter import SkySportsAdapter\n\n@pytest.mark.anyio\n@patch(\"paddock_parser.adapters.skysports_adapter.fetch_html_content\")\nasync def test_skysports_adapter_fetches_and_parses(mock_fetch_html_content):\n    \"\"\"\n    Tests the full end-to-end fetch and parse process for SkySportsAdapter,\n    with the fetch mechanism mocked.\n    \"\"\"\n    # --- Setup ---\n    adapter = SkySportsAdapter()\n\n    # Load the sample HTML from a fixture file for the test\n    with open(\"src/paddock_parser/tests/fixtures/skysports_racecards_sample.html\", \"r\", encoding=\"utf-8\") as f:\n        sample_html = f.read()\n\n    # Configure the mock to return our sample HTML\n    # Since the mocked function is async, the mock's return value will be awaited\n    mock_fetch_html_content.return_value = sample_html\n\n    # --- Run ---\n    # Run the fetch method, which will use the mocked fetch_html_content\n    races = await adapter.fetch()\n\n    # --- Assertions ---\n    assert races is not None\n    assert len(races) == 113\n\n    # Find a specific, known race in the results for a deep check\n    target_race = None\n    for race in races:\n        if race.track_name == \"Chelmsford City\" and race.post_time and race.post_time.strftime(\"%H:%M\") == \"14:20\":\n            target_race = race\n            break\n\n    assert target_race is not None, \"Could not find the target Chelmsford City 14:20 race\"\n    assert target_race.race_number == 1\n    assert target_race.number_of_runners == 8\n    # source_id is not part of the NormalizedRace model, so this assertion is removed.\n    # assert target_race.source_id == \"skysports\"\n"
}