{
    "file_path": "tests/test_engine.py",
    "content": "import pytest\nfrom unittest.mock import AsyncMock, patch\nfrom datetime import datetime, date\nfrom decimal import Decimal\nimport fakeredis.aioredis\n\nfrom python_service.models import Race, Runner, OddsData\nfrom python_service.engine import OddsEngine\nfrom python_service.config import get_settings\nfrom python_service.adapters.base import BaseAdapter\n\ndef create_mock_race(source: str, venue: str, race_number: int, start_time: datetime, runners_data: list) -> Race:\n    \"\"\"Helper function to create a Race object for testing.\"\"\"\n    runners = []\n    for r_data in runners_data:\n        odds = {source: OddsData(win=Decimal(r_data[\"odds\"]), source=source, last_updated=datetime.now())}\n        runners.append(Runner(number=r_data[\"number\"], name=r_data[\"name\"], odds=odds))\n\n    return Race(\n        id=f\"test_{source}_{race_number}\",\n        venue=venue,\n        race_number=race_number,\n        start_time=start_time,\n        runners=runners,\n        source=source\n    )\n\n@pytest.fixture\ndef mock_engine() -> OddsEngine:\n    \"\"\"Provides an OddsEngine instance with a mock config.\"\"\"\n    return OddsEngine(config=get_settings())\n\n@pytest.mark.asyncio\n@patch('python_service.engine.OddsEngine._time_adapter_fetch', new_callable=AsyncMock)\nasync def test_engine_deduplicates_races_and_merges_odds(mock_time_adapter_fetch, mock_engine):\n    \"\"\"\n    SPEC: The OddsEngine's fetch_all_odds method should identify duplicate races\n    from different sources and merge their runner data, stacking the odds.\n    \"\"\"\n    # ARRANGE\n    test_time = datetime(2025, 10, 9, 14, 30)\n\n    source_a_race = create_mock_race(\"SourceA\", \"Test Park\", 1, test_time, [\n        {\"number\": 1, \"name\": \"Speedy\", \"odds\": \"5.0\"},\n        {\"number\": 2, \"name\": \"Steady\", \"odds\": \"10.0\"},\n    ])\n    source_b_race = create_mock_race(\"SourceB\", \"Test Park\", 1, test_time, [\n        {\"number\": 1, \"name\": \"Speedy\", \"odds\": \"5.5\"},\n        {\"number\": 3, \"name\": \"Newcomer\", \"odds\": \"15.0\"},\n    ])\n    other_race = create_mock_race(\"SourceC\", \"Another Place\", 2, test_time, [\n        {\"number\": 1, \"name\": \"Solo\", \"odds\": \"3.0\"}\n    ])\n\n    mock_time_adapter_fetch.side_effect = [\n        (\"SourceA\", {'races': [source_a_race], 'source_info': {'name': 'SourceA', 'status': 'SUCCESS', 'races_fetched': 1}}, 1.0),\n        (\"SourceB\", {'races': [source_b_race], 'source_info': {'name': 'SourceB', 'status': 'SUCCESS', 'races_fetched': 1}}, 1.0),\n        (\"SourceC\", {'races': [other_race], 'source_info': {'name': 'SourceC', 'status': 'SUCCESS', 'races_fetched': 1}}, 1.0),\n    ]\n\n    # ACT\n    today_str = date.today().strftime('%Y-%m-%d')\n    result = await mock_engine.fetch_all_odds(today_str)\n\n    # ASSERT\n    assert len(result['races']) == 2, \"Engine should have de-duplicated the races.\"\n\n    merged_race = next((r for r in result['races'] if r['venue'] == \"Test Park\"), None)\n    assert merged_race is not None, \"Merged race should be present in the results.\"\n    assert len(merged_race['runners']) == 3, \"Merged race should contain all unique runners.\"\n\n    runner1 = next((r for r in merged_race['runners'] if r['number'] == 1), None)\n    assert runner1 is not None\n    assert \"SourceA\" in runner1['odds']\n    assert \"SourceB\" in runner1['odds']\n    assert runner1['odds']['SourceA']['win'] == Decimal(\"5.0\")\n    assert runner1['odds']['SourceB']['win'] == Decimal(\"5.5\")\n\n    runner2 = next((r for r in merged_race['runners'] if r['number'] == 2), None)\n    assert runner2 is not None\n    assert \"SourceA\" in runner2['odds'] and \"SourceB\" not in runner2['odds']\n\n    runner3 = next((r for r in merged_race['runners'] if r['number'] == 3), None)\n    assert runner3 is not None\n    assert \"SourceB\" in runner3['odds'] and \"SourceA\" not in runner3['odds']\n\n\n@pytest.mark.asyncio\n@patch('python_service.engine.redis.from_url')\nasync def test_engine_caching_logic(mock_redis_from_url):\n    \"\"\"\n    SPEC: The OddsEngine should cache results in Redis.\n    1. On a cache miss, it should fetch from adapters and set the cache.\n    2. On a cache hit, it should return data from the cache without fetching from adapters.\n    \"\"\"\n    # ARRANGE\n    mock_redis_client = fakeredis.aioredis.FakeRedis(decode_responses=True)\n    mock_redis_from_url.return_value = mock_redis_client\n    await mock_redis_client.flushall()\n\n    engine = OddsEngine(config=get_settings())\n\n    today_str = date.today().strftime('%Y-%m-%d')\n    cache_key = f\"fortuna:races:{today_str}\"\n    test_time = datetime(2025, 10, 9, 15, 0)\n\n    mock_race = create_mock_race(\"TestSource\", \"Cache Park\", 1, test_time, [\n        {\"number\": 1, \"name\": \"Cachedy\", \"odds\": \"4.0\"}\n    ])\n\n    # Replace the engine's adapters with a single mock to isolate the test\n    mock_adapter = AsyncMock(spec=BaseAdapter)\n    mock_adapter.source_name = \"TestSource\"\n    mock_adapter.fetch_races.return_value = {\n        'races': [mock_race],\n        'source_info': {'name': 'TestSource', 'status': 'SUCCESS', 'races_fetched': 1}\n    }\n    engine.adapters = [mock_adapter]\n\n\n    # --- ACT 1: Cache Miss ---\n    result_miss = await engine.fetch_all_odds(today_str)\n\n    # --- ASSERT 1: Cache Miss ---\n    mock_adapter.fetch_races.assert_called_once()\n    cached_value = await mock_redis_client.get(cache_key)\n    assert cached_value is not None\n    assert len(result_miss['races']) == 1\n    assert result_miss['races'][0]['venue'] == \"Cache Park\"\n\n\n    # --- ACT 2: Cache Hit ---\n    mock_adapter.fetch_races.reset_mock()\n    result_hit = await engine.fetch_all_odds(today_str)\n\n    # --- ASSERT 2: Cache Hit ---\n    mock_adapter.fetch_races.assert_not_called()\n    assert len(result_hit['races']) == 1\n    assert result_hit['races'][0]['venue'] == \"Cache Park\"\n\n    assert result_hit['races'] == result_miss['races']\n    assert result_hit['sources'] == result_miss['sources']\n\n    await engine.close()"
}