{
    "content": "\"\"\"\nTest-as-Spec for the FastAPI Server\nPath: tests/api/test_main.py\n\"\"\"\n\nimport pytest\nfrom unittest.mock import patch\nfrom fastapi.testclient import TestClient\nfrom datetime import datetime\n\n# Assume these data structures will be imported from the project\nfrom src.paddock_parser.base import NormalizedRace, NormalizedRunner\n\n# The yet-to-be-created FastAPI app\nfrom src.paddock_parser.api.main import app\n\n# Create a TestClient instance for making API requests in tests\nclient = TestClient(app)\n\n@pytest.fixture\ndef mock_pipeline_data():\n    \"\"\"Provides a sample list of NormalizedRace objects for mocking.\"\"\"\n    return [\n        NormalizedRace(\n            race_id=\"AQU_20250901_1\",\n            track_name=\"Aqueduct\",\n            race_number=1,\n            post_time=datetime(2025, 9, 1, 13, 0, 0),\n            number_of_runners=8,\n            runners=[\n                NormalizedRunner(name=\"Speedster\", program_number=1),\n                NormalizedRunner(name=\"Galloper\", program_number=2),\n            ],\n            score=95,\n        ),\n        NormalizedRace(\n            race_id=\"SA_20250901_3\",\n            track_name=\"Santa Anita\",\n            race_number=3,\n            post_time=datetime(2025, 9, 1, 15, 30, 0),\n            number_of_runners=10,\n            runners=[],\n            score=110,\n        ),\n    ]\n\nclass TestAPIRoot:\n    def test_read_root_returns_welcome_message(self):\n        \"\"\"\n        SPEC: The root endpoint (\n\"/\") should exist and return a simple welcome message.\n        This confirms the API is running and responsive.\n        \"\"\"\n        response = client.get(\"/\")\n        assert response.status_code == 200\n        assert response.json() == {\"message\": \"Paddock Parser API is running.\"}\n\nclass TestRacesEndpoint:\n    @patch('src.paddock_parser.api.main.run_pipeline')\n    def test_get_races_returns_200_ok(self, mock_run_pipeline):\n        \"\"\"\n        SPEC: The /api/v1/races endpoint should exist and return a 200 OK status code.\n        \"\"\"\n        mock_run_pipeline.return_value = []  # Return empty list for this test\n        response = client.get(\"/api/v1/races\")\n        assert response.status_code == 200\n\n    @patch('src.paddock_parser.api.main.run_pipeline')\n    def test_get_races_returns_list_of_races(self, mock_run_pipeline, mock_pipeline_data):\n        \"\"\"\n        SPEC: The /api/v1/races endpoint should return a JSON array of race objects\n        that match the data returned from the pipeline.\n        \"\"\"\n        mock_run_pipeline.return_value = mock_pipeline_data\n        \n        response = client.get(\"/api/v1/races\")\n        \n        assert response.status_code == 200\n        response_data = response.json()\n        \n        assert isinstance(response_data, list)\n        assert len(response_data) == 2\n        assert response_data[0][\"track_name\"] == \"Aqueduct\"\n        assert response_data[1][\"track_name\"] == \"Santa Anita\"\n\n    @patch('src.paddock_parser.api.main.run_pipeline')\n    def test_race_schema_is_correct(self, mock_run_pipeline, mock_pipeline_data):\n        \"\"\"\n        SPEC: The JSON objects returned should conform to the Pydantic schema,\n        including correct data types and nested runner objects.\n        \"\"\"\n        mock_run_pipeline.return_value = mock_pipeline_data\n        \n        response = client.get(\"/api/v1/races\")\n        response_data = response.json()\n        \n        first_race = response_data[0]\n        \n        # Verify data types and structure\n        assert isinstance(first_race[\"race_id\"], str)\n        assert first_race[\"race_id\"] == \"AQU_20250901_1\"\n        assert isinstance(first_race[\"track_name\"], str)\n        assert isinstance(first_race[\"race_number\"], int)\n        assert isinstance(first_race[\"post_time\"], str) # Pydantic converts datetime to ISO string\n        assert first_race[\"post_time\"] == \"2025-09-01T13:00:00\"\n        assert isinstance(first_race[\"number_of_runners\"], int)\n        assert isinstance(first_race[\"score\"], int)\n        \n        # Verify nested runners schema\n        assert isinstance(first_race[\"runners\"], list)\n        assert len(first_race[\"runners\"]) == 2\n        assert first_race[\"runners\"][0][\"name\"] == \"Speedster\"\n\n    @patch('src.paddock_parser.api.main.run_pipeline')\n    def test_pipeline_is_called_with_default_parameters(self, mock_run_pipeline):\n        \"\"\"\n        SPEC: The endpoint should call the core run_pipeline function\n        with default parameters if none are provided in the request.\n        \"\"\"\n        mock_run_pipeline.return_value = []\n        \n        client.get(\"/api/v1/races\")\n        \n        # Verify that the backend logic was called correctly\n        mock_run_pipeline.assert_called_once()\n        # Check that it was called with default arguments\n        args, kwargs = mock_run_pipeline.call_args\n        assert kwargs.get('min_runners') is None # Or whatever the default is\n        assert kwargs.get('specific_source') is None\n\n    @patch('src.paddock_parser.api.main.run_pipeline')\n    def test_pipeline_is_called_with_query_parameters(self, mock_run_pipeline):\n        \"\"\"\n        SPEC: The endpoint can accept query parameters to filter the pipeline run.\n        e.g., /api/v1/races?min_runners=10&source=equibase\n        \"\"\"\n        mock_run_pipeline.return_value = []\n        \n        client.get(\"/api/v1/races?min_runners=10&source=equibase\")\n        \n        mock_run_pipeline.assert_called_once()\n        args, kwargs = mock_run_pipeline.call_args\n        \n        # Verify that the query parameters were passed to the backend function\n        assert kwargs.get('min_runners') == 10\n        assert kwargs.get('specific_source') == 'equibase'\n"
}
