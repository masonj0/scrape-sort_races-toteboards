{
    "filepath": "./tests/test_fetcher.py",
    "content": "import pytest\nimport httpx\nfrom unittest.mock import AsyncMock, patch\n\nfrom src.paddock_parser.fetcher import get_page_content\n\n@pytest.mark.anyio\nasync def test_get_page_content_success():\n    \"\"\"\n    SPEC: `get_page_content` should return the text content of a successful response.\n    \"\"\"\n    url = \"http://test.com\"\n    request = httpx.Request(\"GET\", url)\n    expected_content = \"<html>Success</html>\"\n\n    # Create a mock response object that includes the request context.\n    # This is necessary for the `raise_for_status` method to work correctly.\n    mock_response = httpx.Response(200, text=expected_content, request=request)\n\n    with patch('httpx.AsyncClient.get', new_callable=AsyncMock, return_value=mock_response) as mock_get:\n        content = await get_page_content(url)\n        assert content == expected_content\n        mock_get.assert_called_once()\n\n@pytest.mark.anyio\nasync def test_get_page_content_post_success():\n    \"\"\"\n    SPEC: `get_page_content` should handle POST requests correctly.\n    \"\"\"\n    url = \"http://test.com/post\"\n    request = httpx.Request(\"POST\", url)\n    post_data = {\"key\": \"value\"}\n    expected_content = \"Post Success\"\n\n    mock_response = httpx.Response(200, text=expected_content, request=request)\n\n    with patch('httpx.AsyncClient.post', new_callable=AsyncMock, return_value=mock_response) as mock_post:\n        content = await get_page_content(url, post_data=post_data)\n        assert content == expected_content\n        mock_post.assert_called_once_with(url, headers=mock_post.call_args[1]['headers'], json=post_data, timeout=30.0)\n\n@pytest.mark.anyio\nasync def test_get_page_content_retry_on_http_error():\n    \"\"\"\n    SPEC: `get_page_content` should retry on HTTP status errors (e.g., 503).\n    \"\"\"\n    url = \"http://test.com/retry\"\n    request = httpx.Request(\"GET\", url)\n\n    # Configure the mock's side_effect to simulate a failure followed by a success.\n\n    mock_responses = [\n        httpx.Response(503, request=request),\n        httpx.Response(200, text=\"Success after retry\", request=request)\n    ]\n\n    with patch('httpx.AsyncClient.get', new_callable=AsyncMock, side_effect=mock_responses) as mock_get:\n        content = await get_page_content(url)\n        assert content == \"Success after retry\"\n        assert mock_get.call_count == 2\n\n@pytest.mark.anyio\nasync def test_get_page_content_retry_on_request_error():\n    \"\"\"\n    SPEC: `get_page_content` should retry on network-related request errors.\n    \"\"\"\n    url = \"http://test.com/network-error\"\n    request = httpx.Request(\"GET\", url)\n\n    # Configure the side_effect to simulate a network error, then a successful response.\n    side_effects = [\n        httpx.RequestError(\"Network Error\", request=request),\n        httpx.Response(200, text=\"Success after network error\", request=request)\n    ]\n\n    with patch('httpx.AsyncClient.get', new_callable=AsyncMock, side_effect=side_effects) as mock_get:\n        content = await get_page_content(url)\n        assert content == \"Success after network error\"\n        assert mock_get.call_count == 2\n\n@pytest.mark.anyio\nasync def test_get_page_content_fails_after_max_retries():\n    \"\"\"\n    SPEC: `get_page_content` should raise the exception after the final retry attempt fails.\n    \"\"\"\n    url = \"http://test.com/persistent-failure\"\n    request = httpx.Request(\"GET\", url)\n\n    # Configure the side_effect to consistently raise an HTTPStatusError.\n    # This simulates a persistent server-side failure.\n    side_effect = httpx.HTTPStatusError(\n        \"Internal Server Error\",\n        request=request,\n        response=httpx.Response(500, request=request)\n    )\n\n    with patch('httpx.AsyncClient.get', new_callable=AsyncMock, side_effect=side_effect) as mock_get:\n        with pytest.raises(httpx.HTTPStatusError):\n            await get_page_content(url)\n\n        # The tenacity decorator is configured to try 5 times in total.\n        assert mock_get.call_count == 5\n"
}