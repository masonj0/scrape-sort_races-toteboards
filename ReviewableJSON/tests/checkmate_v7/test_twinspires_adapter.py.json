{
    "filepath": "./tests/checkmate_v7/test_twinspires_adapter.py",
    "content": "import pytest\nimport os\nfrom unittest.mock import AsyncMock\nfrom src.checkmate_v7.services import TwinspiresAdapterV7, DefensiveFetcher\n\n# Determine absolute paths to the fixture files\nINDEX_FIXTURE_PATH = os.path.join(os.path.dirname(__file__), 'fixtures', 'twinspires_index.html')\nDETAIL_FIXTURE_PATH = os.path.join(os.path.dirname(__file__), 'fixtures', 'twinspires_race_detail.html')\n\n@pytest.fixture\ndef mock_fetcher():\n    \"\"\"Pytest fixture for a mock DefensiveFetcher.\"\"\"\n    return AsyncMock(spec=DefensiveFetcher)\n\n@pytest.fixture\ndef adapter(mock_fetcher):\n    \"\"\"Pytest fixture for the TwinspiresAdapterV7.\"\"\"\n    return TwinspiresAdapterV7(defensive_fetcher=mock_fetcher)\n\n@pytest.fixture\ndef index_html():\n    \"\"\"Reads the mock index HTML content from the fixture file.\"\"\"\n    with open(INDEX_FIXTURE_PATH, 'r') as f:\n        return f.read()\n\n@pytest.fixture\ndef detail_html():\n    \"\"\"Reads the mock race detail HTML content from the fixture file.\"\"\"\n    with open(DETAIL_FIXTURE_PATH, 'r') as f:\n        return f.read()\n\ndef test_parse_race_links(adapter, index_html):\n    \"\"\"Tests that the adapter can parse the index page for race links correctly.\"\"\"\n    links = adapter._parse_race_links(index_html)\n\n    # Should find 2 unique links, ignoring the results link and the duplicate\n    assert len(links) == 2\n    assert \"https://www.twinspires.com/adw/todays-tracks/churchill-downs/2025-09-15/races/5/race-card\" in links\n    assert \"https://www.twinspires.com/adw/todays-tracks/santa-anita/2025-09-15/races/8/race-card\" in links\n\ndef test_parse_single_race_detail(adapter, detail_html):\n    \"\"\"Tests that the adapter can parse runners from a detail page.\"\"\"\n    race = adapter._parse_single_race_detail(detail_html)\n\n    assert race is not None\n    assert race.track_name == \"Churchill Downs\"\n    assert race.race_number == 5\n\n    # \"No Odds Horse\" and \"Bad Odds Horse\" should be skipped\n    assert len(race.runners) == 2\n    assert race.runners[0].name == \"War Admiral\"\n    assert race.runners[0].program_number == 1\n    assert race.runners[0].odds == 3.5 # 5/2 + 1\n\n    assert race.runners[1].name == \"Affirmed\"\n    assert race.runners[1].program_number == 2\n    assert race.runners[1].odds == 4.0 # 3/1 + 1\n\n@pytest.mark.anyio\nasync def test_fetch_races_two_step(adapter, mock_fetcher, index_html, detail_html):\n    \"\"\"\n    Tests the full two-step fetch process, mocking both API calls.\n    \"\"\"\n    # Given: A more specific side effect for the mock fetcher\n    async def fetch_side_effect(url, response_type='text'):\n        if \"?sortOrder=nextUp\" in url:\n            return index_html  # This is unique to the index page URL\n        else:\n            return detail_html    # Assume any other call is for a detail page\n\n    mock_fetcher.fetch.side_effect = fetch_side_effect\n\n    # When\n    races = await adapter.fetch_races()\n\n    # Then\n    # Should have been called 3 times: 1 for index + 2 for details\n    assert mock_fetcher.fetch.call_count == 3\n\n    # Check that the final race objects are correctly populated\n    assert len(races) == 2\n\n    # Both races will have the same runners because we return the same detail page\n    assert races[0].runners[0].name == \"War Admiral\"\n    assert races[1].runners[1].name == \"Affirmed\"\n"
}