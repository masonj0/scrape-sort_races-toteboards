{
    "filepath": "./tests/checkmate_v7/test_api.py",
    "content": "import pytest\nfrom unittest.mock import patch, MagicMock, AsyncMock\nfrom fastapi.testclient import TestClient\nimport asyncio\n\n# Import the app from the correct module\nfrom src.checkmate_v7.api import app\nfrom src.checkmate_v7.models import Race # For creating mock race objects\n\nclient = TestClient(app)\n\n# --- Mocks and Fixtures ---\n\n@pytest.fixture\ndef mock_races():\n    \"\"\"Provides a sample list of Race objects.\"\"\"\n    return [\n        Race(race_id=\"R1\", track_name=\"Aqueduct\", runners=[]),\n        Race(race_id=\"R2\", track_name=\"Santa Anita\", runners=[]),\n    ]\n\n@pytest.fixture\ndef mock_statuses():\n    \"\"\"Provides a sample list of adapter status dictionaries, including the new 'notes' field.\"\"\"\n    return [\n        {\n            \"adapter_id\": \"FanDuelApiAdapterV7\",\n            \"status\": \"OK\", \"races_found\": 2, \"error_message\": None, \"notes\": \"Successfully parsed 2 races.\",\n            \"last_run\": \"2025-09-20T12:00:00Z\"\n        },\n        {\n            \"adapter_id\": \"TwinspiresModernAdapter\",\n            \"status\": \"ERROR\", \"races_found\": 0, \"error_message\": \"Connection timed out\", \"notes\": \"API Error: Connection timed out\",\n            \"last_run\": \"2025-09-20T12:00:05Z\"\n        }\n    ]\n\n# --- Tests ---\n\ndef test_get_adapter_status_endpoint_returns_correct_data(mock_statuses):\n    \"\"\"\n    SPEC: The /api/v1/adapters/status endpoint should call the orchestrator,\n    extract the status list, and return it as JSON with a 200 OK status.\n    \"\"\"\n    with patch('src.checkmate_v7.api.services.DataSourceOrchestrator') as MockOrchestrator:\n        mock_instance = MockOrchestrator.return_value\n        # Mock get_races to return the new tuple format\n        mock_instance.get_races = AsyncMock(return_value=([], mock_statuses))\n\n        response = client.get(\"/api/v1/adapters/status\")\n\n        # This will fail until the endpoint is created\n        assert response.status_code == 200\n        assert response.json() == mock_statuses\n\ndef test_get_races_all_endpoint_handles_new_signature(mock_races, mock_statuses):\n    \"\"\"\n    SPEC: The /api/v1/races/all endpoint must be updated to handle the new\n    tuple return signature from get_races, extracting only the race list.\n    \"\"\"\n    with patch('src.checkmate_v7.api.services.DataSourceOrchestrator') as MockOrchestrator:\n        mock_instance = MockOrchestrator.return_value\n        # Mock get_races to return the new tuple format\n        mock_instance.get_races.return_value = (mock_races, mock_statuses)\n\n        response = client.get(\"/api/v1/races/all\")\n\n        # This will fail until the endpoint is updated to unpack the tuple\n        assert response.status_code == 200\n\n        # The endpoint should ignore the statuses and return only the races,\n        # which then get mapped to the RaceDataSchema.\n        response_data = response.json()\n        assert len(response_data) == 2\n        assert response_data[0][\"id\"] == \"R1\"\n        assert response_data[1][\"track\"] == \"Santa Anita\"\n\ndef test_post_refresh_action_endpoint():\n    \"\"\"\n    Tests the new POST /api/v1/actions/refresh endpoint.\n    It should simply return a 200 OK with the specified acknowledgement message.\n    \"\"\"\n    # Act\n    response = client.post(\"/api/v1/actions/refresh\")\n\n    # Assert\n    assert response.status_code == 200\n    expected_response = {\n        \"status\": \"acknowledged\",\n        \"message\": \"A data refresh can be triggered by hitting the primary data endpoints.\"\n    }\n    assert response.json() == expected_response\n"
}