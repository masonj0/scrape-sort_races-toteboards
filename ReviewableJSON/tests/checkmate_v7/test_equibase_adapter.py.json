{
    "filepath": "./tests/checkmate_v7/test_equibase_adapter.py",
    "content": "import pytest\nimport os\nfrom unittest.mock import AsyncMock\nfrom src.checkmate_v7.services import EquibaseAdapterV7, DefensiveFetcher\nfrom src.checkmate_v7.models import Race\n\n# Determine absolute paths to the fixture files\nSCHEDULE_FIXTURE_PATH = os.path.join(os.path.dirname(__file__), 'fixtures', 'equibase_entries.html')\nDETAIL_FIXTURE_PATH = os.path.join(os.path.dirname(__file__), 'fixtures', 'equibase_race_detail.html')\n\n@pytest.fixture\ndef mock_fetcher():\n    \"\"\"Pytest fixture for a mock DefensiveFetcher.\"\"\"\n    return AsyncMock(spec=DefensiveFetcher)\n\n@pytest.fixture\ndef adapter(mock_fetcher):\n    \"\"\"Pytest fixture for the EquibaseAdapterV7.\"\"\"\n    return EquibaseAdapterV7(defensive_fetcher=mock_fetcher)\n\n@pytest.fixture\ndef schedule_html():\n    \"\"\"Reads the mock schedule HTML content from the fixture file.\"\"\"\n    with open(SCHEDULE_FIXTURE_PATH, 'r') as f:\n        return f.read()\n\n@pytest.fixture\ndef detail_html():\n    \"\"\"Reads the mock race detail HTML content from the fixture file.\"\"\"\n    with open(DETAIL_FIXTURE_PATH, 'r') as f:\n        return f.read()\n\ndef test_parse_schedule(adapter, schedule_html):\n    \"\"\"Tests that the adapter can parse the main schedule page correctly.\"\"\"\n    partial_races, detail_urls = adapter._parse_race_schedule(schedule_html)\n\n    assert len(partial_races) == 3\n    assert len(detail_urls) == 3\n\n    assert partial_races[0].track_name == \"Aqueduct\"\n    assert partial_races[0].race_number == 1\n    assert detail_urls[0] == \"/entries/AQU/20250915/1\"\n\n    assert partial_races[2].track_name == \"Gulfstream Park\"\n    assert partial_races[2].race_number == 8\n\ndef test_parse_runners_from_detail_page(adapter, detail_html):\n    \"\"\"Tests that the adapter can parse runners from a detail page.\"\"\"\n    runners = adapter._parse_runners_from_detail_page(detail_html)\n\n    assert len(runners) == 3\n    assert runners[0].name == \"Gallant Fox\"\n    assert runners[0].program_number == 1\n    assert runners[2].name == \"Citation\"\n    assert runners[2].program_number == 3\n\n@pytest.mark.anyio\nasync def test_fetch_races_two_step(adapter, mock_fetcher, schedule_html, detail_html):\n    \"\"\"\n    Tests the full two-step fetch process, mocking both API calls.\n    \"\"\"\n    # Given: A side effect for the mock fetcher to return different HTML\n    # based on the URL being fetched.\n    async def fetch_side_effect(url):\n        if \"ENT_\" in url:\n            return schedule_html  # It's the main schedule page\n        else:\n            return detail_html    # It's a race detail page\n\n    mock_fetcher.fetch.side_effect = fetch_side_effect\n\n    # When\n    races = await adapter.fetch_races()\n\n    # Then\n    # Should have been called 4 times: 1 for schedule + 3 for details\n    assert mock_fetcher.fetch.call_count == 4\n\n    # Check that the final race objects are correctly populated\n    assert len(races) == 3\n\n    # The first race should have runners from the detail page\n    assert races[0].track_name == \"Aqueduct\"\n    assert len(races[0].runners) == 3\n    assert races[0].runners[0].name == \"Gallant Fox\"\n\n    # The third race should also have runners\n    assert races[2].track_name == \"Gulfstream Park\"\n    assert len(races[2].runners) == 3\n    assert races[2].runners[1].name == \"Zev\"\n"
}