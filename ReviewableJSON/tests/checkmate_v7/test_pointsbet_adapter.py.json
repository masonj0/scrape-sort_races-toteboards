{
    "filepath": "./tests/checkmate_v7/test_pointsbet_adapter.py",
    "content": "import pytest\nimport json\nimport os\nfrom unittest.mock import AsyncMock\nfrom src.checkmate_v7.services import PointsBetAdapterV7, DefensiveFetcher\n\n# Determine the absolute path to the fixture file\nFIXTURE_PATH = os.path.join(os.path.dirname(__file__), 'fixtures', 'pointsbet_races.json')\n\n@pytest.fixture\ndef mock_fetcher():\n    \"\"\"Pytest fixture for a mock DefensiveFetcher.\"\"\"\n    return AsyncMock(spec=DefensiveFetcher)\n\n@pytest.fixture\ndef adapter(mock_fetcher):\n    \"\"\"Pytest fixture for the PointsBetAdapterV7.\"\"\"\n    return PointsBetAdapterV7(defensive_fetcher=mock_fetcher)\n\n@pytest.fixture\ndef mock_json_content():\n    \"\"\"Reads the mock JSON content from the fixture file.\"\"\"\n    with open(FIXTURE_PATH, 'r') as f:\n        return json.load(f)\n\ndef test_parse_races_with_runners(adapter, mock_json_content):\n    \"\"\"\n    Tests that the adapter can successfully parse races including runners\n    from the mock JSON fixture.\n    \"\"\"\n    # When\n    parsed_races = adapter._parse_races(mock_json_content.get('events', []))\n\n    # Then\n    # The second race in the fixture has no runners, so only 1 should be parsed.\n    assert len(parsed_races) == 1\n\n    race = parsed_races[0]\n    assert race.race_id == \"PB_R_12345\"\n    assert race.track_name == \"Flemington\"\n    assert race.race_number == 7\n\n    # All 4 runners should be parsed as they have a runnerNumber\n    assert len(race.runners) == 4\n\n    # Check details of the parsed runners\n    assert race.runners[0].name == \"Lightning Bolt\"\n    assert race.runners[0].program_number == 1\n    assert race.runners[0].odds == 3.50\n\n    assert race.runners[1].name == \"Steady Eddie\"\n    assert race.runners[1].program_number == 2\n    assert race.runners[1].odds == 8.00\n\n    # This runner has no odds, but should still be included\n    assert race.runners[2].name == \"No Show\"\n    assert race.runners[2].program_number == 3\n    assert race.runners[2].odds is None\n\n    assert race.runners[3].name == \"Just Happy To Be Here\"\n    assert race.runners[3].program_number == 4\n    assert race.runners[3].odds == 51.00\n\n@pytest.mark.anyio\nasync def test_fetch_races_end_to_end(adapter, mock_fetcher, mock_json_content):\n    \"\"\"\n    Tests the end-to-end flow of the fetch_races method using the detailed fixture.\n    \"\"\"\n    # Given\n    # Configure the mock fetcher to return the mock JSON as a string\n    mock_fetcher.fetch.return_value = json.dumps(mock_json_content)\n\n    # When\n    races = await adapter.fetch_races()\n\n    # Then\n    mock_fetcher.fetch.assert_called_once_with(adapter.API_URL)\n\n    # Assert the parsing logic produced the expected race and runners\n    assert len(races) == 1\n    assert len(races[0].runners) == 4\n    assert races[0].runners[0].name == \"Lightning Bolt\"\n"
}