{
    "filepath": "./tests/adapters/test_twinspires_adapter.py",
    "content": "import pytest\nfrom pathlib import Path\nfrom unittest.mock import patch, AsyncMock\n\nfrom src.paddock_parser.adapters.twinspires_adapter import TwinSpiresAdapter\nfrom src.paddock_parser.base import NormalizedRace, NormalizedRunner\n\n@pytest.fixture\ndef mock_race_detail_html():\n    \"\"\"Loads the mock TwinSpires race detail HTML content.\"\"\"\n    fixture_path = Path(__file__).parent / \"mock_data\" / \"twinspires_race_detail.html\"\n    return fixture_path.read_text()\n\n@pytest.fixture\ndef mock_todays_tracks_html():\n    \"\"\"Loads the mock TwinSpires 'Today's Tracks' HTML content.\"\"\"\n    fixture_path = Path(__file__).parent / \"mock_data\" / \"twinspires_todays_tracks.html\"\n    return fixture_path.read_text()\n\ndef test_twinspires_adapter_parse_single_race(mock_race_detail_html):\n    \"\"\"\n    Tests that the _parse_single_race_detail helper method correctly\n    parses a single race detail page into a NormalizedRace object.\n    \"\"\"\n    # 1. Setup\n    adapter = TwinSpiresAdapter()\n\n    # 2. Execution\n    # We are testing the internal helper method directly\n    parsed_race = adapter._parse_single_race_detail(mock_race_detail_html)\n\n    # 3. Assertions\n    assert isinstance(parsed_race, NormalizedRace)\n    assert parsed_race.track_name == \"Churchill Downs\"\n    assert parsed_race.race_number == 1\n    # The third runner \"Scratched Runner\" has invalid odds and should be skipped\n    assert parsed_race.number_of_runners == 2\n    assert len(parsed_race.runners) == 2\n\n    # --- Detailed assertions for the first runner ---\n    first_runner = parsed_race.runners[0]\n    assert isinstance(first_runner, NormalizedRunner)\n    assert first_runner.name == \"Mighty Steed\"\n    assert first_runner.program_number == 1\n    # Odds are \"5/2\" -> (5/2) + 1.0 = 3.5\n    assert first_runner.odds == 3.5\n\n    # --- Detailed assertions for the second runner ---\n    second_runner = parsed_race.runners[1]\n    assert second_runner.name == \"Galloping Power\"\n    assert second_runner.program_number == 2\n    # Odds are \"10\" -> 10.0 + 1.0 = 11.0\n    assert second_runner.odds == 11.0\n\n@pytest.mark.anyio\n@patch('src.paddock_parser.adapters.twinspires_adapter.get_page_content', new_callable=AsyncMock)\nasync def test_twinspires_adapter_fetch_full_process(mock_get_page_content, mock_todays_tracks_html, mock_race_detail_html):\n    \"\"\"\n    Tests the full two-stage fetch process of the TwinSpiresAdapter.\n    \"\"\"\n    # 1. Setup\n    # The first call to get_page_content should return the index page.\n    # Subsequent calls should return the detail page for each link found.\n    mock_get_page_content.side_effect = [\n        mock_todays_tracks_html,\n        mock_race_detail_html,\n        mock_race_detail_html,\n        mock_race_detail_html\n    ]\n    adapter = TwinSpiresAdapter()\n\n    # 2. Execution\n    fetched_races = await adapter.fetch()\n\n    # 3. Assertions\n    # The mock index page has 3 valid race links.\n    # So, get_page_content should be called 4 times (1 for index + 3 for details).\n    assert mock_get_page_content.call_count == 4\n\n    # The mock detail page has 2 valid runners. Since we return the same detail\n    # page for all 3 links, we expect 3 identical race objects.\n    assert len(fetched_races) == 3\n    assert fetched_races[0].track_name == \"Churchill Downs\"\n    assert fetched_races[0].number_of_runners == 2\n"
}