{
    "file_path": "fortuna_watchman.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: The Watchman (v2 - Score-Aware)\n# ==============================================================================\n# This is the master orchestrator for the Fortuna Faucet project.\n# It executes the full, end-to-end handicapping strategy autonomously.\n# ==============================================================================\n\nimport asyncio\nimport httpx\nimport structlog\nfrom datetime import datetime, timedelta, timezone\nfrom typing import List\n\nfrom python_service.config import get_settings\nfrom python_service.engine import FortunaEngine\nfrom python_service.analyzer import AnalyzerEngine\nfrom python_service.models import Race\nfrom live_monitor import LiveOddsMonitor\n\nlog = structlog.get_logger(__name__)\n\nclass Watchman:\n    \"\"\"Orchestrates the daily operation of the Fortuna Faucet.\"\"\"\n\n    def __init__(self):\n        self.settings = get_settings()\n        self.odds_engine = FortunaEngine(config=self.settings)\n        self.analyzer_engine = AnalyzerEngine()\n        self.live_monitor = LiveOddsMonitor(config=self.settings)\n\n    async def get_initial_targets(self) -> List[Race]:\n        \"\"\"Uses the OddsEngine and AnalyzerEngine to get the day's ranked targets.\"\"\"\n        log.info(\"Watchman: Acquiring and ranking initial targets for the day...\")\n        today_str = datetime.now(timezone.utc).strftime('%Y-%m-%d')\n        try:\n            background_tasks = set() # Create a dummy set for background tasks\n            aggregated_data = await self.odds_engine.get_races(today_str, background_tasks)\n            all_races = aggregated_data.get('races', [])\n            if not all_races:\n                log.warning(\"Watchman: No races returned from OddsEngine.\")\n                return []\n\n            analyzer = self.analyzer_engine.get_analyzer('trifecta')\n            qualified_races = analyzer.qualify_races(all_races) # This now returns a sorted list with scores\n            log.info(\"Watchman: Initial target acquisition and ranking complete\", target_count=len(qualified_races))\n\n            # Log the top targets for better observability\n            for race in qualified_races[:5]:\n                log.info(\"Top Target Found\",\n                    score=race.qualification_score,\n                    venue=race.venue,\n                    race_number=race.race_number,\n                    post_time=race.start_time.isoformat()\n                )\n            return qualified_races\n        except Exception as e:\n            log.error(\"Watchman: Failed to get initial targets\", error=str(e), exc_info=True)\n            return []\n\n    async def run_tactical_monitoring(self, targets: List[Race]):\n        \"\"\"Uses the LiveOddsMonitor on each target as it approaches post time.\"\"\"\n        log.info(\"Watchman: Entering tactical monitoring loop.\")\n        active_targets = list(targets)\n        async with httpx.AsyncClient() as client:\n            while active_targets:\n                now = datetime.now(timezone.utc)\n\n                # Find races that are within the 5-minute monitoring window\n                races_to_monitor = [r for r in active_targets if r.start_time.replace(tzinfo=timezone.utc) > now and r.start_time.replace(tzinfo=timezone.utc) < now + timedelta(minutes=5)]\n\n                if races_to_monitor:\n                    for race in races_to_monitor:\n                        log.info(\"Watchman: Deploying Live Monitor for approaching target\",\n                            race_id=race.id,\n                            venue=race.venue,\n                            score=race.qualification_score\n                        )\n                        updated_race = await self.live_monitor.monitor_race(race, client)\n                        log.info(\"Watchman: Live monitoring complete for race\", race_id=updated_race.id)\n                        # Remove from target list to prevent re-monitoring\n                        active_targets = [t for t in active_targets if t.id != race.id]\n\n                if not active_targets:\n                    break # Exit loop if all targets are processed\n\n                await asyncio.sleep(30) # Check for upcoming races every 30 seconds\n\n        log.info(\"Watchman: All targets for the day have been monitored. Mission complete.\")\n\n    async def execute_daily_protocol(self):\n        \"\"\"The main, end-to-end orchestration method.\"\"\"\n        log.info(\"--- Fortuna Watchman Daily Protocol: ACTIVE ---\")\n        initial_targets = await self.get_initial_targets()\n        if initial_targets:\n            await self.run_tactical_monitoring(initial_targets)\n        else:\n            log.info(\"Watchman: No initial targets found. Shutting down for the day.\")\n\n        await self.odds_engine.close()\n        log.info(\"--- Fortuna Watchman Daily Protocol: COMPLETE ---\")\n\nasync def main():\n    from python_service.logging_config import configure_logging\n    configure_logging()\n    watchman = Watchman()\n    await watchman.execute_daily_protocol()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())"
}