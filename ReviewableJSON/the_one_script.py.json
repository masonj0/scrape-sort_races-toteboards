{
    "filepath": "./the_one_script.py",
    "content": "#!/usr/bin/env python3\n\"\"\"\nThe One Script: The Complete Paddock Parser \"Modern Renaissance\"\nA single, self-contained application for finding real-time \"Checkmate\" betting opportunities.\nPowered by The Racing API.\n\nSetup:\n1. Create a file named .env in this directory.\n2. Add your API key to it: RACING_API_KEY=\"YOUR_KEY\"\n3. Run: pip install streamlit httpx python-dotenv\n4. Execute: streamlit run the_one_script.py\n\"\"\"\n\nimport asyncio\nimport streamlit as st\nimport time\nimport os\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, date, timedelta\nimport httpx\nfrom dotenv import load_dotenv\n\n# --- Configuration & Setup ---\nload_dotenv()\nAPI_KEY = os.getenv(\"RACING_API_KEY\")\nBASE_URL = \"https://api.theracingapi.com/v1\"\n\n#\n# --- PILLAR 2: THE GUARDIAN (Data Models) ---\n#\n\n@dataclass\nclass NormalizedRunner:\n    \"\"\"A simple dataclass for a runner with its odds.\"\"\"\n    name: str\n    odds: float = 0.0\n\n@dataclass\nclass NormalizedRace:\n    \"\"\"A simple dataclass for a race, containing its runners.\"\"\"\n    track: str\n    race_number: int\n    race_time: datetime\n    runners: list[NormalizedRunner] = field(default_factory=list)\n\n#\n# --- PILLAR 1: THE TEMPLATE (The One Adapter) ---\n#\n\nasync def fetch_racing_api_data(fetch_date: date) -> list[NormalizedRace]:\n    \"\"\"Fetches and parses race data from The Racing API.\"\"\"\n    if not API_KEY:\n        st.error(\"RACING_API_KEY not found in .env file. Please create the file and add your key.\")\n        return []\n\n    url = f\"{BASE_URL}/racecards\"\n    params = {\n        \"api_key\": API_KEY,\n        \"date\": fetch_date.strftime('%Y-%m-%d'),\n        \"region\": \"USA\"\n    }\n    all_races = []\n\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, params=params, timeout=30.0)\n            response.raise_for_status()\n            json_content = response.json()\n\n            for race in json_content.get('racecards', []):\n                try:\n                    runners = []\n                    for horse in race.get('runners', []):\n                        odds = horse.get('odds', {}).get('decimal')\n                        if odds:\n                            runners.append(NormalizedRunner(name=horse.get('name'), odds=float(odds)))\n\n                    if runners:\n                        all_races.append(NormalizedRace(\n                            track=race.get('course'),\n                            race_number=int(race.get('race_num')),\n                            race_time=datetime.fromisoformat(race.get('off_time')),\n                            runners=runners\n                        ))\n                except Exception as e:\n                    st.warning(f\"Skipping a malformed race: {e}\")\n                    continue\n        except httpx.HTTPStatusError as e:\n            st.error(f\"API Error: {e.response.status_code} - {e.response.text}\")\n        except Exception as e:\n            st.error(f\"An unexpected error occurred: {e}\")\n            \n    return all_races\n\n#\n# --- PILLAR 3: THE BRAIN (The Checkmate Scorer) ---\n#\n\ndef get_dynamic_odds_thresholds(field_size: int) -> tuple[float, float]:\n    \"\"\"Returns (fav_threshold, second_fav_threshold) based on field size.\"\"\"\n    if field_size <= 4: return (0.5, 2.0)\n    if field_size == 5: return (0.8, 3.0)\n    if field_size == 6: return (1.0, 3.5)\n    return (1.0, 4.0)\n\ndef find_checkmate_opportunities(races: list[NormalizedRace]) -> list[NormalizedRace]:\n    \"\"\"Applies the dynamic 'Checkmate' filter to a list of races.\"\"\"\n    opportunities = []\n    for race in races:\n        if not race.runners or len(race.runners) < 2 or len(race.runners) >= 7:\n            continue\n\n        sorted_runners = sorted(race.runners, key=lambda r: r.odds)\n        field_size = len(sorted_runners)\n        fav_threshold, second_fav_threshold = get_dynamic_odds_thresholds(field_size)\n        \n        favorite = sorted_runners[0]\n        second_favorite = sorted_runners[1]\n\n        if favorite.odds > fav_threshold and second_favorite.odds > second_fav_threshold:\n            opportunities.append(race)\n            \n    return opportunities\n\n#\n# --- PILLAR 4: THE FACE (The Live Dashboard) ---\n#\n\ndef main():\n    \"\"\"Main function to run the Streamlit application.\"\"\"\n    st.set_page_config(page_title=\"Checkmate Alert System\", layout=\"wide\")\n    st.title(\"\ud83c\udfc7 Checkmate Alert System\")\n    st.write(\"Live monitoring for US Thoroughbred races using The Racing API.\")\n\n    if not API_KEY:\n        st.error(\"API Key is missing. Please set up your .env file.\")\n        return\n\n    if \"monitoring\" not in st.session_state:\n        st.session_state.monitoring = False\n\n    def toggle_monitoring():\n        st.session_state.monitoring = not st.session_state.monitoring\n\n    button_text = \"Stop Monitoring\" if st.session_state.monitoring else \"Start Monitoring\"\n    st.button(button_text, on_click=toggle_monitoring)\n\n    if st.session_state.monitoring:\n        placeholder = st.empty()\n        while st.session_state.monitoring:\n            with placeholder.container():\n                current_time_str = datetime.now().strftime('%H:%M:%S')\n                st.info(f\"Scanning for opportunities... Last update: {current_time_str}\")\n\n                all_races = asyncio.run(fetch_racing_api_data(date.today()))\n                \n                if not all_races:\n                    st.warning(\"No race data could be fetched. Waiting for the next cycle.\")\n                    time.sleep(60)\n                    continue\n\n                now = datetime.utcnow()\n                upcoming_races = [\n                    race for race in all_races \n                    if race.race_time > now and race.race_time - now < timedelta(minutes=30)\n                ]\n                \n                opportunities = find_checkmate_opportunities(upcoming_races)\n\n                st.subheader(\"Checkmate Opportunities (Next 30 Mins)\")\n                if opportunities:\n                    st.dataframe(opportunities)\n                    for race in opportunities:\n                        mtp = (race.race_time - now).seconds // 60\n                        if mtp <= 1:\n                            st.toast(f\"\ud83d\udea8 CHECKMATE! {race.track} R{race.race_number} at {mtp} MTP!\", icon=\"\ud83d\udea8\")\n                else:\n                    st.write(\"No Checkmate opportunities found in the current upcoming races.\")\n            \n            time.sleep(60)\n        st.success(\"Monitoring stopped.\")\n\nif __name__ == \"__main__\":\n    main()"
}