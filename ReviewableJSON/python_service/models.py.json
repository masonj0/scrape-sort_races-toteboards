{
    "file_path": "python_service/models.py",
    "content": "# python_service/models.py\n\nfrom pydantic import BaseModel, Field, field_validator\nfrom typing import List, Optional, Dict\nfrom datetime import datetime, date\nfrom decimal import Decimal\n\nclass OddsData(BaseModel):\n    win: Optional[Decimal] = None\n    source: str\n    last_updated: datetime\n\n    @field_validator('win')\n    def win_must_be_positive(cls, v):\n        if v is not None and v <= 1.0:\n            raise ValueError('Odds must be greater than 1.0')\n        return v\n\nclass Runner(BaseModel):\n    number: int = Field(..., gt=0, lt=100)\n    name: str = Field(..., max_length=100)\n    scratched: bool = False\n    odds: Dict[str, OddsData] = {}\n\nclass Race(BaseModel):\n    id: str\n    venue: str\n    race_number: int = Field(..., gt=0, lt=21)\n    start_time: datetime\n    runners: List[Runner]\n    source: str\n\n    @field_validator('runners')\n    def runner_numbers_must_be_unique(cls, v):\n        numbers = [r.number for r in v]\n        if len(numbers) != len(set(numbers)):\n            raise ValueError('Runner numbers must be unique within a race')\n        return v\n\nclass SourceInfo(BaseModel):\n    name: str\n    status: str\n    races_fetched: int\n    error_message: Optional[str] = None\n    fetch_duration: float\n\nclass FetchMetadata(BaseModel):\n    fetch_time: datetime\n    sources_queried: List[str]\n    sources_successful: int\n    total_races: int\n\nclass AggregatedResponse(BaseModel):\n    date: date\n    races: List[Race]\n    sources: List[SourceInfo]\n    metadata: FetchMetadata"
}