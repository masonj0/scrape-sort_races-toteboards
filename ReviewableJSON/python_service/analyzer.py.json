{
    "file_path": "python_service/analyzer.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List, Dict, Type, Optional\nimport structlog\nfrom decimal import Decimal\n\nfrom python_service.models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\n# --- Corrected Helper Function ---\ndef _get_best_win_odds(runner: Runner) -> Optional[Decimal]:\n    \"\"\"Helper to find the best (lowest) win odds for a runner from any source.\"\"\"\n    if not runner.odds:\n        return None\n\n    valid_odds = [\n        odds_data.win\n        for odds_data in runner.odds.values()\n        if odds_data and odds_data.win is not None\n    ]\n\n    return min(valid_odds) if valid_odds else None\n\n\n# --- 1. The Abstract Base Class (The Interface) ---\nclass BaseAnalyzer(ABC):\n    \"\"\"The abstract interface for all future analyzer plugins.\"\"\"\n    def __init__(self, **kwargs):\n        pass\n\n    @abstractmethod\n    def qualify_races(self, races: List[Race]) -> List[Race]:\n        \"\"\"The core method every analyzer must implement.\"\"\"\n        pass\n\n\n# --- 2. The Concrete Implementation (The First Plugin) ---\nclass TrifectaAnalyzer(BaseAnalyzer):\n    \"\"\"Analyzes races to find opportunities based on the 'Trifecta of Factors'.\"\"\"\n    def __init__(self, max_field_size: int = 10, min_favorite_odds: float = 2.5, min_second_favorite_odds: float = 4.0):\n        self.max_field_size = max_field_size\n        self.min_favorite_odds = Decimal(str(min_favorite_odds))\n        self.min_second_favorite_odds = Decimal(str(min_second_favorite_odds))\n        log.info(\n            \"TrifectaAnalyzer initialized with TRUE TRIFECTA logic\",\n            max_field_size=self.max_field_size,\n            min_favorite_odds=self.min_favorite_odds,\n            min_second_favorite_odds=self.min_second_favorite_odds\n        )\n\n    def qualify_races(self, races: List[Race]) -> List[Race]:\n        \"\"\"Filters a list of races based on the true handicapping criteria.\"\"\"\n        qualified_races = []\n        for race in races:\n            active_runners = [r for r in race.runners if not r.scratched]\n\n            # FACTOR 2: Field size, the lower the better\n            if len(active_runners) > self.max_field_size:\n                log.debug(f\"Race {race.id} disqualified: Field size too large ({len(active_runners)} > {self.max_field_size}).\")\n                continue\n\n            runners_with_odds = []\n            for runner in active_runners:\n                best_odds = _get_best_win_odds(runner)\n                if best_odds is not None:\n                    runners_with_odds.append((runner, best_odds))\n\n            if len(runners_with_odds) < 2:\n                log.debug(f\"Race {race.id} disqualified: Not enough runners with odds.\")\n                continue\n\n            runners_with_odds.sort(key=lambda x: x[1])\n\n            favorite_odds = runners_with_odds[0][1]\n            second_favorite_odds = runners_with_odds[1][1]\n\n            # FACTOR 3: Odds for the favorite horse cannot be 'chalky'\n            if favorite_odds < self.min_favorite_odds:\n                log.debug(f\"Race {race.id} disqualified: Favorite odds too low ({favorite_odds} < {self.min_favorite_odds}).\")\n                continue\n\n            # FACTOR 1: Second-favorite odds, the higher the better\n            if second_favorite_odds < self.min_second_favorite_odds:\n                log.debug(f\"Race {race.id} disqualified: Second favorite odds too low ({second_favorite_odds} < {self.min_second_favorite_odds}).\")\n                continue\n\n            qualified_races.append(race)\n\n        log.info(\"True Trifecta qualification complete\", total_races=len(races), qualified_races=len(qualified_races))\n        return qualified_races\n\n\n# --- 3. The Orchestrator (The Engine) ---\nclass AnalyzerEngine:\n    \"\"\"Discovers and manages all available analyzer plugins.\"\"\"\n    def __init__(self):\n        self.analyzers: Dict[str, Type[BaseAnalyzer]] = {}\n        self._discover_analyzers()\n\n    def _discover_analyzers(self):\n        # In a real plugin system, this would inspect a folder.\n        # For now, we register them manually.\n        self.register_analyzer('trifecta', TrifectaAnalyzer)\n        log.info(\"AnalyzerEngine discovered plugins\", available_analyzers=list(self.analyzers.keys()))\n\n    def register_analyzer(self, name: str, analyzer_class: Type[BaseAnalyzer]):\n        self.analyzers[name] = analyzer_class\n\n    def get_analyzer(self, name: str, **kwargs) -> BaseAnalyzer:\n        analyzer_class = self.analyzers.get(name)\n        if not analyzer_class:\n            log.error(\"Requested analyzer not found\", requested_analyzer=name)\n            raise ValueError(f\"Analyzer '{name}' not found.\")\n        return analyzer_class(**kwargs)"
}