{
    "file_path": "python_service/analyzer.py",
    "content": "from abc import ABC, abstractmethod\nfrom typing import List, Dict, Type, Optional\nimport structlog\nfrom decimal import Decimal\n\nfrom python_service.models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\ndef _get_best_win_odds(runner: Runner) -> Optional[Decimal]:\n    \"\"\"Helper to find the best (lowest) win odds for a runner from any source.\"\"\"\n    if not runner.odds:\n        return None\n\n    valid_odds = [\n        odds_data.win\n        for odds_data in runner.odds.values()\n        if odds_data and odds_data.win is not None\n    ]\n\n    return min(valid_odds) if valid_odds else None\n\nclass BaseAnalyzer(ABC):\n    \"\"\"The abstract interface for all future analyzer plugins.\"\"\"\n    def __init__(self, **kwargs):\n        pass\n\n    @abstractmethod\n    def qualify_races(self, races: List[Race]) -> List[Race]:\n        \"\"\"The core method every analyzer must implement.\"\"\"\n        pass\n\nclass TrifectaAnalyzer(BaseAnalyzer):\n    \"\"\"Analyzes races and assigns a qualification score based on the 'Trifecta of Factors'.\"\"\"\n    def __init__(self, max_field_size: int = 10, min_favorite_odds: float = 2.5, min_second_favorite_odds: float = 4.0):\n        self.max_field_size = max_field_size\n        self.min_favorite_odds = Decimal(str(min_favorite_odds))\n        self.min_second_favorite_odds = Decimal(str(min_second_favorite_odds))\n\n    def qualify_races(self, races: List[Race]) -> List[Race]:\n        \"\"\"Filters and scores races, returning a sorted list of qualified opportunities.\"\"\"\n        qualified_races = []\n        for race in races:\n            score = self._evaluate_race(race)\n            if score is not None:\n                race.qualification_score = score\n                qualified_races.append(race)\n\n        # Sort the qualified races by score, descending\n        qualified_races.sort(key=lambda r: r.qualification_score, reverse=True)\n        log.info(\"Qualification and scoring complete\", qualified_count=len(qualified_races))\n        return qualified_races\n\n    def _evaluate_race(self, race: Race) -> Optional[float]:\n        \"\"\"Evaluates a single race and returns a qualification score if it passes, else None.\"\"\"\n        active_runners = [r for r in race.runners if not r.scratched]\n\n        runners_with_odds = []\n        for runner in active_runners:\n            best_odds = _get_best_win_odds(runner)\n            if best_odds is not None:\n                runners_with_odds.append((runner, best_odds))\n\n        if len(runners_with_odds) < 2: return None\n\n        runners_with_odds.sort(key=lambda x: x[1])\n        favorite_odds = runners_with_odds[0][1]\n        second_favorite_odds = runners_with_odds[1][1]\n\n        # --- Apply the Trifecta of Factors as hard filters ---\n        if len(active_runners) > self.max_field_size: return None\n        if favorite_odds < self.min_favorite_odds: return None\n        if second_favorite_odds < self.min_second_favorite_odds: return None\n\n        # --- Calculate Qualification Score (as inspired by the TypeScript Genesis) ---\n        field_score = (self.max_field_size - len(active_runners)) / self.max_field_size\n        # Normalize odds scores - cap influence of extremely high odds\n        fav_odds_score = min(float(favorite_odds) / 10.0, 1.0)\n        sec_fav_odds_score = min(float(second_favorite_odds) / 15.0, 1.0)\n\n        # Weighted average\n        odds_score = (fav_odds_score * 0.6) + (sec_fav_odds_score * 0.4)\n        final_score = (field_score * 0.3) + (odds_score * 0.7)\n\n        return round(final_score * 100, 2)\n\nclass AnalyzerEngine:\n    \"\"\"Discovers and manages all available analyzer plugins.\"\"\"\n    def __init__(self):\n        self.analyzers: Dict[str, Type[BaseAnalyzer]] = {}\n        self._discover_analyzers()\n\n    def _discover_analyzers(self):\n        # In a real plugin system, this would inspect a folder.\n        # For now, we register them manually.\n        self.register_analyzer('trifecta', TrifectaAnalyzer)\n        log.info(\"AnalyzerEngine discovered plugins\", available_analyzers=list(self.analyzers.keys()))\n\n    def register_analyzer(self, name: str, analyzer_class: Type[BaseAnalyzer]):\n        self.analyzers[name] = analyzer_class\n\n    def get_analyzer(self, name: str, **kwargs) -> BaseAnalyzer:\n        analyzer_class = self.analyzers.get(name)\n        if not analyzer_class:\n            log.error(\"Requested analyzer not found\", requested_analyzer=name)\n            raise ValueError(f\"Analyzer '{name}' not found.\")\n        return analyzer_class(**kwargs)"
}