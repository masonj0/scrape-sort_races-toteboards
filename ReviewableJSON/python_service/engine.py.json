{
    "file_path": "python_service/engine.py",
    "content": "# python_service/engine.py\n\nimport asyncio\nimport logging\nimport httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Tuple\n\nfrom .adapters.base import BaseAdapter\nfrom .adapters.betfair_adapter import BetfairAdapter\nfrom .adapters.tvg_adapter import TVGAdapter\nfrom .adapters.racing_and_sports_adapter import RacingAndSportsAdapter\nfrom .adapters.pointsbet_adapter import PointsBetAdapter\n\nclass OddsEngine:\n    def __init__(self):\n        self.logger = logging.getLogger(self.__class__.__name__)\n        self.adapters: List[BaseAdapter] = [\n            BetfairAdapter(), TVGAdapter(), \n            RacingAndSportsAdapter(), PointsBetAdapter()\n        ]\n        self.http_client = httpx.AsyncClient()\n\n    async def close(self):\n        await self.http_client.aclose()\n\n    async def _time_adapter_fetch(self, adapter: BaseAdapter, date: str) -> Tuple[str, Dict[str, Any], float]:\n        \"\"\"Wraps an adapter's fetch call to accurately measure its duration.\"\"\"\n        start_time = datetime.now()\n        try:\n            result = await adapter.fetch_races(date, self.http_client)\n            duration = (datetime.now() - start_time).total_seconds()\n            return (adapter.source_name, result, duration)\n        except Exception as e:\n            duration = (datetime.now() - start_time).total_seconds()\n            self.logger.error(f\"Adapter {adapter.source_name} raised an unhandled exception: {e}\")\n            # Propagate the exception along with the timing info\n            raise e from None\n\n    async def fetch_all_odds(self, date: str, source_filter: str = None) -> Dict[str, Any]:\n        target_adapters = self.adapters\n        if source_filter:\n            target_adapters = [a for a in self.adapters if a.source_name.lower() == source_filter.lower()]\n        \n        tasks = [self._time_adapter_fetch(adapter, date) for adapter in target_adapters]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        successful_results = []\n        source_infos = []\n        all_races = []\n\n        for result in results:\n            if isinstance(result, Exception):\n                # This path is for unexpected errors in the wrapper or adapter itself\n                # The adapter name is not easily available here, logging is key\n                self.logger.error(f\"A fetch task failed unexpectedly: {result}\", exc_info=True)\n                continue\n\n            adapter_name, adapter_result, fetch_duration = result\n            \n            source_infos.append({\n                'name': adapter_name,\n                'status': adapter_result['source_info']['status'],\n                'races_fetched': adapter_result['source_info']['races_fetched'],\n                'error_message': adapter_result['source_info']['error_message'],\n                'fetch_duration': round(fetch_duration, 2) # Use the accurate, individual duration\n            })\n\n            if adapter_result['source_info']['status'] == 'SUCCESS':\n                all_races.extend(adapter_result.get('races', []))\n        \n        return {\n            \"date\": datetime.strptime(date, '%Y-%m-%d').date(),\n            \"races\": all_races,\n            \"sources\": source_infos,\n            \"metadata\": {\n                'fetch_time': datetime.now(),\n                'sources_queried': [a.source_name for a in target_adapters],\n                'sources_successful': len([s for s in source_infos if s['status'] == 'SUCCESS']),\n                'total_races': len(all_races)\n            }\n        }"
}