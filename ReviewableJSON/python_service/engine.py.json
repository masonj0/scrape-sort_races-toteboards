{
    "file_path": "python_service/engine.py",
    "content": "# python_service/engine.py\n\nimport asyncio\nimport structlog\nimport httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Tuple\n\nfrom .adapters.base import BaseAdapter\nfrom .adapters.betfair_adapter import BetfairAdapter\nfrom .adapters.tvg_adapter import TVGAdapter\nfrom .adapters.racing_and_sports_adapter import RacingAndSportsAdapter\nfrom .adapters.pointsbet_adapter import PointsBetAdapter\nfrom .adapters.harness_adapter import HarnessAdapter\nfrom .adapters.greyhound_adapter import GreyhoundAdapter\n\nclass OddsEngine:\n    def __init__(self, config):\n        self.config = config\n        self.log = structlog.get_logger(self.__class__.__name__)\n        self.adapters: List[BaseAdapter] = [\n            BetfairAdapter(config=self.config),\n            TVGAdapter(config=self.config),\n            RacingAndSportsAdapter(config=self.config),\n            PointsBetAdapter(config=self.config),\n            HarnessAdapter(config=self.config),\n            GreyhoundAdapter(config=self.config)\n        ]\n        self.http_client = httpx.AsyncClient()\n\n    async def close(self):\n        await self.http_client.aclose()\n\n    def get_all_adapter_statuses(self) -> List[Dict[str, Any]]:\n        \"\"\"Returns the health status of all registered adapters.\"\"\"\n        statuses = []\n        for adapter in self.adapters:\n            statuses.append(adapter.get_status())\n        return statuses\n\n    async def _time_adapter_fetch(self, adapter: BaseAdapter, date: str) -> Tuple[str, Dict[str, Any], float]:\n        \"\"\"Wraps an adapter's fetch call to accurately measure its duration.\"\"\"\n        start_time = datetime.now()\n        # Adapters now handle their own exceptions and return a consistent payload.\n        # The engine's role is to orchestrate and time the calls.\n        result = await adapter.fetch_races(date, self.http_client)\n        duration = (datetime.now() - start_time).total_seconds()\n        return (adapter.source_name, result, duration)\n\n    async def fetch_all_odds(self, date: str, source_filter: str = None) -> Dict[str, Any]:\n        target_adapters = self.adapters\n        if source_filter:\n            target_adapters = [a for a in self.adapters if a.source_name.lower() == source_filter.lower()]\n\n        tasks = [self._time_adapter_fetch(adapter, date) for adapter in target_adapters]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        successful_results = []\n        source_infos = []\n        all_races = []\n\n        for result in results:\n            if isinstance(result, Exception):\n                # This path is for unexpected errors in the wrapper or adapter itself\n                # The adapter name is not easily available here, logging is key\n                self.log.error(\"A fetch task failed unexpectedly\", error=result, exc_info=True)\n                continue\n\n            adapter_name, adapter_result, fetch_duration = result\n\n            source_infos.append({\n                'name': adapter_name,\n                'status': adapter_result['source_info']['status'],\n                'races_fetched': adapter_result['source_info']['races_fetched'],\n                'error_message': adapter_result['source_info']['error_message'],\n                'fetch_duration': round(fetch_duration, 2) # Use the accurate, individual duration\n            })\n\n            if adapter_result['source_info']['status'] == 'SUCCESS':\n                all_races.extend(adapter_result.get('races', []))\n\n        return {\n            \"date\": datetime.strptime(date, '%Y-%m-%d').date(),\n            \"races\": all_races,\n            \"sources\": source_infos,\n            \"metadata\": {\n                'fetch_time': datetime.now(),\n                'sources_queried': [a.source_name for a in target_adapters],\n                'sources_successful': len([s for s in source_infos if s['status'] == 'SUCCESS']),\n                'sources_failed': len([s for s in source_infos if s['status'] == 'FAILED']),\n                'failed_sources_list': [s['name'] for s in source_infos if s['status'] == 'FAILED'],\n                'total_races': len(all_races)\n            }\n        }"
}