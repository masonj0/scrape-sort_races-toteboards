{
    "file_path": "python_service/adapters/betfair_greyhound_adapter.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Betfair Greyhound API Adapter\n# ==============================================================================\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairGreyhoundAdapter(BaseAdapter):\n    \"\"\"API client for the Betfair Exchange, specifically for Greyhound markets.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairGreyhound\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n        self.session_token: Optional[str] = None\n        self.token_expiry: Optional[datetime] = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > (datetime.now() + timedelta(minutes=5)):\n            return\n        if not all([self.app_key, self.config.BETFAIR_USERNAME, self.config.BETFAIR_PASSWORD]):\n            raise ValueError(\"Betfair credentials not fully configured.\")\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.config.BETFAIR_USERNAME}&password={self.config.BETFAIR_PASSWORD}'\n\n        log.info(\"BetfairGreyhoundAdapter: Authenticating...\")\n        response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == 'SUCCESS':\n            self.session_token = data.get('token')\n            self.token_expiry = datetime.now() + timedelta(hours=3)\n        else:\n            raise ConnectionError(f\"Betfair authentication failed: {data.get('error')}\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            market_filter = {\"eventTypeIds\": [\"4339\"], \"marketTypeCodes\": [\"WIN\"], \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}}\n\n            market_catalogue = await self.make_request(\n                http_client, 'POST', 'listMarketCatalogue/', headers=headers,\n                json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]}\n            )\n\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No greyhound markets found.\")\n\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"BetfairGreyhoundAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"BetfairGreyhoundAdapter: Failed to fetch races\", exc_info=True, error=str(e))\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in market.get('runners', []):\n            runners.append(Runner(\n                number=runner_data.get('sortPriority', 99),\n                name=runner_data['runnerName'],\n                selection_id=runner_data['selectionId']\n            ))\n        return Race(\n            id=f\"bfg_{market['marketId']}\",\n            venue=market['event']['venue'],\n            race_number=self._extract_race_number(market.get('marketName')),\n            start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')),\n            runners=runners,\n            source=self.source_name\n        )\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name: return 1\n        match = re.search(r'\\\\bR(\\\\d{1,2})\\\\b', name)\n        return int(match.group(1)) if match else 1\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }"
}