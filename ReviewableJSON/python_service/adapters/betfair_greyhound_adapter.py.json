{
    "file_path": "python_service/adapters/betfair_greyhound_adapter.py",
    "content": "# python_service/adapters/betfair_greyhound_adapter.py\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom decimal import Decimal\nfrom typing import AsyncGenerator\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base import BaseAdapter\nfrom .betfair_auth_mixin import BetfairAuthMixin\n\n\nclass BetfairGreyhoundAdapter(BetfairAuthMixin, BaseAdapter):\n    \"\"\"Adapter for fetching greyhound racing data from the Betfair Exchange API.\"\"\"\n\n    SOURCE_NAME = \"BetfairGreyhounds\"\n    BASE_URL = \"https://api.betfair.com/exchange/betting/rest/v1.0/\"\n\n    def __init__(self, config=None):\n        super().__init__(self.SOURCE_NAME, self.BASE_URL)\n        if config:\n            self.betfair_app_key = config.BETFAIR_APP_KEY\n            self.betfair_username = config.BETFAIR_USERNAME\n            self.betfair_password = config.BETFAIR_PASSWORD\n\n    async def fetch_races(self, date: str, http_client) -> AsyncGenerator[Race, None]:\n        \"\"\"Fetches all greyhound races for a given date.\"\"\"\n        await self._authenticate(http_client)\n        if not self.session_token:\n            # self.logger.error(\"Authentication failed, cannot fetch races.\")\n            return\n\n        start_time, end_time = self._get_datetime_range(date)\n\n        market_catalogue = await self.make_request(\n            http_client=http_client,\n            method=\"post\",\n            url=f\"{self.BASE_URL}listMarketCatalogue/\",\n            json={\n                \"filter\": {\n                    \"eventTypeIds\": [\"4339\"],  # Greyhound Racing\n                    \"marketCountries\": [\"GB\", \"IE\"],\n                    \"marketTypeCodes\": [\"WIN\"],\n                    \"marketStartTime\": {\"from\": start_time.isoformat() + \"Z\", \"to\": end_time.isoformat() + \"Z\"},\n                },\n                \"maxResults\": 1000,\n                \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"],\n            },\n        )\n\n        if not market_catalogue:\n            return\n\n        for market in market_catalogue:\n            yield await self._parse_race(market, http_client)\n\n    async def _parse_race(self, market: dict, http_client) -> Race:\n        \"\"\"Parses a single market from the Betfair API into a Race object.\"\"\"\n        market_id = market[\"marketId\"]\n        event = market[\"event\"]\n        start_time = datetime.fromisoformat(market[\"marketStartTime\"].replace(\"Z\", \"+00:00\"))\n\n        odds_data = await self._get_odds_for_market(market_id, http_client)\n\n        runners = [\n            Runner(\n                number=runner.get(\"sortPriority\", i + 1),\n                name=runner[\"runnerName\"],\n                scratched=runner[\"status\"] != \"ACTIVE\",\n                selection_id=runner[\"selectionId\"],\n                odds=odds_data.get(runner[\"selectionId\"], {}),\n            )\n            for i, runner in enumerate(market.get(\"runners\", []))\n        ]\n\n        return Race(\n            id=f\"bfg_{market_id}\",\n            venue=event.get(\"venue\", \"Unknown Venue\"),\n            race_number=self._extract_race_number(market.get(\"marketName\", \"\")),\n            start_time=start_time,\n            runners=runners,\n            source=self.SOURCE_NAME,\n        )\n\n    async def _get_odds_for_market(self, market_id: str, http_client) -> dict:\n        \"\"\"Fetches the latest odds for a given market.\"\"\"\n        market_book = await self.make_request(\n            http_client=http_client,\n            method=\"post\",\n            url=f\"{self.BASE_URL}listMarketBook/\",\n            json={\"marketIds\": [market_id], \"priceProjection\": {\"priceData\": [\"EX_BEST_OFFERS\"]}},\n        )\n\n        odds_data = {}\n        if market_book and market_book[0].get(\"runners\"):\n            for runner in market_book[0][\"runners\"]:\n                selection_id = runner[\"selectionId\"]\n                if runner[\"status\"] == \"ACTIVE\" and runner[\"ex\"][\"availableToBack\"]:\n                    win_odds = Decimal(str(runner[\"ex\"][\"availableToBack\"][0][\"price\"]))\n                    odds_data[selection_id] = {\n                        self.SOURCE_NAME: OddsData(win=win_odds, source=self.SOURCE_NAME, last_updated=datetime.now())\n                    }\n        return odds_data\n\n    def _get_datetime_range(self, date_str: str):\n        start_of_day = datetime.strptime(date_str, \"%Y-%m-%d\")\n        end_of_day = start_of_day + timedelta(days=1)\n        return start_of_day, end_of_day\n\n    def _extract_race_number(self, market_name: str) -> int:\n        import re\n\n        match = re.search(r\"R(\\d+)\", market_name)\n        return int(match.group(1)) if match else 0\n"
}