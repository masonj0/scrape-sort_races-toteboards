{
    "file_path": "python_service/adapters/base_v3.py",
    "content": "# python_service/adapters/base_v3.py\nimport time\nfrom abc import ABC, abstractmethod\nfrom typing import AsyncGenerator, Any, List\n\nimport structlog\n\nfrom ..models import Race\nfrom .base import BaseAdapter # Inherit to retain retry logic, logging, circuit breaker state, etc.\n\nclass BaseAdapterV3(ABC):\n    \"\"\"\n    An architecturally superior abstract base class for data adapters.\n\n    This class enforces a rigid, standardized implementation pattern by requiring all\n    subclasses to implement their own `_fetch_data` and `_parse_races` methods.\n    It also includes a built-in circuit breaker to enhance resilience.\n    \"\"\"\n    def __init__(self, source_name: str, base_url: str, timeout: int = 20, max_retries: int = 3):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.logger = structlog.get_logger(adapter_name=source_name)\n        # Circuit Breaker State\n        self.circuit_breaker_tripped = False\n        self.circuit_breaker_failure_count = 0\n        self.circuit_breaker_last_failure = 0\n        self.FAILURE_THRESHOLD = 3\n        self.COOLDOWN_PERIOD_SECONDS = 300  # 5 minutes\n\n    @abstractmethod\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"\n        Fetches the raw data (e.g., HTML, JSON) for the given date.\n        This is the only method that should interact with the network.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"\n        Parses the raw data fetched by _fetch_data into a list of Race objects.\n        This method should be pure and contain no network logic.\n        \"\"\"\n        raise NotImplementedError\n\n    async def get_races(self, date: str) -> AsyncGenerator[Race, None]:\n        \"\"\"\n        The public-facing method to get races. Orchestrates the fetch and parse process.\n        Includes a circuit breaker to prevent repeated calls to a failing adapter.\n        Subclasses should NOT override this method.\n        \"\"\"\n        # Check Circuit Breaker state\n        if self.circuit_breaker_tripped:\n            if time.time() - self.circuit_breaker_last_failure < self.COOLDOWN_PERIOD_SECONDS:\n                self.logger.warning(f\"Circuit breaker for {self.SOURCE_NAME} is tripped. Skipping fetch.\")\n                return\n            else:\n                self.logger.info(f\"Cooldown period for {self.SOURCE_NAME} has passed. Resetting circuit breaker.\")\n                self.circuit_breaker_failure_count = 0\n                self.circuit_breaker_tripped = False\n\n        try:\n            raw_data = await self._fetch_data(date)\n            if raw_data is None:\n                self.logger.warning(f\"Fetching data for {self.SOURCE_NAME} on {date} returned None.\")\n                return\n\n            parsed_races = self._parse_races(raw_data)\n            for race in parsed_races:\n                yield race\n\n            # Reset failure count on success\n            self.circuit_breaker_failure_count = 0\n\n        except Exception:\n            self.logger.error(\n                f\"An unexpected error occurred in the get_races pipeline for {self.SOURCE_NAME}.\",\n                exc_info=True\n            )\n            # Handle circuit breaker logic on failure\n            self.circuit_breaker_failure_count += 1\n            self.circuit_breaker_last_failure = time.time()\n            if self.circuit_breaker_failure_count >= self.FAILURE_THRESHOLD:\n                self.circuit_breaker_tripped = True\n                self.logger.critical(f\"Circuit breaker for {self.SOURCE_NAME} has been tripped after {self.FAILURE_THRESHOLD} failures.\")\n            return\n"
}