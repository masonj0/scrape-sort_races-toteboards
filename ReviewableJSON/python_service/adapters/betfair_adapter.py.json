{
    "file_path": "python_service/adapters/betfair_adapter.py",
    "content": "# python_service/adapters/betfair_adapter.py\n\nimport os\nimport re\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nclass BetfairAdapter(BaseAdapter):\n    def __init__(self):\n        super().__init__(\n            source_name=\"Betfair\", \n            base_url=\"https://api.betfair.com/exchange/betting/json-rpc/v1\"\n        )\n        self.app_key = os.getenv(\"BETFAIR_APP_KEY\")\n        self.username = os.getenv(\"BETFAIR_USERNAME\")\n        self.password = os.getenv(\"BETFAIR_PASSWORD\")\n        self.session_token: str | None = None\n        self.token_expiry: datetime | None = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > datetime.now():\n            return\n        if not all([self.app_key, self.username, self.password]):\n            raise Exception(\"Betfair credentials not set in environment.\")\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.username}&password={self.password}'\n\n        response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == 'SUCCESS':\n            self.session_token = data.get('token')\n            self.token_expiry = datetime.now() + timedelta(hours=4)\n        else:\n            raise Exception(f\"Betfair authentication failed: {data.get('error')}\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            \n            market_filter = {\n                \"eventTypeIds\": [\"7\"], \"marketTypeCodes\": [\"WIN\"],\n                \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}\n            }\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            json_payload = {\n                \"jsonrpc\": \"2.0\", \"method\": \"SportsAPING/v1.0/listMarketCatalogue\",\n                \"params\": {\n                    \"filter\": market_filter,\n                    \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\", \"MARKET_START_TIME\"],\n                    \"maxResults\": 1000\n                }, \"id\": 1\n            }\n\n            # BUG FIX: Use the resilient self.make_request method\n            markets_response = await self.make_request(http_client, 'POST', '/', headers=headers, json=json_payload)\n            if not markets_response or 'result' not in markets_response:\n                return {'races': []}\n\n            all_races = [self._parse_betfair_race(market) for market in markets_response['result']]\n            fetch_duration = (datetime.now() - start_time).total_seconds()\n            return {\n                # FEEDBACK FIX: Use .model_dump() instead of .dict()\n                'races': [r.model_dump() for r in all_races],\n                'source_info': {\n                    'name': self.source_name, 'status': 'SUCCESS',\n                    'races_fetched': len(all_races), 'error_message': None,\n                    'fetch_duration': fetch_duration\n                }\n            }\n        except Exception as e:\n            self.logger.error(f\"Failed to fetch races from Betfair: {e}\", exc_info=True)\n            raise\n\n    def _parse_betfair_race(self, market: Dict[str, Any]) -> Race:\n        venue = market.get('event', {}).get('venue', 'Unknown Venue')\n        start_time = datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00'))\n        \n        # BUG FIX: Use a robust regex for race number parsing\n        match = re.search(r'[Rr](\\d+)', market.get('marketName', ''))\n        race_number = int(match.group(1)) if match else 0\n\n        runners = []\n        for runner_data in market.get('runners', []):\n            if runner_data.get('status') == 'ACTIVE':\n                runners.append(Runner(\n                    number=runner_data.get('sortPriority', 0),\n                    name=runner_data.get('runnerName', 'Unknown Runner'),\n                    scratched=False # Explicitly set required field\n                ))\n\n        return Race(\n            id=f\"bf_{market['marketId']}\",\n            venue=venue, race_number=race_number, start_time=start_time,\n            runners=runners,\n            source=self.source_name # BUG FIX: Add the required 'source' field\n        )"
}