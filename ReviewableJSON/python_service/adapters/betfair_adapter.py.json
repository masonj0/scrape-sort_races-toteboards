{
    "file_path": "python_service/adapters/betfair_adapter.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Betfair API Adapter (Canonized)\n# ==============================================================================\n# This adapter is a production-grade API client for the Betfair Exchange.\n# It is the primary weapon for the LiveOddsMonitor (The Third Pillar).\n# ==============================================================================\n\nimport httpx\nimport structlog\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairAdapter(BaseAdapter):\n    \"\"\"API client for the Betfair Exchange, focused on live odds.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairExchange\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n        self.session_token: Optional[str] = None\n        self.token_expiry: Optional[datetime] = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > datetime.now():\n            return # Token is still valid\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.config.BETFAIR_USERNAME}&password={self.config.BETFAIR_PASSWORD}'\n        \n        log.info(\"BetfairAdapter: Authenticating to get new session token...\")\n        try:\n            response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n            response.raise_for_status()\n            data = response.json()\n            if data.get('status') == 'SUCCESS':\n                self.session_token = data.get('token')\n                self.token_expiry = datetime.now() + timedelta(hours=3)\n                log.info(\"BetfairAdapter: Authentication successful.\")\n            else:\n                raise Exception(f\"Authentication failed: {data.get('error')}\")\n        except Exception as e:\n            log.error(\"BetfairAdapter: Authentication failed catastrophically\", error=str(e))\n            raise\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            \n            # 1. Find all horse racing WIN markets for the day\n            market_filter = {\n                \"eventTypeIds\": [\"7\"], # 7 is Horse Racing\n                \"marketTypeCodes\": [\"WIN\"],\n                \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}\n            }\n            market_catalogue = await self.make_request(http_client, 'POST', 'listMarketCatalogue/', headers=headers, json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]})\n\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n\n            all_races = []\n            for market in market_catalogue:\n                parsed_race = self._parse_race(market)\n                all_races.append(parsed_race)\n\n            return self._format_response(all_races, start_time)\n\n        except Exception as e:\n            log.error(\"BetfairAdapter: Failed to fetch races\", exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        \"\"\"Parses a single market from the catalogue into a Race object.\"\"\"\n        runners = []\n        for runner_data in market.get('runners', []):\n            # The catalogue doesn't have live odds, just runner info.\n            # A full LiveOddsMonitor would now take the marketId and call listMarketBook.\n            runners.append(Runner(\n                number=runner_data.get('sortPriority', 0), # Using sortPriority as a proxy for number\n                name=runner_data['runnerName']\n            ))\n\n        return Race(\n            id=f\"bf_{market['marketId']}\",\n            venue=market['event']['venue'],\n            race_number=0, # Not easily available in catalogue, would need parsing from name\n            start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')),\n            runners=runners\n        )\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': [r.model_dump() for r in races],\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }"
}