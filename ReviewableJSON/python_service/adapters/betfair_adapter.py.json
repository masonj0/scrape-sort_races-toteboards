{
    "file_path": "python_service/adapters/betfair_adapter.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Betfair API Adapter (Canonized)\n# ==============================================================================\n# This adapter is a production-grade API client for the Betfair Exchange.\n# It is the primary weapon for the LiveOddsMonitor (The Third Pillar).\n# ==============================================================================\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairAdapter(BaseAdapter):\n    \"\"\"API client for the Betfair Exchange, focused on live odds.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairExchange\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n        self.session_token: Optional[str] = None\n        self.token_expiry: Optional[datetime] = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > datetime.now():\n            return # Token is still valid\n\n        if not all([self.app_key, self.config.BETFAIR_USERNAME, self.config.BETFAIR_PASSWORD]):\n            raise ValueError(\"Betfair credentials (APP_KEY, USERNAME, PASSWORD) not fully configured.\")\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.config.BETFAIR_USERNAME}&password={self.config.BETFAIR_PASSWORD}'\n        \n        log.info(\"BetfairAdapter: Authenticating to get new session token...\")\n        response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == 'SUCCESS':\n            self.session_token = data.get('token')\n            self.token_expiry = datetime.now() + timedelta(hours=3)\n            log.info(\"BetfairAdapter: Authentication successful.\")\n        else:\n            raise ConnectionError(f\"Betfair authentication failed: {data.get('error')}\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            \n            market_filter = {\n                \"eventTypeIds\": [\"7\"], # 7 is Horse Racing\n                \"marketTypeCodes\": [\"WIN\"],\n                \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}\n            }\n            # The make_request method in BaseAdapter is not suitable for Betfair's JSON-RPC style API, so we call httpx directly.\n            response = await http_client.post(self.base_url + 'listMarketCatalogue/', headers=headers, json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]}, timeout=self.timeout)\n            response.raise_for_status()\n            market_catalogue = response.json()\n\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time)\n\n        except Exception as e:\n            log.error(\"BetfairAdapter: Failed to fetch races\", exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in market.get('runners', []):\n            runners.append(Runner(\n                number=runner_data.get('sortPriority', 99),\n                name=runner_data['runnerName']\n            ))\n\n        return Race(\n            id=f\"bf_{market['marketId']}\",\n            venue=market['event']['venue'],\n            race_number=self._extract_race_number(market.get('marketName')),\n            start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')),\n            runners=runners,\n            source=self.source_name\n        )\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name: return 1\n        match = re.search(r'\\\\bR(\\\\d{1,2})\\\\b', name)\n        return int(match.group(1)) if match else 1\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': [r.model_dump() for r in races],\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }"
}