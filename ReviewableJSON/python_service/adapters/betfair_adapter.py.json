{
    "file_path": "python_service/adapters/betfair_adapter.py",
    "content": "# python_service/adapters/betfair_adapter.py\n\nimport re\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Optional\n\nimport httpx\nimport structlog\n\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base import BaseAdapter\nfrom .betfair_auth_mixin import BetfairAuthMixin\n\nlog = structlog.get_logger(__name__)\n\n\nclass BetfairAdapter(BetfairAuthMixin, BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairExchange\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\", config=config)\n        self.app_key = self.config.BETFAIR_APP_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\n                \"X-Application\": self.app_key,\n                \"X-Authentication\": self.session_token,\n                \"Content-Type\": \"application/json\",\n            }\n            market_filter = {\n                \"eventTypeIds\": [\"7\"],\n                \"marketTypeCodes\": [\"WIN\"],\n                \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"},\n            }\n            response = await self.make_request(\n                http_client,\n                \"POST\",\n                \"listMarketCatalogue/\",\n                headers=headers,\n                json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]},\n            )\n            if not response:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n            market_catalogue = response.json()\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except Exception as e:\n            log.error(f\"Error fetching races from Betfair: {e}\", exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race | None:\n        if market is None:\n            return None\n        runners = [\n            Runner(number=rd.get(\"sortPriority\", 99), name=rd[\"runnerName\"], selection_id=rd[\"selectionId\"])\n            for rd in market.get(\"runners\", [])\n        ]\n        return Race(\n            id=f\"bf_{market['marketId']}\",\n            venue=market[\"event\"][\"venue\"],\n            race_number=self._extract_race_number(market.get(\"marketName\")),\n            start_time=datetime.fromisoformat(market[\"marketStartTime\"].replace(\"Z\", \"+00:00\")),\n            runners=runners,\n            source=self.source_name,\n        )\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name:\n            return 1\n        match = re.search(r\"\\bR(\\d{1,2})\\b\", name)\n        return int(match.group(1)) if match else 1\n\n    # The duplicated method has been removed.\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client to release resources.\"\"\"\n        if self.http_client:\n            await self.http_client.aclose()\n"
}