{
    "filepath": "python_service/adapters/betfair_adapter.py",
    "content": "# python_service/adapters/betfair_adapter.py\n\nimport logging\nfrom datetime import datetime\nfrom typing import List\n\nfrom .base import BaseAdapterV7, Race, Runner\nfrom .utils import parse_odds\n\nclass BetfairExchangeAdapter(BaseAdapterV7):\n    \"\"\"\n    Adapter for the Betfair Exchange API.\n    \"\"\"\n    SOURCE_ID = \"betfair_exchange\"\n    API_ENDPOINT = \"https://ero.betfair.com/www/sports/exchange/readonly/v1/bymarket?alt=json&filter=canonical&maxResults=25&rollupLimit=2&types=EVENT,MARKET_DESCRIPTION,RUNNER_DESCRIPTION,RUNNER_EXCHANGE_PRICES_BEST,MARKET_STATE&marketProjection=EVENT,MARKET_START_TIME,RUNNER_DESCRIPTION&eventTypeIds=7\"\n\n    def fetch_races(self) -> List[Race]:\n        \"\"\"\n        Fetches race data from the Betfair Exchange API and transforms it into\n        the standardized Race model.\n        \"\"\"\n        data = self.fetcher.get(self.API_ENDPOINT, headers={'Accept': 'application/json'})\n        if not isinstance(data, dict):\n            logging.warning(f\"BetfairExchangeAdapter received invalid or non-dict data: {type(data)}\")\n            return []\n\n        return self._parse_betfair_races(data)\n\n    def _parse_betfair_races(self, data: dict) -> List[Race]:\n        \"\"\"\n        Parses the complex JSON structure from the Betfair API.\n        \"\"\"\n        races = []\n        try:\n            event_nodes = data.get('eventTypes', [{}])[0].get('eventNodes', [])\n            for event_node in event_nodes:\n                event = event_node.get('event', {})\n                for market_node in event_node.get('marketNodes', []):\n                    market = market_node.get('market', {})\n                    if market.get('marketType', '') != 'WIN':\n                        continue\n\n                    runners = []\n                    for runner_node in market_node.get('runners', []):\n                        if runner_node.get('state', {}).get('status') != 'ACTIVE':\n                            continue\n\n                        raw_odds = None\n                        if 'exchange' in runner_node:\n                            available_to_back = runner_node['exchange'].get('availableToBack', [])\n                            if available_to_back:\n                                raw_odds = available_to_back[0].get('price')\n\n                        # Use the centralized utility to parse odds.\n                        # The raw_odds is already a float here, but using the utility ensures consistency.\n                        odds = parse_odds(raw_odds)\n\n                        if odds < 999.0:\n                            runners.append(\n                                Runner(\n                                    name=runner_node.get('description', {}).get('runnerName', 'Unknown'),\n                                    odds=odds\n                                )\n                            )\n\n                    if len(runners) >= 3:\n                        start_time = None\n                        if market.get('marketStartTime'):\n                            try:\n                                start_time = datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00'))\n                            except ValueError:\n                                pass # Ignore if parsing fails\n\n                        race_number = None\n                        event_name = event.get('eventName', '')\n                        if 'R' in event_name:\n                            try:\n                                race_number = int(event_name.split('R')[-1])\n                            except (ValueError, IndexError):\n                                pass\n\n                        races.append(\n                            Race(\n                                race_id=f\"betfair_{market.get('marketId', 'unknown')}\",\n                                track_name=event.get('venue', 'Betfair Exchange'),\n                                post_time=start_time,\n                                race_number=race_number,\n                                runners=runners,\n                                source=self.SOURCE_ID\n                            )\n                        )\n        except (KeyError, TypeError, IndexError) as e:\n            logging.error(f\"Error parsing Betfair data structure: {e}\")\n\n        return races"
}