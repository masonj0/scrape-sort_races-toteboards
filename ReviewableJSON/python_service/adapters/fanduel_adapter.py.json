{
    "file_path": "python_service/adapters/fanduel_adapter.py",
    "content": "# python_service/adapters/fanduel_adapter.py\n\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom decimal import Decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\n\nimport httpx\nimport structlog\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base import BaseAdapter\n\nlog = structlog.get_logger()\n\n\nclass FanDuelAdapter(BaseAdapter):\n    \"\"\"Adapter for fetching horse racing odds from FanDuel's private API.\"\"\"\n\n    source_name = \"FanDuel\"\n    API_URL = \"https://sb-api.nj.sportsbook.fanduel.com/api/markets?_ak=Fh2e68s832c41d4b&eventId=\"\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> List[Race]:\n        \"\"\"Fetches races for a given date. Note: FanDuel API is event-based, not date-based.\"\"\"\n        # This is a placeholder for a more robust event discovery mechanism.\n        # For now, we'll use a known event ID for a major race day as a proof of concept.\n        # A full implementation would need to first find the relevant event IDs for the day.\n        event_id = \"38183.3\"  # Example: A major race event\n\n        log.info(\"Fetching races from FanDuel\", event_id=event_id)\n        start_time = datetime.now()\n        try:\n            response = await http_client.get(self.API_URL + event_id)\n            response.raise_for_status()\n            data = response.json()\n            races = self._parse_races(data)\n            return self._format_response(races, start_time, is_success=True)\n        except httpx.HTTPStatusError as e:\n            log.error(\"FanDuel API request failed\", status_code=e.response.status_code, response=e.response.text)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n        except Exception as e:\n            log.error(\"An unexpected error occurred fetching FanDuel data\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_races(self, data: Dict[str, Any]) -> List[Race]:\n        races = []\n        if \"marketGroups\" not in data:\n            log.warning(\"FanDuel response missing 'marketGroups' key\")\n            return []\n\n        for group in data[\"marketGroups\"]:\n            if group.get(\"marketGroupName\") == \"Win\":\n                for market in group.get(\"markets\", []):\n                    try:\n                        race = self._parse_single_race(market)\n                        if race:\n                            races.append(race)\n                    except Exception as e:\n                        log.error(\"Failed to parse a FanDuel market\", market=market, error=str(e), exc_info=True)\n        return races\n\n    def _parse_single_race(self, market: Dict[str, Any]) -> Race | None:\n        market_name = market.get(\"marketName\", \"\")\n        if not market_name.startswith(\"Race\"):\n            return None\n\n        # Extract race number and track from market name (e.g., \"Race 5 - Churchill Downs\")\n        parts = market_name.split(\" - \")\n        if len(parts) < 2:\n            return None\n\n        race_number_str = parts[0].replace(\"Race \", \"\")\n        track_name = parts[1]\n\n        # Placeholder for start_time - FanDuel's market API doesn't provide it directly\n        start_time = datetime.now(timezone.utc) + timedelta(hours=int(race_number_str))\n\n        runners = []\n        for runner_data in market.get(\"runners\", []):\n            runner_name = runner_data.get(\"runnerName\")\n            win_odds = runner_data.get(\"winRunnerOdds\", {}).get(\"currentPrice\")\n            if not runner_name or not win_odds:\n                continue\n\n            try:\n                # Price is given as a fraction string, e.g., \"12/5\"\n                numerator, denominator = map(int, win_odds.split(\"/\"))\n                decimal_odds = Decimal(numerator) / Decimal(denominator) + 1\n            except (ValueError, ZeroDivisionError):\n                log.warning(\"Could not parse FanDuel odds\", odds_str=win_odds, runner=runner_name)\n                continue\n\n            odds = OddsData(win=decimal_odds, source=self.source_name, last_updated=datetime.now(timezone.utc))\n\n            # Placeholder for program number\n            program_number_str = runner_name.split(\".\")[0].strip()\n\n            runner = Runner(\n                name=runner_name.split(\".\")[1].strip(),\n                number=int(program_number_str) if program_number_str.isdigit() else None,\n                odds={self.source_name: odds},\n            )\n            runners.append(runner)\n\n        if not runners:\n            return None\n\n        race_id = f\"FD-{track_name.replace(' ', '')[:5].upper()}-{start_time.strftime('%Y%m%d')}-R{race_number_str}\"\n\n        return Race(\n            id=race_id,\n            venue=track_name,\n            race_number=int(race_number_str),\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name,\n        )\n"
}