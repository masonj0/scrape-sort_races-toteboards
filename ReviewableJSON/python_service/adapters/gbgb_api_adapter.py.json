{
    "file_path": "python_service/adapters/gbgb_api_adapter.py",
    "content": "# python_service/adapters/gbgb_api_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass GbgbApiAdapter(BaseAdapter):\n    \"\"\"Adapter for the undocumented JSON API for the Greyhound Board of Great Britain.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"GBGB\",\n            base_url=\"https://api.gbgb.org.uk/api/\"\n        )\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            # The endpoint appears to be structured by date for all meetings\n            endpoint = f\"results/meeting/{date}\"\n            response_json = await self.make_request(http_client, 'GET', endpoint)\n\n            if not response_json:\n                return self._format_response([], start_time, is_success=True, error_message=\"No meetings found in API response.\")\n\n            all_races = self._parse_meetings(response_json)\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(f\"{self.source_name}: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(f\"{self.source_name}: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _parse_meetings(self, meetings_data: List[Dict[str, Any]]) -> List[Race]:\n        races = []\n        for meeting in meetings_data:\n            track_name = meeting.get('trackName')\n            for race_data in meeting.get('races', []):\n                try:\n                    races.append(self._parse_race(race_data, track_name))\n                except Exception as e:\n                    log.error(f\"{self.source_name}: Error parsing race\", race_id=race_data.get('raceId'), error=str(e))\n        return races\n\n    def _parse_race(self, race_data: Dict[str, Any], track_name: str) -> Race:\n        return Race(\n            id=f\"gbgb_{race_data['raceId']}\",\n            venue=track_name,\n            race_number=race_data['raceNumber'],\n            start_time=datetime.fromisoformat(race_data['raceTime'].replace('Z', '+00:00')),\n            runners=self._parse_runners(race_data.get('traps', [])),\n            source=self.source_name,\n            race_name=race_data.get('raceTitle'),\n            distance=f\"{race_data.get('raceDistance')}m\",\n        )\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for runner_data in runners_data:\n            try:\n                # The API provides SP as a fraction, e.g., '5/2'\n                odds_data = {}\n                sp = runner_data.get('sp')\n                if sp:\n                    from .utils import parse_odds # Local import to avoid circular dependency issues at module level\n                    win_odds = Decimal(str(parse_odds(sp)))\n                    if win_odds < 999:\n                        odds_data[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=runner_data['trapNumber'],\n                    name=runner_data['dogName'],\n                    odds=odds_data,\n                ))\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing runner\", runner_name=runner_data.get('dogName'), error=str(e))\n        return runners\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': (datetime.now() - start_time).total_seconds()\n            }\n        }"
}