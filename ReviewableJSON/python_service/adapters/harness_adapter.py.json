{
    "file_path": "python_service/adapters/harness_adapter.py",
    "content": "from datetime import datetime\nfrom typing import Any, Dict, List\nimport httpx\nfrom pydantic import ValidationError\nimport structlog\nfrom decimal import Decimal\n\nfrom ..models import Race, Runner, OddsData\nfrom .base import BaseAdapter\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\nclass HarnessAdapter(BaseAdapter):\n    \"\"\"Adapter for fetching Harness racing data from USTA.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"Harness Racing (USTA)\",\n            base_url=\"https://data.ustrotting.com/\"\n        )\n        # No API key required for this public endpoint\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        \"\"\"Fetches upcoming harness races for the specified date.\"\"\"\n        start_time = datetime.now()\n        endpoint = f\"api/racenet/racing/card/{date}\"\n        try:\n            response_json = await self.make_request(http_client, 'GET', endpoint)\n            if not response_json or \"meetings\" not in response_json:\n                log.warning(\"HarnessAdapter: No 'meetings' in response or empty response.\")\n                return self._format_response([], start_time, is_success=True, error_message=\"No meetings found for date.\")\n\n            all_races = self._parse_meetings(response_json[\"meetings\"])\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"HarnessAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"HarnessAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {str(e)}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        \"\"\"Formats the adapter's response consistently.\"\"\"\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_meetings(self, meetings: List[Dict[str, Any]]) -> List[Race]:\n        \"\"\"Parses a list of meetings and their races into Race objects.\"\"\"\n        all_races = []\n        for meeting in meetings:\n            venue = meeting.get(\"trackName\", \"Unknown Venue\")\n            races_data = meeting.get(\"races\", [])\n            for race_data in races_data:\n                try:\n                    if not race_data.get(\"runners\"):\n                        continue\n\n                    race_id = race_data.get('raceId')\n                    race = Race(\n                        id=f\"usta_{race_id}\",\n                        venue=venue,\n                        race_number=race_data[\"raceNumber\"],\n                        start_time=datetime.fromisoformat(race_data[\"startTime\"].replace(\"Z\", \"+00:00\")),\n                        runners=self._parse_runners(race_data[\"runners\"], race_id),\n                        source=self.source_name\n                    )\n                    all_races.append(race)\n                except (ValidationError, KeyError) as e:\n                    log.error(\n                        f\"HarnessAdapter: Error parsing race {race_data.get('raceId', 'N/A')}\",\n                        error=str(e),\n                        race_data=race_data\n                    )\n        return all_races\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]], race_id: str) -> List[Runner]:\n        \"\"\"Parses a list of runner dictionaries into Runner objects.\"\"\"\n        runners = []\n        for runner_data in runners_data:\n            try:\n                # API provides number as 'postPosition'\n                runner_number = runner_data.get('postPosition')\n                if not runner_number:\n                    continue\n\n                # Adapt to the Runner model's odds structure\n                odds_data = {}\n                win_odds_str = runner_data.get(\"morningLineOdds\")\n                if win_odds_str:\n                    try:\n                        # Use the robust, shared odds parser to handle formats like '9-5' or 'EVEN'\n                        decimal_odds = Decimal(str(parse_odds(win_odds_str)))\n                        if decimal_odds > 1:\n                            odds_data[self.source_name] = OddsData(win=decimal_odds, source=self.source_name, last_updated=datetime.now())\n                    except (ValueError, TypeError):\n                        log.warning(\"Could not parse harness odds\", odds_str=win_odds_str, race_id=race_id)\n\n\n                runner = Runner(\n                    number=runner_number,\n                    name=runner_data[\"horseName\"],\n                    scratched=runner_data.get(\"scratched\", False),\n                    odds=odds_data\n                )\n                runners.append(runner)\n            except (KeyError, ValidationError) as e:\n                log.error(\"HarnessAdapter: Error parsing runner\", error=str(e), runner_data=runner_data)\n        return runners"
}