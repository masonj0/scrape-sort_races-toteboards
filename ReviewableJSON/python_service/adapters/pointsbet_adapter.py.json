{
    "file_path": "python_service/adapters/pointsbet_adapter.py",
    "content": "# python_service/adapters/pointsbet_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass PointsBetAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"PointsBet\",\n            base_url=\"https://api.au.pointsbet.com\"\n        )\n        self.api_key = config.POINTSBET_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        \"\"\"Fetches upcoming thoroughbred races from the PointsBet API.\"\"\"\n        start_time = datetime.now()\n\n        if not self.api_key:\n            log.warning(\"PointsBetAdapter: POINTSBET_API_KEY not set. Skipping.\")\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: Token not set\")\n\n        endpoint = \"/api/v2/racing/futures\"\n        headers = {\"api-key\": self.api_key}\n        params = {\"sportId\": 21}  # Assuming 21 is for Thoroughbred Racing\n\n        try:\n            response_json = await self.make_request(http_client, 'GET', endpoint, headers=headers, params=params)\n\n            if not response_json or \"events\" not in response_json:\n                log.warning(\"PointsBetAdapter: No 'events' in response or empty response.\")\n                return self._format_response([], start_time, is_success=True)\n\n            all_races = self._parse_races(response_json[\"events\"])\n\n            # The API is for futures, so we must filter by the requested date\n            all_races = [race for race in all_races if race.start_time.strftime('%Y-%m-%d') == date]\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"PointsBetAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"PointsBetAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_races(self, events: List[Dict[str, Any]]) -> List[Race]:\n        races = []\n        for event in events:\n            if not event.get(\"outcomes\"):  # Skip events without runners\n                continue\n\n            try:\n                race = Race(\n                    id=f\"pb_{event['id']}\",\n                    venue=event.get(\"competitionName\", \"Unknown Venue\"),\n                    race_number=event.get(\"eventNumber\", 0),\n                    start_time=datetime.fromisoformat(event[\"startTime\"].replace(\"Z\", \"+00:00\")),\n                    runners=self._parse_runners(event[\"outcomes\"]),\n                    source=self.source_name\n                )\n                races.append(race)\n            except Exception as e:\n                log.error(\n                    \"PointsBetAdapter: Error parsing event\",\n                    error=str(e),\n                    event_id=event.get('id', 'N/A')\n                )\n        return races\n\n    def _parse_runners(self, outcomes: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for i, outcome in enumerate(outcomes):\n            win_odds_data = next((p for p in outcome.get(\"prices\", []) if p[\"priceType\"] == \"FixedWin\"), None)\n\n            odds_dict = {}\n            if win_odds_data and win_odds_data.get(\"price\"):\n                try:\n                    win_odds = Decimal(str(win_odds_data[\"price\"]))\n                    odds_dict[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n                except Exception:\n                    win_odds = None\n\n            runners.append(Runner(\n                number=i + 1,  # Placeholder as number is not provided\n                name=outcome.get(\"name\", \"Unknown Runner\"),\n                scratched=outcome.get(\"isSuspended\", False),\n                odds=odds_dict\n            ))\n        return runners\n"
}