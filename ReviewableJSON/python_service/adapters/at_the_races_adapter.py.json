{
    "file_path": "python_service/adapters/at_the_races_adapter.py",
    "content": "# python_service/adapters/at_the_races_adapter.py\n\nimport asyncio\nfrom datetime import datetime\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nimport httpx\nimport structlog\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom ..utils.odds import parse_odds_to_decimal\nfrom ..utils.text import clean_text\nfrom ..utils.text import normalize_venue_name\nfrom .base import BaseAdapter\n\nlog = structlog.get_logger(__name__)\n\n\nclass AtTheRacesAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"AtTheRaces\", base_url=\"https://www.attheraces.com\", config=config)\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            log.error(f\"Error fetching races from AtTheRaces: {e}\", exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response = await self.make_request(http_client, \"GET\", \"/racecards\")\n        if not response:\n            return []\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        links = {a[\"href\"] for a in soup.select(\"a.race-time-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response = await self.make_request(http_client, \"GET\", url)\n            if response is None:\n                return None\n            soup = BeautifulSoup(response.text, \"html.parser\")\n            header = soup.select_one(\"h1.heading-racecard-title\").get_text()\n            track_name_raw, race_time = [p.strip() for p in header.split(\"|\")[:2]]\n            track_name = normalize_venue_name(track_name_raw)\n            active_link = soup.select_one(\"a.race-time-link.active\")\n            race_number = active_link.find_parent(\"div\", \"races\").select(\"a.race-time-link\").index(active_link) + 1\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time}\", \"%Y-%m-%d %H:%M\")\n            runners = [self._parse_runner(row) for row in soup.select(\"div.card-horse\")]\n            return Race(\n                id=f\"atr_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\",\n                venue=track_name,\n                race_number=race_number,\n                start_time=start_time,\n                runners=[r for r in runners if r],\n                source=self.source_name,\n            )\n        except Exception as e:\n            log.error(\"Error parsing race from AtTheRaces\", url=url, exc_info=e)\n            return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = clean_text(row.select_one(\"h3.horse-name a\").get_text())\n            num_str = clean_text(row.select_one(\"span.horse-number\").get_text())\n            number = int(\"\".join(filter(str.isdigit, num_str)))\n            odds_str = clean_text(row.select_one(\"button.best-odds\").get_text())\n            win_odds = parse_odds_to_decimal(odds_str)\n            odds_data = (\n                {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())}\n                if win_odds and win_odds < 999\n                else {}\n            )\n            return Runner(number=number, name=name, odds=odds_data)\n        except Exception as e:\n            log.warning(\"Failed to parse runner\", exc_info=e)\n            return None\n"
}