{
    "file_path": "python_service/adapters/tvg_adapter.py",
    "content": "# python_service/adapters/tvg_adapter.py\n\nimport os\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nimport httpx\nfrom decimal import Decimal, InvalidOperation\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\ndef _parse_program_number(program_str: str) -> int:\n    \"\"\"Safely parses program numbers like '1A' into an integer.\"\"\"\n    return int(''.join(filter(str.isdigit, program_str))) if program_str else 99\n\nclass TVGAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"TVG\",\n            base_url=\"https://api.tvg.com/v3/\"\n        )\n        self.api_key = config.TVG_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Accept\": \"application/json\", \"X-API-Key\": self.api_key}\n\n        if not self.api_key:\n            log.warning(\"TVGAdapter: TVG_API_KEY not set. Skipping.\")\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: TVG_API_KEY not set\")\n\n        try:\n            tracks_url = \"tracks\"\n            tracks_params = {\"date\": date, \"country\": \"US\"}\n            tracks_response = await self.make_request(http_client, 'GET', tracks_url, headers=headers, params=tracks_params)\n\n            if not tracks_response or 'tracks' not in tracks_response:\n                log.warning(\"TVG: No tracks found for the given date.\")\n                return self._format_response(all_races, start_time, is_success=True)\n\n            for track in tracks_response['tracks']:\n                try:\n                    races_url = f\"tracks/{track['code']}/races\"\n                    races_params = {\"date\": date}\n                    races_response = await self.make_request(http_client, 'GET', races_url, headers=headers, params=races_params)\n\n                    for race_summary in races_response.get('races', []):\n                        race_detail_url = f\"tracks/{track['code']}/races/{race_summary['number']}\"\n                        race_detail = await self.make_request(http_client, 'GET', race_detail_url, headers=headers)\n                        if race_detail:\n                            parsed_race = self._parse_tvg_race(track, race_detail)\n                            all_races.append(parsed_race)\n                except httpx.HTTPError as e:\n                    log.error(\"TVGAdapter: Failed to process track, skipping.\", track_name=track.get('name'), error=str(e))\n                    continue # Continue to the next track\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"TVGAdapter: Initial HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"TVGAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_tvg_race(self, track: Dict[str, Any], race_data: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in race_data.get('runners', []):\n            if not runner_data.get('scratched'):\n                current_odds_str = runner_data.get('odds', {}).get('current') or runner_data.get('odds', {}).get('morningLine')\n                win_odds = self._parse_tvg_odds(current_odds_str)\n\n                odds_dict = {}\n                if win_odds:\n                    odds_dict[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=_parse_program_number(runner_data.get('programNumber')),\n                    name=runner_data.get('horseName', 'Unknown Runner'),\n                    scratched=False,\n                    odds=odds_dict\n                ))\n\n        race_id = f\"{track.get('code', 'UNK').lower()}_{race_data['postTime'].split('T')[0]}_R{race_data['number']}\"\n\n        return Race(\n            id=race_id,\n            venue=track.get('name', 'Unknown Venue'),\n            race_number=race_data.get('number'),\n            start_time=datetime.fromisoformat(race_data.get('postTime')),\n            runners=runners,\n            source=self.source_name\n        )\n\n    def _parse_tvg_odds(self, odds_string: str) -> Optional[Decimal]:\n        if not odds_string or odds_string == \"SCR\": return None\n        if odds_string == \"EVEN\": return Decimal('2.0')\n        if \"/\" in odds_string:\n            try:\n                numerator, denominator = odds_string.split(\"/\")\n                return (Decimal(numerator) / Decimal(denominator)) + Decimal('1.0')\n            except (ValueError, ZeroDivisionError, InvalidOperation): return None\n        try: return Decimal(odds_string)\n        except InvalidOperation: return None"
}