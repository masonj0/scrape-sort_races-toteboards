{
    "file_path": "python_service/adapters/tvg_adapter.py",
    "content": "# python_service/adapters/tvg_adapter.py\n\nimport os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nimport httpx\nfrom decimal import Decimal, InvalidOperation\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nclass TVGAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"TVG\",\n            base_url=\"https://api.tvg.com/v3/\"\n        )\n        self.api_key = config.TVG_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Accept\": \"application/json\", \"X-API-Key\": self.api_key}\n\n        if not self.api_key:\n            self.logger.warning(f\"TVG_API_KEY not set. Adapter {self.source_name} will be skipped.\")\n            return self._format_response(all_races, start_time)\n\n        try:\n            tracks_url = \"tracks\"\n            tracks_params = {\"date\": date, \"country\": \"US\"}\n            tracks_response = await self.make_request(http_client, 'GET', tracks_url, headers=headers, params=tracks_params)\n\n            if not tracks_response or 'tracks' not in tracks_response:\n                self.logger.warning(\"TVG: No tracks found for the given date.\")\n                return self._format_response(all_races, start_time)\n\n            for track in tracks_response['tracks']:\n                try:\n                    races_url = f\"tracks/{track['code']}/races\"\n                    races_params = {\"date\": date}\n                    races_response = await self.make_request(http_client, 'GET', races_url, headers=headers, params=races_params)\n\n                    for race_summary in races_response.get('races', []):\n                        race_detail_url = f\"tracks/{track['code']}/races/{race_summary['number']}\"\n                        race_detail = await self.make_request(http_client, 'GET', race_detail_url, headers=headers)\n                        if race_detail:\n                            parsed_race = self._parse_tvg_race(track, race_detail)\n                            all_races.append(parsed_race)\n                except Exception as e:\n                    self.logger.error(f\"Failed to process track {track.get('name')}: {e}\", exc_info=True)\n\n            return self._format_response(all_races, start_time)\n        except Exception as e:\n            self.logger.error(f\"Failed to fetch races from {self.source_name}: {e}\", exc_info=True)\n            raise\n\n    def _format_response(self, races: List[Race], start_time: datetime) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': [r.model_dump() for r in races],\n            'source_info': {\n                'name': self.source_name, 'status': 'SUCCESS',\n                'races_fetched': len(races), 'error_message': None,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_tvg_race(self, track: Dict[str, Any], race_data: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in race_data.get('runners', []):\n            if not runner_data.get('scratched'):\n                current_odds_str = runner_data.get('odds', {}).get('current') or runner_data.get('odds', {}).get('morningLine')\n                win_odds = self._parse_tvg_odds(current_odds_str)\n\n                odds_dict = {}\n                if win_odds:\n                    odds_dict[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=runner_data.get('programNumber'),\n                    name=runner_data.get('horseName', 'Unknown Runner'),\n                    scratched=False, # Corrected based on Oracle feedback\n                    odds=odds_dict\n                ))\n\n        race_id = f\"{track.get('code', 'UNK').lower()}_{race_data['postTime'].split('T')[0]}_R{race_data['number']}\"\n\n        return Race(\n            id=race_id,\n            venue=track.get('name', 'Unknown Venue'),\n            race_number=race_data.get('number'),\n            start_time=datetime.fromisoformat(race_data.get('postTime')),\n            runners=runners,\n            source=self.source_name # Corrected based on Oracle feedback\n        )\n\n    def _parse_tvg_odds(self, odds_string: str) -> Optional[Decimal]:\n        # Corrected based on Oracle feedback to return Decimal\n        if not odds_string or odds_string == \"SCR\": return None\n        if odds_string == \"EVEN\": return Decimal('2.0')\n        if \"/\" in odds_string:\n            try:\n                numerator, denominator = odds_string.split(\"/\")\n                return (Decimal(numerator) / Decimal(denominator)) + Decimal('1.0')\n            except (ValueError, ZeroDivisionError, InvalidOperation): return None\n        try: return Decimal(odds_string)\n        except InvalidOperation: return None"
}