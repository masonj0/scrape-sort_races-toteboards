{
    "file_path": "python_service/adapters/tvg_adapter.py",
    "content": "# python_service/adapters/tvg_adapter.py\nfrom datetime import datetime\nfrom typing import Any, List, Optional\n\nfrom ..models import Race, Runner\nfrom ..utils.text import clean_text\nfrom .base_v3 import BaseAdapterV3\n\nclass TVGAdapter(BaseAdapterV3):\n    \"\"\"Adapter for fetching US racing data from the TVG API, using BaseAdapterV3.\"\"\"\n\n    SOURCE_NAME = \"TVG\"\n    BASE_URL = \"https://api.tvg.com/v2/races/\"\n\n    def __init__(self, config=None):\n        super().__init__(source_name=self.SOURCE_NAME, base_url=self.BASE_URL)\n        self.config = config or {}\n        self.tvg_api_key = self.config.TVG_API_KEY\n        if not self.tvg_api_key:\n            self.logger.warning(\"TVG_API_KEY is not set. Adapter will be non-functional.\")\n\n    async def _fetch_data(self, date: str) -> Any:\n        \"\"\"Fetches all race details for a given date by first getting tracks.\"\"\"\n        if not self.tvg_api_key:\n            return None\n\n        headers = {\"X-Api-Key\": self.tvg_api_key}\n        tracks_response = await self.http_client.get(f\"{self.BASE_URL}summary?date={date}&country=USA\", headers=headers)\n        tracks_response.raise_for_status()\n        tracks_data = tracks_response.json()\n\n        all_race_details = []\n        for track in tracks_data.get('tracks', []):\n            track_id = track.get('id')\n            for race in track.get('races', []):\n                race_id = race.get('id')\n                if track_id and race_id:\n                    details_response = await self.http_client.get(f\"{self.BASE_URL}{track_id}/{race_id}\", headers=headers)\n                    if details_response.status_code == 200:\n                        all_race_details.append(details_response.json())\n        return all_race_details\n\n    def _parse_races(self, raw_data: Any) -> List[Race]:\n        \"\"\"Parses the list of detailed race JSON objects into Race models.\"\"\"\n        races = []\n        for race_detail in raw_data:\n            try:\n                track = race_detail.get('track', {})\n                race_info = race_detail.get('race', {})\n\n                runners = []\n                for runner_data in race_detail.get('runners', []):\n                    if runner_data.get('scratched'):\n                        continue\n\n                    odds = runner_data.get('odds', {})\n                    current_odds = odds.get('currentPrice', {})\n                    odds_str = current_odds.get('fractional') or odds.get('morningLinePrice', {}).get('fractional')\n\n                    runners.append(Runner(\n                        number=int(runner_data.get('programNumber', '0').replace('A', '')),\n                        name=clean_text(runner_data.get('name')),\n                        odds=odds_str,\n                        scratched=False\n                    ))\n\n                if runners:\n                    race = Race(\n                        id=f\"tvg_{track.get('code', 'UNK')}_{race_info.get('date', 'NODATE')}_{race_info.get('number', 0)}\",\n                        venue=track.get('name'),\n                        race_number=race_info.get('number'),\n                        start_time=datetime.fromisoformat(race_info.get('postTime').replace('Z', '+00:00')),\n                        runners=runners,\n                        source=self.SOURCE_NAME\n                    )\n                    races.append(race)\n            except (ValueError, AttributeError):\n                self.logger.warning(\"Failed to parse a TVG race detail.\", exc_info=True)\n                continue\n        return races\n\n    async def fetch_races(self, date: str, http_client):\n        pass\n"
}