{
    "file_path": "python_service/adapters/tvg_adapter.py",
    "content": "# python_service/adapters/tvg_adapter.py\n\nimport asyncio\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nimport httpx\nfrom decimal import Decimal, InvalidOperation\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _parse_program_number(program_str: str) -> int:\n    \"\"\"Safely parses program numbers like '1A' into an integer.\"\"\"\n    return int(''.join(filter(str.isdigit, program_str))) if program_str else 99\n\nclass TVGAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"TVG\",\n            base_url=\"https://api.tvg.com/v3/\"\n        )\n        self.api_key = config.TVG_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        headers = {\"Accept\": \"application/json\", \"X-API-Key\": self.api_key}\n\n        if not self.api_key:\n            log.warning(\"TVGAdapter: TVG_API_KEY not set. Skipping.\")\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: TVG_API_KEY not set\")\n\n        try:\n            tracks_url = \"tracks\"\n            tracks_params = {\"date\": date, \"country\": \"US\"}\n            tracks_response = await self.make_request(http_client, 'GET', tracks_url, headers=headers, params=tracks_params)\n\n            if not tracks_response or 'tracks' not in tracks_response:\n                log.warning(\"TVG: No tracks found for the given date.\")\n                return self._format_response([], start_time, is_success=True)\n\n            # Create a list of tasks to fetch races for all tracks concurrently\n            tasks = [self._fetch_races_for_track(track, date, http_client, headers) for track in tracks_response['tracks']]\n            results_per_track = await asyncio.gather(*tasks, return_exceptions=True)\n\n            # Flatten the list of lists into a single list of races\n            all_races = []\n            for result in results_per_track:\n                if isinstance(result, list):\n                    all_races.extend(result)\n                elif isinstance(result, Exception):\n                    log.error(\"TVGAdapter: A track fetch task failed\", error=result)\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except Exception as e:\n            log.error(\"TVGAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    async def _fetch_races_for_track(self, track: Dict[str, Any], date: str, http_client: httpx.AsyncClient, headers: Dict) -> List[Race]:\n        \"\"\"Fetches all race details for a single track concurrently.\"\"\"\n        track_races = []\n        track_code = track.get('code')\n        if not track_code:\n            return []\n\n        try:\n            races_url = f\"tracks/{track_code}/races\"\n            races_params = {\"date\": date}\n            races_response = await self.make_request(http_client, 'GET', races_url, headers=headers, params=races_params)\n            if not races_response or 'races' not in races_response:\n                return []\n\n            # Create a list of tasks to fetch details for all races in this track concurrently\n            detail_tasks = []\n            for race_summary in races_response.get('races', []):\n                race_detail_url = f\"tracks/{track_code}/races/{race_summary['number']}\"\n                detail_tasks.append(self.make_request(http_client, 'GET', race_detail_url, headers=headers))\n\n            race_details = await asyncio.gather(*detail_tasks, return_exceptions=True)\n\n            for detail in race_details:\n                if detail and not isinstance(detail, Exception):\n                    parsed_race = self._parse_tvg_race(track, detail)\n                    track_races.append(parsed_race)\n            return track_races\n        except Exception as e:\n            log.error(\"TVGAdapter: Failed to process track\", track_name=track.get('name'), error=str(e))\n            return [] # Return empty list for this track on failure\n\n    def _parse_tvg_race(self, track: Dict[str, Any], race_data: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in race_data.get('runners', []):\n            if not runner_data.get('scratched'):\n                current_odds_str = runner_data.get('odds', {}).get('current') or runner_data.get('odds', {}).get('morningLine')\n                win_odds = self._parse_tvg_odds(current_odds_str)\n                odds_dict = {}\n                if win_odds:\n                    odds_dict[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n                runners.append(Runner(number=_parse_program_number(runner_data.get('programNumber')), name=runner_data.get('horseName', 'Unknown Runner'), scratched=False, odds=odds_dict))\n        race_id = f\"{track.get('code', 'UNK').lower()}_{race_data['postTime'].split('T')[0]}_R{race_data['number']}\"\n        return Race(id=race_id, venue=track.get('name', 'Unknown Venue'), race_number=race_data.get('number'), start_time=datetime.fromisoformat(race_data.get('postTime')), runners=runners, source=self.source_name)\n\n    def _parse_tvg_odds(self, odds_string: str) -> Optional[Decimal]:\n        if not odds_string or odds_string == \"SCR\":\n            return None\n        try:\n            parsed_float = parse_odds(odds_string)\n            if parsed_float >= 999.0:\n                return None\n            return Decimal(str(parsed_float))\n        except (ValueError, InvalidOperation):\n            log.warning(\"Could not convert parsed TVG odds to Decimal\", odds_str=odds_string)\n            return None"
}