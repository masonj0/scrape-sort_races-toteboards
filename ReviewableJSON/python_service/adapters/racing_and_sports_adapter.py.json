{
    "file_path": "python_service/adapters/racing_and_sports_adapter.py",
    "content": "# python_service/adapters/racing_and_sports_adapter.py\n\nimport os\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass RacingAndSportsAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"Racing and Sports\",\n            base_url=\"https://api.racingandsports.com.au/\"\n        )\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Authorization\": f\"Bearer {self.api_token}\", \"Accept\": \"application/json\"}\n\n        if not self.api_token:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: Token not set\")\n\n        try:\n            meetings_url = \"v1/racing/meetings\"\n            params = {\"date\": date, \"jurisdiction\": \"AUS\"}\n            meetings_data = await self.make_request(http_client, 'GET', meetings_url, headers=headers, params=params)\n\n            if not meetings_data or not meetings_data.get('meetings'):\n                return self._format_response(all_races, start_time, is_success=True)\n\n            for meeting in meetings_data['meetings']:\n                for race_summary in meeting.get('races', []):\n                    try:\n                        parsed_race = self._parse_ras_race(meeting, race_summary)\n                        all_races.append(parsed_race)\n                    except Exception as e:\n                        log.error(\"RacingAndSportsAdapter: Failed to parse race\", meeting=meeting.get('venueName'), error=str(e), exc_info=True)\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"RacingAndSportsAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"RacingAndSportsAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races), 'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('runnerNumber'), name=rd.get('horseName', 'Unknown'), scratched=rd.get('isScratched', False)) for rd in race.get('runners', [])]\n\n        return Race(\n            id=f\"ras_{race.get('raceId')}\",\n            venue=meeting.get('venueName', 'Unknown Venue'),\n            race_number=race.get('raceNumber'),\n            start_time=datetime.fromisoformat(race.get('startTime')),\n            runners=runners,\n            source=self.source_name\n        )"
}