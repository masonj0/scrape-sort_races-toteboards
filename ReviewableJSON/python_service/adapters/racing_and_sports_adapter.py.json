{
    "filepath": "python_service/adapters/racing_and_sports_adapter.py",
    "content": "# python_service/adapters/racing_and_sports_adapter.py\n\nimport os\nimport logging\nimport requests\nfrom typing import List, Optional\nfrom datetime import datetime, timezone\n\nfrom ..models import RaceData\n\nclass RacingAndSportsAdapter:\n    \"\"\"\n    Adapter for the RacingAndSports API, enhanced for multi-race type coverage.\n    \"\"\"\n    SOURCE_ID = \"ras\"\n    API_TEMPLATE = \"https://api.racingandsports.com.au/Meetings?RaceType={race_type}\"\n    RACE_TYPES = ['R', 'G', 'H']  # R=Thoroughbred, G=Greyhound, H=Harness\n\n    def __init__(self, api_key: Optional[str] = None):\n        self.logger = logging.getLogger(self.__class__.__name__)\n        self.api_key = api_key or os.getenv(\"RAS_API_KEY\")\n\n    def _fetch_data(self, url, headers):\n        try:\n            response = requests.get(url, headers=headers, timeout=15)\n            response.raise_for_status()\n            return response.json()\n        except requests.RequestException as e:\n            self.logger.error(f\"GET request to {url} failed: {e}\")\n            return None\n\n    def fetch_races(self) -> List[RaceData]:\n        if not self.api_key:\n            self.logger.warning(\"RAS_API_KEY not configured. Skipping RacingAndSports.\")\n            return []\n\n        self.logger.info(\"Fetching from RacingAndSports for all T/H/G race types...\")\n        all_races: List[RaceData] = []\n        headers = {\"X-API-Key\": self.api_key}\n\n        for race_type in self.RACE_TYPES:\n            url = self.API_TEMPLATE.format(race_type=race_type)\n            meetings_data = self._fetch_data(url, headers=headers)\n            if not meetings_data or not isinstance(meetings_data, list):\n                self.logger.warning(f\"Invalid or empty response from RAS for race type: {race_type}\")\n                continue\n\n            races = self._parse_meetings(meetings_data, race_type)\n            all_races.extend(races)\n\n        self.logger.info(f\"Successfully fetched {len(all_races)} total races from RacingAndSports.\")\n        return all_races\n\n    def _parse_meetings(self, meetings: List[dict], race_type: str) -> List[RaceData]:\n        \"\"\"\n        Parses a list of meetings to extract individual races.\n        \"\"\"\n        parsed_races = []\n        for meeting in meetings:\n            track_name = meeting.get('Venue', 'Unknown Track')\n            for race_data in meeting.get('Races', []):\n                try:\n                    post_time_str = race_data.get('StartTimeUTC', '')\n                    if not post_time_str:\n                        continue\n                    post_time = datetime.fromisoformat(post_time_str.replace('Z', '+00:00'))\n\n                    if post_time < datetime.now(timezone.utc):\n                        continue\n\n                    placeholder_race = RaceData(\n                        race_id=f\"ras_{race_data.get('RaceID')}\",\n                        track_name=track_name,\n                        race_number=race_data.get('RaceNo'),\n                        post_time=post_time,\n                        runners=[],\n                        source=self.SOURCE_ID,\n                    )\n                    parsed_races.append(placeholder_race)\n                except (KeyError, TypeError, ValueError) as e:\n                    self.logger.warning(f\"Skipping malformed RAS race: {e}\")\n                    continue\n        return parsed_races"
}