{
    "file_path": "python_service/adapters/oddschecker_adapter.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Oddschecker Adapter (Canonized)\n# ==============================================================================\n# This adapter was sourced from the 'Live Odds Anthology' and has been modernized\n# to conform to the project's current BaseAdapter framework.\n# ==============================================================================\n\nimport asyncio\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\n\nimport httpx\nimport structlog\nfrom bs4 import BeautifulSoup\nfrom bs4 import Tag\n\nfrom ..models import OddsData\nfrom ..models import Race\nfrom ..models import Runner\nfrom .base import BaseAdapter\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\n\nclass OddscheckerAdapter(BaseAdapter):\n    \"\"\"Adapter for scraping live horse racing odds from Oddschecker.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(source_name=\"Oddschecker\", base_url=\"https://www.oddschecker.com\")\n        self.config = config\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            meeting_links = await self._get_all_meeting_links(http_client)\n            if not meeting_links:\n                return self._format_response([], start_time, is_success=True, error_message=\"No meeting links found.\")\n\n            tasks = [self._fetch_single_meeting(link, http_client) for link in meeting_links]\n            races_from_all_meetings = await asyncio.gather(*tasks)\n\n            all_races = [race for sublist in races_from_all_meetings for race in sublist if race]\n            return self._format_response(all_races, start_time)\n        except Exception as e:\n            log.error(\"OddscheckerAdapter failed\", exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_all_meeting_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        html = await self.make_request(http_client, \"GET\", \"/horse-racing\")\n        soup = BeautifulSoup(html, \"html.parser\")\n        links = {self.base_url + a[\"href\"] for a in soup.select(\"a.meeting-title[href]\")}\n        return sorted(list(links))\n\n    async def _fetch_single_meeting(self, url: str, client: httpx.AsyncClient) -> List[Optional[Race]]:\n        try:\n            html = await self.make_request(client, \"GET\", url.replace(self.base_url, \"\"))\n            soup = BeautifulSoup(html, \"html.parser\")\n            race_links = {self.base_url + a[\"href\"] for a in soup.select(\"a.race-time-link[href]\")}\n            tasks = [self._fetch_and_parse_race_card(link, client) for link in race_links]\n            return await asyncio.gather(*tasks)\n        except Exception as e:\n            log.error(\"Oddschecker failed to fetch meeting\", url=url, error=e)\n            return []\n\n    async def _fetch_and_parse_race_card(self, url: str, client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            html = await self.make_request(client, \"GET\", url.replace(self.base_url, \"\"))\n            soup = BeautifulSoup(html, \"html.parser\")\n            return self._parse_race_page(soup, url)\n        except Exception as e:\n            log.error(\"Oddschecker failed to parse race card\", url=url, error=e)\n            return None\n\n    def _parse_race_page(self, soup: BeautifulSoup, url: str) -> Optional[Race]:\n        track_name = (\n            soup.select_one(\"h1.meeting-name\").get_text(strip=True) if soup.select_one(\"h1.meeting-name\") else \"Unknown\"\n        )\n        race_time_str = (\n            soup.select_one(\"span.race-time\").get_text(strip=True) if soup.select_one(\"span.race-time\") else None\n        )\n        race_number = int(url.split(\"-\")[-1]) if \"race-\" in url else 0\n\n        runners = []\n        for row in soup.select(\"tr.race-card-row\"):\n            runner = self._parse_runner_row(row)\n            if runner:\n                runners.append(runner)\n\n        if not runners:\n            return None\n\n        start_time = datetime.now()  # Default to now\n        if race_time_str:\n            try:\n                today_str = datetime.now().strftime(\"%Y-%m-%d\")\n                start_time = datetime.strptime(f\"{today_str} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            except ValueError:\n                log.warning(\"Could not parse race time\", time_str=race_time_str)\n\n        return Race(\n            id=f\"oc_{track_name.lower().replace(' ', '')}_{start_time.strftime('%Y%m%d')}_r{race_number}\",\n            venue=track_name,\n            race_number=race_number,\n            start_time=start_time,\n            runners=runners,\n        )\n\n    def _parse_runner_row(self, row: Tag) -> Optional[Runner]:\n        name_tag = row.select_one(\"span.selection-name\")\n        name = name_tag.get_text(strip=True) if name_tag else None\n        odds_tag = row.select_one(\"span.bet-button-odds-desktop, span.best-price\")\n        odds_str = odds_tag.get_text(strip=True) if odds_tag else None\n        number_tag = row.select_one(\"td.runner-number\")\n        number = int(number_tag.get_text(strip=True)) if number_tag else 0\n\n        if not name or not odds_str:\n            return None\n\n        odds_val = parse_odds(odds_str)\n        odds_dict = {}\n        if odds_val:\n            odds_dict[self.source_name] = OddsData(\n                win=Decimal(str(odds_val)), source=self.source_name, last_updated=datetime.now()\n            )\n\n        return Runner(number=number, name=name, odds=odds_dict)\n\n    def _format_response(\n        self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None\n    ) -> Dict[str, Any]:\n        \"\"\"Formats the adapter's response consistently.\"\"\"\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            \"races\": races,\n            \"source_info\": {\n                \"name\": self.source_name,\n                \"status\": \"SUCCESS\" if is_success else \"FAILED\",\n                \"races_fetched\": len(races),\n                \"error_message\": error_message,\n                \"fetch_duration\": fetch_duration,\n            },\n        }\n"
}