{
    "file_path": "python_service/adapters/base.py",
    "content": "# python_service/adapters/base.py\nimport httpx\nimport structlog\nfrom tenacity import AsyncRetrying, stop_after_attempt, wait_exponential\n\nclass BaseAdapter:\n    \"\"\"The base class for all data adapters, now with enhanced error handling.\"\"\"\n\n    def __init__(self, source_name: str, base_url: str = \"\", config: dict = None):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.config = config or {}\n        self.logger = structlog.get_logger(self.__class__.__name__)\n        self.retryer = AsyncRetrying(\n            stop=stop_after_attempt(3),\n            wait=wait_exponential(multiplier=1, min=2, max=10)\n        )\n        # Circuit Breaker State\n        self.circuit_breaker_tripped = False\n        self.circuit_breaker_failure_count = 0\n        self.circuit_breaker_last_failure = 0\n        self.FAILURE_THRESHOLD = 3\n        self.COOLDOWN_PERIOD_SECONDS = 300  # 5 minutes\n\n    async def make_request(self, http_client: httpx.AsyncClient, method: str, url: str, **kwargs):\n        full_url = url if url.startswith('http') else f\"{self.base_url}{url}\"\n\n        async def _make_request():\n            response = await http_client.request(method, full_url, **kwargs)\n            response.raise_for_status()\n            # Note: Previously, this returned response.json(), but that prevents\n            # the Timeform adapter from reading .text for HTML parsing.\n            # Returning the full response object is more flexible.\n            return response\n\n        try:\n            async for attempt in self.retryer:\n                with attempt:\n                    return await _make_request()\n        except httpx.HTTPStatusError as e:\n            self.logger.error(\n                \"http_error\",\n                adapter=self.source_name,\n                status_code=e.response.status_code,\n                url=full_url,\n            )\n            self._show_windows_toast(\n                \"Adapter HTTP Error\", f\"{self.source_name}: Received status {e.response.status_code} from {full_url}\"\n            )\n            return None\n        except httpx.RequestError as e:\n            self.logger.error(\"request_error\", adapter=self.source_name, error=str(e), url=full_url)\n            self._show_windows_toast(\"Adapter Network Error\", f\"{self.source_name}: Could not connect to {full_url}\")\n            return None\n        except Exception as e:\n            self.logger.error(\"unexpected_adapter_error\", adapter=self.source_name, error=str(e), exc_info=True)\n            self._show_windows_toast(\"Adapter Unexpected Error\", f\"{self.source_name}: An unknown error occurred.\")\n            return None\n\n    def _show_windows_toast(self, title: str, message: str):\n        try:\n            from windows_toasts import Toast, WindowsToaster\n            toaster = WindowsToaster(title)\n            new_toast = Toast()\n            new_toast.text_fields = [message]\n            toaster.show_toast(new_toast)\n        except (ImportError, RuntimeError):\n            # Fail silently if not on Windows or if notifier fails\n            pass"
}