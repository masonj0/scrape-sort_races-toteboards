{
    "file_path": "python_service/adapters/base.py",
    "content": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Base Adapter (v2 - Hardened with Tenacity)\n# ==============================================================================\n\nimport httpx\nimport structlog\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional\nfrom tenacity import retry, stop_after_attempt, wait_exponential, RetryError, AsyncRetrying\n\nlog = structlog.get_logger(__name__)\n\nclass BaseAdapter(ABC):\n    \"\"\"The resilient base class for all data source adapters.\"\"\"\n\n    def __init__(self, source_name: str, base_url: str, timeout: int = 20, max_retries: int = 3):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n    @abstractmethod\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        raise NotImplementedError\n\n    async def make_request(self, http_client: httpx.AsyncClient, method: str, url: str, **kwargs) -> Optional[Any]:\n        \"\"\"Makes a resilient HTTP request with automatic retries using Tenacity.\"\"\"\n        retryer = AsyncRetrying(\n            stop=stop_after_attempt(self.max_retries),\n            wait=wait_exponential(multiplier=1, min=2, max=10),\n            reraise=True\n        )\n        try:\n            async for attempt in retryer:\n                with attempt:\n                    try:\n                        full_url = url if url.startswith('http') else f\"{self.base_url}{url}\"\n                        log.info(f\"Requesting...\", adapter=self.source_name, method=method, url=full_url, attempt=attempt.retry_state.attempt_number)\n                        response = await http_client.request(method, full_url, timeout=self.timeout, **kwargs)\n                        response.raise_for_status()\n                        return response.json()\n                    except (httpx.RequestError, httpx.HTTPStatusError) as e:\n                        log.warning(\"Request failed, tenacity will retry...\", adapter=self.source_name, error=str(e))\n                        raise # Reraise to trigger tenacity's retry mechanism\n        except RetryError as e:\n            log.error(f\"Max retries exceeded for {self.source_name}. Aborting request.\", final_error=str(e))\n            return None # Return None on total failure\n\n    def get_status(self) -> Dict[str, Any]:\n        return {\"adapter_name\": self.source_name, \"status\": \"OK\"}"
}