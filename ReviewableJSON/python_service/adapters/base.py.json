{
    "file_path": "python_service/adapters/base.py",
    "content": "# python_service/adapters/base.py\n\nimport asyncio\nimport logging\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\nimport httpx\n\nclass BaseAdapter(ABC):\n    def __init__(self, source_name: str, base_url: str, timeout: int = 30, max_retries: int = 3):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    @abstractmethod\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        raise NotImplementedError\n\n    async def make_request(self, http_client: httpx.AsyncClient, method: str, url: str, **kwargs) -> Any:\n        retry_count = 0\n        while retry_count < self.max_retries:\n            try:\n                full_url = f\"{self.base_url}{url}\"\n                self.logger.info(f\"Requesting {method} {full_url}\")\n                response = await http_client.request(method, full_url, timeout=self.timeout, **kwargs)\n                response.raise_for_status()\n                return response.json()\n            except (httpx.RequestError, httpx.HTTPStatusError) as e:\n                self.logger.warning(f\"Request failed for {self.source_name} (attempt {retry_count + 1}/{self.max_retries}): {e}\")\n                retry_count += 1\n                if retry_count >= self.max_retries:\n                    self.logger.error(f\"Max retries exceeded for {self.source_name}. Aborting.\")\n                    raise\n                backoff = 1 * (2 ** retry_count) # Exponential backoff\n                await asyncio.sleep(backoff)\n        raise Exception(\"make_request failed after max retries\")\n\n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Returns a dictionary representing the adapter's default status.\"\"\"\n        return {\"adapter_name\": self.source_name, \"status\": \"OK\"}\n"
}