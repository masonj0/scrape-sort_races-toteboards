{
    "file_path": "python_service/middleware/error_handler.py",
    "content": "# python_service/middleware/error_handler.py\nimport structlog\nimport httpx\nfrom fastapi import Request, Response\nfrom fastapi.responses import JSONResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint\nfrom pydantic import ValidationError\nimport json\n\nfrom ..core.errors import ErrorCategory\n\nlogger = structlog.get_logger(__name__)\n\ndef _get_error_category(exc: Exception) -> ErrorCategory:\n    \"\"\"Maps an exception type to a defined ErrorCategory.\"\"\"\n    if isinstance(exc, httpx.RequestError):\n        return ErrorCategory.NETWORK_ERROR\n    if isinstance(exc, (ValidationError, json.JSONDecodeError)):\n        return ErrorCategory.PARSING_ERROR\n    # In a more complex system, we could check for specific config errors\n    # if isinstance(exc, ConfigNotFoundError): return ErrorCategory.CONFIGURATION_ERROR\n    return ErrorCategory.UNEXPECTED_ERROR\n\nclass ErrorHandlingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:\n        try:\n            return await call_next(request)\n        except Exception as exc:\n            category = _get_error_category(exc)\n\n            logger.error(\n                \"unhandled_exception_caught\",\n                error_category=category.name,\n                error_message=str(exc),\n                path=request.url.path,\n                method=request.method,\n                exc_info=True,\n            )\n\n            return JSONResponse(\n                status_code=500,\n                content={\n                    \"error\": {\n                        \"category\": category.name,\n                        \"message\": category.value,\n                        \"detail\": str(exc),\n                    }\n                },\n            )"
}