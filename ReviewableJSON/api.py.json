{
    "filepath": "src/checkmate_v7/api.py",
    "content": "\"\"\"\nCheckmate V7: `api.py` - THE CONDUCTOR\n\"\"\"\nfrom fastapi import FastAPI, HTTPException\nfrom typing import List\nfrom datetime import datetime, timezone, timedelta\n\n# These will be placeholder imports until other files are created\nfrom .models import PredictionSchema, PredictionORM\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\n\n# Placeholder for get_db_session\ndef get_db_session():\n    # In a real setup, this would use a configured database URL\n    # Using an in-memory sqlite for this recreation\n    engine = create_engine(\"sqlite:///:memory:\")\n    # This is also a placeholder, as the PredictionORM table won't exist\n    # until we have a proper setup. The test will mock this away.\n    from .models import Base\n    Base.metadata.create_all(bind=engine)\n    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n    return SessionLocal()\n\napp = FastAPI()\n\n@app.get(\"/predictions/active\", response_model=List[PredictionSchema])\ndef get_active_predictions():\n    \"\"\"\n    Returns a list of all active (pending) predictions with calculated\n    time-to-post and scores.\n    \"\"\"\n    session = get_db_session()\n    try:\n        active_preds = session.query(PredictionORM).filter_by(status='pending').all()\n        \n        response_data = []\n        for pred in active_preds:\n            minutes_to_post = 0.0\n            if pred.race_local_datetime:\n                now_utc = datetime.now(timezone.utc)\n                # Assume race_local_datetime is naive, make it timezone-aware (UTC)\n                post_time_utc = pred.race_local_datetime.replace(tzinfo=timezone.utc)\n                time_diff_seconds = (post_time_utc - now_utc).total_seconds()\n                minutes_to_post = time_diff_seconds / 60\n            \n            pred_schema = PredictionSchema(\n                prediction_id=pred.prediction_id,\n                race_key=pred.race_key,\n                status=pred.status,\n                minutes_to_post=minutes_to_post,\n                score_total=pred.score_total\n            )\n            response_data.append(pred_schema)\n            \n        return response_data\n    except SQLAlchemyError as e:\n        # A real logger would be used here\n        print(f\"Database error: {e}\")\n        raise HTTPException(status_code=500, detail=\"Database error\")\n    finally:\n        session.close()\n"
}