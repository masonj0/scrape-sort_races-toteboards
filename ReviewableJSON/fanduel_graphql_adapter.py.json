{
    "filepath": "src/paddock_parser/adapters/fanduel_graphql_adapter.py",
    "content": "import json\nimport httpx\nimport logging\nfrom datetime import datetime\nfrom typing import List, Dict, Any\n\nfrom ..base import BaseAdapter, NormalizedRace, NormalizedRunner\n\n\ndef parse_from_json(schedule_data: str, detail_data: str) -> List[NormalizedRace]:\n    \"\"\"\n    Parses the two-stage JSON data from FanDuel's GraphQL API into a list of\n    standardized race objects.\n    \"\"\"\n    schedule = json.loads(schedule_data)\n    detail = json.loads(detail_data)\n\n    # Create a lookup dictionary for schedule information for efficient access\n    schedule_lookup = {}\n    for track in schedule.get(\"data\", {}).get(\"scheduleRaces\", []):\n        for race_info in track.get(\"races\", []):\n            schedule_lookup[race_info[\"id\"]] = race_info\n\n    normalized_races = []\n    for race_detail in detail.get(\"data\", {}).get(\"races\", []):\n        race_id = race_detail.get(\"id\")\n        if not race_id or race_id not in schedule_lookup:\n            continue\n\n        race_schedule_info = schedule_lookup[race_id]\n\n        runners = []\n        for interest in race_detail.get(\"bettingInterests\", []):\n            runner_info = interest.get(\"runners\", [{}])[0]\n            if not runner_info.get(\"scratched\"):\n                odds_info = interest.get(\"currentOdds\", {})\n                odds_num = odds_info.get('numerator')\n                odds = float(odds_num) if odds_num is not None else None\n\n                runner = NormalizedRunner(\n                    name=runner_info.get(\"horseName\"),\n                    program_number=interest.get(\"biNumber\"),\n                    scratched=runner_info.get(\"scratched\", False),\n                    jockey=runner_info.get(\"jockey\"),\n                    trainer=runner_info.get(\"trainer\"),\n                    odds=odds,\n                )\n                runners.append(runner)\n\n        # If there are no non-scratched runners, we can skip this race.\n        if not runners:\n            continue\n\n        normalized_race = NormalizedRace(\n            race_id=race_id,\n            track_name=race_schedule_info.get(\"track\", {}).get(\"name\"),\n            race_number=int(race_schedule_info.get(\"number\")),\n            post_time=datetime.fromisoformat(race_schedule_info.get(\"postTime\").replace(\"Z\", \"+00:00\")),\n            race_type=race_schedule_info.get(\"type\", {}).get(\"code\"),\n            minutes_to_post=race_schedule_info.get(\"mtp\"),\n            number_of_runners=len(runners),\n            runners=runners,\n        )\n        normalized_races.append(normalized_race)\n\n    return normalized_races\n\n\nclass FanDuelGraphQLAdapter(BaseAdapter):\n    \"\"\"\n    Adapter for fetching and parsing data from the FanDuel GraphQL API.\n    \"\"\"\n    SOURCE_ID = \"fanduel\"\n    API_ENDPOINT = \"https://api.racing.fanduel.com/cosmo/v1/graphql\"\n    HEADERS = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"content-type\": \"application/json\"\n    }\n    SCHEDULE_QUERY = {\n        \"operationName\": \"getLhnInfo\",\n        \"variables\": {\"withGreyhounds\": False, \"brand\": \"FDR\", \"product\": \"TVG5\", \"device\": \"Desktop\", \"noLoggedIn\": True, \"wagerProfile\": \"FDR-Generic\"},\n        \"query\": \"query getLhnInfo($wagerProfile: String, $withGreyhounds: Boolean, $noLoggedIn: Boolean!, $product: String, $device: String, $brand: String) { scheduleRaces: tracks(profile: $wagerProfile) { id races( filter: {status: [\\\"MO\\\", \\\"O\\\", \\\"SK\\\", \\\"IC\\\"] allRaceClasses: $withGreyhounds} page: {results: 2, current: 0} sort: {byMTP: ASC} ) { id tvgRaceId mtp number postTime isGreyhound location { country __typename } track { id isFavorite @skip(if: $noLoggedIn) code name perfAbbr featured hasWagersToday @skip(if: $noLoggedIn) __typename } highlighted(product: $product, device: $device, brand: $brand) { description pinnedOrder action style __typename } promos(product: $product, brand: $brand) { rootParentPromoID isAboveTheLine promoPath isPromoTagShown __typename } type { code __typename } status { code __typename } video { onTvg onTvg2 __typename } __typename } __typename } }\"\n    }\n    DETAIL_QUERY = {\n        \"operationName\": \"getGraphRaceBettingInterest\",\n        \"variables\": {\"tvgRaceIds\": [], \"tvgRaceIdsBiPartial\": [], \"wagerProfile\": \"FDR-Generic\"},\n        \"query\": \"query getGraphRaceBettingInterest($tvgRaceIds: [Long], $tvgRaceIdsBiPartial: [Long], $wagerProfile: String) { races: races( tvgRaceIds: $tvgRaceIds profile: $wagerProfile sorts: [{byRaceNumber: ASC}] ) { id tvgRaceId bettingInterests { biNumber saddleColor numberColor favorite currentOdds { numerator denominator __typename } morningLineOdds { numerator denominator __typename } recentOdds(pages: [{current: 0, results: 4}]) { odd trending __typename } biPools { wagerType { id code name __typename } poolRunnersData { amount __typename } __typename } runners { runnerId entityRunnerId scratched horseName age sex weight med jockey trainer dob hasJockeyChanges ...timeformFragment handicapping { freePick { number info __typename } __typename } ...handicappingFragment __typename } __typename } ...Probables ...RacePools ...WillPays __typename } racesBiPartial: races( tvgRaceIds: $tvgRaceIdsBiPartial profile: $wagerProfile sorts: [{byRaceNumber: ASC}] ) { id tvgRaceId bettingInterests { biNumber saddleColor numberColor favorite currentOdds { numerator denominator __typename } morningLineOdds { numerator denominator __typename } runners { runnerId entityRunnerId scratched horseName jockey trainer hasJockeyChanges winProbability __typename } __typename } __typename } }\\\\n\\\\nfragment handicappingFragment on Runner { ownerName sire damSire dam handicapping { speedAndClass { avgClassRating highSpeed avgSpeed lastClassRating avgDistance __typename } averagePace { finish numRaces middle early __typename } jockeyTrainer { places jockeyName trainerName shows wins starts __typename } snapshot { powerRating daysOff horseWins horseStarts __typename } pastResults { totalNumberOfStarts numberOfFirstPlace numberOfSecondPlace numberOfThirdPlace winPercentage winPercentageRanking top3Percentage top3PercentageRanking __typename } __typename } __typename }\\\\n\\\\nfragment timeformFragment on Runner { timeform { analystsComments silkUrl silkUrlSvg freePick { number info __typename } flags { horseInFocus warningHorse jockeyUplift trainerUplift horsesForCoursePos horsesForCourseNeg hotTrainer coldTrainer highestLastSpeedRating sectionalFlag significantImprover jockeyInForm clearTopRated interestingJockeyBooking firstTimeBlinkers __typename } __typename } __typename }\\\\n\\\\nfragment Probables on Race { probables { amount minWagerAmount wagerType { id code name __typename } betCombos { runner1 runner2 payout __typename } __typename } __typename }\\\\n\\\\nfragment RacePools on Race { racePools { wagerType { id code name __typename } amount __typename } __typename } __typename }\\\\n\\\\nfragment WillPays on Race { willPays { wagerAmount payOffType type { id code name __typename } payouts { bettingInterestNumber payoutAmount __typename } legResults { legNumber winningBi __typename } __typename } __typename } }\"\n    }\n\n\n    def fetch_data(self) -> Dict[str, Any]:\n        \"\"\"\n        Fetches schedule and detail data from the FanDuel GraphQL endpoint.\n        \"\"\"\n        with httpx.Client() as client:\n            try:\n                # Fetch the race schedule\n                schedule_response = client.post(self.API_ENDPOINT, json=self.SCHEDULE_QUERY, headers=self.HEADERS)\n                schedule_response.raise_for_status()\n                schedule_json = schedule_response.json()\n\n                # Extract tvgRaceIds from the schedule\n                tvg_race_ids = []\n                for track in schedule_json.get(\"data\", {}).get(\"scheduleRaces\", []):\n                    for race in track.get(\"races\", []):\n                        if race.get(\"tvgRaceId\"):\n                            tvg_race_ids.append(race[\"tvgRaceId\"])\n\n                if not tvg_race_ids:\n                    logging.warning(\"No races found in the schedule.\")\n                    return {\"schedule\": schedule_response.text, \"detail\": \"{}\"}\n\n                # Fetch the details for the found races\n                detail_query = self.DETAIL_QUERY.copy()\n                detail_query[\"variables\"][\"tvgRaceIds\"] = tvg_race_ids\n\n                detail_response = client.post(self.API_ENDPOINT, json=detail_query, headers=self.HEADERS)\n                detail_response.raise_for_status()\n\n                return {\n                    \"schedule\": schedule_response.text,\n                    \"detail\": detail_response.text\n                }\n\n            except httpx.RequestError as e:\n                logging.error(f\"An error occurred while requesting {e.request.url!r}: {e}\")\n                return {\"schedule\": \"{}\", \"detail\": \"{}\"}\n            except httpx.HTTPStatusError as e:\n                logging.error(f\"Error response {e.response.status_code} while requesting {e.request.url!r}.\")\n                return {\"schedule\": \"{}\", \"detail\": \"{}\"}\n\n\n    def parse_data(self, raw_data: Dict[str, Any]) -> List[NormalizedRace]:\n        \"\"\"\n        Parses the raw FanDuel GraphQL data by calling the standalone function.\n        \"\"\"\n        return parse_from_json(raw_data[\"schedule\"], raw_data[\"detail\"])\n"
}