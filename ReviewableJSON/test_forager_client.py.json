{"content": "import pytest\nimport httpx\nfrom unittest.mock import patch, AsyncMock, MagicMock\nfrom paddock_parser.forager.http_client import ForagerClient\n\n@pytest.mark.anyio\n@patch(\"random.choice\")\n@patch(\"httpx.AsyncClient\")\nasync def test_forager_client_uses_random_user_agent(mock_async_client, mock_random_choice):\n    \"\"\"\n    Tests that the ForagerClient's fetch method uses a randomly selected User-Agent.\n    \"\"\"\n    # --- Setup ---\n    # 1. Mock the response object that client.get() will return\n    mock_response = MagicMock()\n    mock_response.raise_for_status = MagicMock() # This is a regular method, not awaited\n    mock_response.text = \"<html></html>\"\n\n    # 2. Mock the client instance that the 'async with' will yield\n    mock_client_instance = AsyncMock()\n    mock_client_instance.get.return_value = mock_response # .get() returns our response mock\n\n    # 3. Set up the async context manager\n    mock_async_client.return_value.__aenter__.return_value = mock_client_instance\n\n    # 4. Mock random.choice\n    test_user_agent = \"Test-User-Agent-123\"\n    mock_random_choice.return_value = test_user_agent\n\n    forager = ForagerClient()\n    test_url = \"http://example.com\"\n\n    # --- Run ---\n    await forager.fetch(test_url)\n\n    # --- Assertions ---\n    mock_random_choice.assert_called_once_with(ForagerClient.USER_AGENTS)\n    expected_headers = {\"User-Agent\": test_user_agent}\n    mock_client_instance.get.assert_called_once_with(test_url, headers=expected_headers, follow_redirects=True)\n\n@pytest.mark.anyio\n@patch(\"paddock_parser.forager.http_client.asyncio.sleep\", return_value=None)\n@patch(\"httpx.AsyncClient\")\nasync def test_forager_client_retries_on_failure(mock_async_client, mock_sleep):\n    \"\"\"\n    Tests that the ForagerClient's fetch method retries on transient errors.\n    \"\"\"\n    # --- Setup ---\n    # 1. Mock the client to fail twice, then succeed\n    mock_client_instance = AsyncMock()\n    \n    # Create a mock for the successful response\n    mock_success_response = MagicMock()\n    mock_success_response.raise_for_status = MagicMock()\n    mock_success_response.text = \"Success\"\n\n    mock_client_instance.get.side_effect = [\n        httpx.RequestError(\"Connection failed\"),\n        httpx.HTTPStatusError(\"Server error\", request=MagicMock(), response=MagicMock(status_code=503)),\n        mock_success_response\n    ]\n    mock_async_client.return_value.__aenter__.return_value = mock_client_instance\n    \n    # Use a client with known retry settings for the test\n    forager = ForagerClient(max_retries=3, backoff_factor=0.1)\n    test_url = \"http://example.com\"\n\n    # --- Run ---\n    result = await forager.fetch(test_url)\n\n    # --- Assertions ---\n    assert result == \"Success\"\n    \n    # Check that fetch was attempted 3 times (1 initial + 2 retries)\n    assert mock_client_instance.get.call_count == 3\n    \n    # Check that asyncio.sleep was called with the correct backoff times\n    assert mock_sleep.call_count == 2\n    mock_sleep.assert_any_call(0.1 * (2 ** 0))\n    mock_sleep.assert_any_call(0.1 * (2 ** 1))\n"}
