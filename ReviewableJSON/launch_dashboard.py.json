{
    "filepath": "launch_dashboard.py",
    "content": "import time\nimport asyncio\nimport pandas as pd\nimport streamlit as st\nfrom datetime import datetime, UTC\n\nfrom src.paddock_parser.pipeline import run_pipeline\nfrom src.paddock_parser.scorer import find_checkmate_opportunities\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Paddock Parser NG - Checkmate Alert System\")\n\nst.markdown(\n    \"\"\"\n    This dashboard continuously monitors for the \"Checkmate\" betting opportunity.\n    When a race meets the specified criteria and is near its post time, an alert\n    will be displayed.\n    \"\"\"\n)\n\n# Initialize session state\nif 'monitoring' not in st.session_state:\n    st.session_state.monitoring = False\nif 'last_run' not in st.session_state:\n    st.session_state.last_run = None\n\n# --- Control Buttons ---\ncol1, col2 = st.columns(2)\nwith col1:\n    if st.button(\"Start Monitoring\", type=\"primary\"):\n        st.session_state.monitoring = True\n        st.session_state.last_run = datetime.now(UTC)\n\nwith col2:\n    if st.button(\"Stop Monitoring\"):\n        st.session_state.monitoring = False\n\n# --- Live Monitoring Loop ---\nif st.session_state.monitoring:\n    st.success(\"Monitoring for Checkmate opportunities... The dashboard will update automatically.\")\n    \n    # Create placeholders for live data\n    placeholder = st.empty()\n    \n    while st.session_state.monitoring:\n        with placeholder.container():\n            st.write(f\"Last check: {datetime.now(UTC).strftime('%Y-%m-%d %H:%M:%S')} UTC\")\n            \n            with st.spinner(\"Running pipeline for `rpb2b` adapter...\"):\n                try:\n                    races = asyncio.run(\n                        run_pipeline(min_runners=0, time_window_minutes=120, specific_source=\"rpb2b\")\n                    )\n                    \n                    if races:\n                        checkmate_races = find_checkmate_opportunities(races)\n                        \n                        alert_races = []\n                        for race in checkmate_races:\n                            if race.post_time:\n                                time_diff = race.post_time - datetime.now(UTC)\n                                minutes_to_post = time_diff.total_seconds() / 60\n                                if 0 <= minutes_to_post <= 5:\n                                    alert_races.append(race)\n\n                        if alert_races:\n                            st.header(\"\ud83d\udea8 Checkmate Opportunity Found! \ud83d\udea8\")\n                            st.balloons()\n                            \n                            race_list = []\n                            for race in alert_races:\n                                race_list.append({\n                                    \"Track\": race.track_name,\n                                    \"Time\": race.post_time.strftime(\"%H:%M\") if race.post_time else \"N/A\",\n                                    \"Race #\": race.race_number,\n                                    \"Runners\": race.number_of_runners,\n                                    \"Fav Odds\": next((r.odds for r in sorted(race.runners, key=lambda r: r.odds or float('inf'))), 0),\n                                    \"2nd Fav Odds\": next((r.odds for r in sorted(race.runners, key=lambda r: r.odds or float('inf'))[1:]), 0)\n                                })\n                            df = pd.DataFrame(race_list)\n                            st.dataframe(df, use_container_width=True)\n                        else:\n                            st.info(\"No imminent Checkmate opportunities found. Continuing to monitor...\")\n                    else:\n                        st.warning(\"No races were found by the pipeline in the last run.\")\n\n                except Exception as e:\n                    st.error(f\"An error occurred: {e}\")\n\n        # Wait for 60 seconds before the next run\n        time.sleep(60)\n        \n        # Rerun the script to update the dashboard\n        st.experimental_rerun()\nelse:\n    st.info(\"Monitoring is stopped. Click 'Start Monitoring' to begin.\")\n"
}