{
    "filepath": "launch_dashboard.py",
    "content": "import time\nimport asyncio\nimport pandas as pd\nimport streamlit as st\nfrom datetime import datetime, UTC, timedelta\n\nfrom src.paddock_parser.pipeline import run_pipeline\nfrom src.paddock_parser.scorer import find_checkmate_opportunities\n\nst.set_page_config(layout=\"wide\")\n\nst.title(\"Paddock Parser NG - Checkmate Alert System\")\n\nst.markdown(\n    \"\"\"\n    This dashboard continuously monitors for the \"Checkmate\" betting opportunity.\n    When a race meets the specified criteria and is near its post time, an alert\n    will be displayed.\n    \"\"\"\n)\n\n# Initialize session state\nif 'monitoring' not in st.session_state:\n    st.session_state.monitoring = False\nif 'daily_races' not in st.session_state:\n    st.session_state.daily_races = []\nif 'last_full_fetch' not in st.session_state:\n    st.session_state.last_full_fetch = None\n\n# --- Control Buttons ---\ncol1, col2 = st.columns(2)\nwith col1:\n    if st.button(\"Start Monitoring\", type=\"primary\"):\n        st.session_state.monitoring = True\n        st.session_state.last_full_fetch = None # Reset on start\n        st.experimental_rerun()\n\nwith col2:\n    if st.button(\"Stop Monitoring\"):\n        st.session_state.monitoring = False\n        st.experimental_rerun()\n\n# --- Live Monitoring Loop ---\nif st.session_state.monitoring:\n    st.success(\"Monitoring for Checkmate opportunities... The dashboard will update automatically.\")\n    \n    placeholder = st.empty()\n    \n    while st.session_state.monitoring:\n        now = datetime.now(UTC)\n        \n        # Perform a full refresh every 15 minutes\n        if (\n            st.session_state.last_full_fetch is None or \n            (now - st.session_state.last_full_fetch) > timedelta(minutes=15)\n        ):\n            with st.spinner(\"Performing full daily race refresh...\"):\n                st.session_state.daily_races = asyncio.run(\n                    run_pipeline(specific_source=\"rpb2b\")\n                )\n                st.session_state.last_full_fetch = now\n        \n        with placeholder.container():\n            st.write(f\"Last check: {now.strftime('%Y-%m-%d %H:%M:%S')} UTC\")\n\n            imminent_races = [\n                race for race in st.session_state.daily_races\n                if race.post_time and (now - timedelta(minutes=2)) < race.post_time <= (now + timedelta(minutes=10))\n            ]\n            \n            if not imminent_races:\n                st.info(\"No races are imminent. Waiting for the next check...\")\n            else:\n                imminent_race_ids = [race.race_id for race in imminent_races]\n                st.info(f\"Found {len(imminent_races)} imminent races. Fetching live odds...\")\n\n                with st.spinner(f\"Fetching details for {len(imminent_races)} races...\"):\n                    try:\n                        live_races = asyncio.run(\n                            run_pipeline(specific_source=\"rpb2b\", race_ids=imminent_race_ids)\n                        )\n                        \n                        checkmate_races = find_checkmate_opportunities(live_races)\n                        \n                        if checkmate_races:\n                            st.header(\"\ud83d\udea8 Checkmate Opportunity Found! \ud83d\udea8\")\n                            st.balloons()\n                            \n                            race_list = []\n                            for race in checkmate_races:\n                                race_list.append({\n                                    \"Track\": race.track_name,\n                                    \"Time\": race.post_time.strftime(\"%H:%M\") if race.post_time else \"N/A\",\n                                    \"MTP\": int((race.post_time - now).total_seconds() / 60) if race.post_time else \"N/A\",\n                                    \"Race #\": race.race_number,\n                                    \"Runners\": race.number_of_runners,\n                                    \"Fav Odds\": next((r.odds for r in sorted(race.runners, key=lambda r: r.odds or float('inf'))), 0),\n                                    \"2nd Fav Odds\": next((r.odds for r in sorted(race.runners, key=lambda r: r.odds or float('inf'))[1:]), 0)\n                                })\n                            df = pd.DataFrame(race_list)\n                            st.dataframe(df, use_container_width=True)\n                        else:\n                            st.info(\"No Checkmate opportunities in the imminent races.\")\n\n                    except Exception as e:\n                        st.error(f\"An error occurred: {e}\")\n\n        time.sleep(60)\n        st.experimental_rerun()\nelse:\n    st.info(\"Monitoring is stopped. Click 'Start Monitoring' to begin.\")\n"

}