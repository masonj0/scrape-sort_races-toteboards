{
    "filepath": "tests/test_dashboard.py",
    "content": "import sys\nfrom unittest.mock import patch, MagicMock\nimport pytest\n\n# This is a bit of a hack to allow importing from the root of the project\nsys.path.append('.')\n\nfrom launch_dashboard import st, asyncio, pd, datetime, timedelta, UTC\nfrom src.paddock_parser.pipeline import run_pipeline\n\n@pytest.fixture\ndef mock_streamlit():\n    \"\"\"Mocks streamlit functions.\"\"\"\n    with patch('launch_dashboard.st') as mock_st:\n        # Set up a mock for session_state\n        mock_st.session_state = MagicMock()\n        mock_st.session_state.monitoring = False\n        mock_st.session_state.daily_races = []\n        mock_st.session_state.last_full_fetch = None\n        yield mock_st\n\n@patch('tests.test_dashboard.run_pipeline')\n@patch('launch_dashboard.time.sleep')\ndef test_dashboard_monitoring_loop(mock_sleep, mock_run_pipeline, mock_streamlit):\n    \"\"\"\n    Tests the main monitoring loop of the dashboard to ensure it performs\n    a periodic full refresh.\n    \"\"\"\n    # --- Setup ---\n    # Make the loop run only once for the test\n    mock_streamlit.session_state.monitoring = True\n    \n    # Simulate the first run\n    mock_streamlit.session_state.last_full_fetch = None\n    \n    # Mock the return value of the pipeline\n    mock_run_pipeline.return_value = []\n\n    # --- Run the main part of the dashboard script ---\n    # This is tricky because the script is not in a function.\n    # We can't call it directly. We have to execute the file.\n    # For this test, we will manually call the logic inside the loop.\n    \n    # --- First Iteration (should do a full refresh) ---\n    now = datetime.now(UTC)\n    st.session_state.last_full_fetch = None\n    \n    # This is the logic from the dashboard\n    if (\n        st.session_state.last_full_fetch is None or \n        (now - st.session_state.last_full_fetch) > timedelta(minutes=15)\n    ):\n        with st.spinner(\"Performing full daily race refresh...\"):\n            st.session_state.daily_races = asyncio.run(\n                run_pipeline(specific_source=\"rpb2b\")\n            )\n            st.session_state.last_full_fetch = now\n            \n    mock_run_pipeline.assert_called_once_with(specific_source=\"rpb2b\")\n    \n    # --- Second Iteration (should NOT do a full refresh) ---\n    mock_run_pipeline.reset_mock()\n    \n    # Simulate some time passing, but less than 15 minutes\n    now = st.session_state.last_full_fetch + timedelta(minutes=5)\n    \n    if (\n        st.session_state.last_full_fetch is None or \n        (now - st.session_state.last_full_fetch) > timedelta(minutes=15)\n    ):\n        with st.spinner(\"Performing full daily race refresh...\"):\n            st.session_state.daily_races = asyncio.run(\n                run_pipeline(specific_source=\"rpb2b\")\n            )\n            st.session_state.last_full_fetch = now\n            \n    mock_run_pipeline.assert_not_called()\n    \n    # --- Third Iteration (should do a full refresh again) ---\n    mock_run_pipeline.reset_mock()\n    \n    # Simulate more time passing\n    now = st.session_state.last_full_fetch + timedelta(minutes=16)\n    \n    if (\n        st.session_state.last_full_fetch is None or \n        (now - st.session_state.last_full_fetch) > timedelta(minutes=15)\n    ):\n        with st.spinner(\"Performing full daily race refresh...\"):\n            st.session_state.daily_races = asyncio.run(\n                run_pipeline(specific_source=\"rpb2b\")\n            )\n            st.session_state.last_full_fetch = now\n            \n    mock_run_pipeline.assert_called_once_with(specific_source=\"rpb2b\")\n"
}