{
    "filepath": "./src/paddock_parser/entry_points.py",
    "content": "import asyncio\nimport subprocess\nimport sys\nfrom pathlib import Path\n\ndef run_terminal_ui():\n    \"\"\"Entry point for the terminal user interface.\"\"\"\n    # This is a bit of a hack to make sure the UI can be imported\n    # when run as a script. We add the parent directory of the package\n    # to the path.\n    sys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n    from paddock_parser.ui.terminal_ui import TerminalUI\n\n    ui = TerminalUI()\n    asyncio.run(ui.start_interactive_mode())\n\ndef run_dashboard():\n    \"\"\"Entry point for the Streamlit dashboard.\"\"\"\n    dashboard_path = Path(__file__).resolve().parents[2] / \"launch_dashboard.py\"\n    subprocess.run([\"streamlit\", \"run\", str(dashboard_path)])\n\ndef run_prediction_engine():\n    \"\"\"Entry point for the Prediction Engine.\"\"\"\n    # This path hack is needed to ensure relative imports in the engine work\n    sys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n    import anyio\n    from paddock_parser.prediction_engine import main as run_engine_main\n\n    anyio.run(run_engine_main)\n\nif __name__ == '__main__':\n    # This allows running the entry points directly for testing\n    # e.g., python -m src.paddock_parser.entry_points ui\n    if len(sys.argv) > 1:\n        if sys.argv[1] == 'ui':\n            run_terminal_ui()\n        elif sys.argv[1] == 'dashboard':\n            run_dashboard()\n        elif sys.argv[1] == 'predict':\n            run_prediction_engine()\n        else:\n            print(\"Usage: python -m src.paddock_parser.entry_points [ui|dashboard|predict]\")\n    else:\n        print(\"Usage: python -m src.paddock_parser.entry_points [ui|dashboard|predict]\")\n"
}