{
    "filepath": "./src/paddock_parser/prediction_engine.py",
    "content": "import anyio\nimport logging\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\n\nfrom .adapters.twinspires_adapter import TwinSpiresAdapter\nfrom .adapters.racingpost_adapter import RacingPostAdapter\nfrom .adapters.pointsbet_adapter import PointsBetAdapter\nfrom .database.manager import DatabaseManager\nfrom .models import NormalizedRace, Prediction\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef get_dynamic_odds_thresholds(field_size: int) -> Dict[str, float]:\n    \"\"\"Ported from the Checkmate Monitor JavaScript, this determines the odds\n    thresholds for identifying an opportunity based on field size.\"\"\"\n    if field_size <= 4: return {\"fav\": 0.5, \"secondFav\": 2.0}\n    if field_size == 5: return {\"fav\": 0.8, \"secondFav\": 3.0}\n    if field_size == 6: return {\"fav\": 1.0, \"secondFav\": 3.5}\n    return {\"fav\": 1.0, \"secondFav\": 4.0}\n\ndef find_checkmate_opportunities(races: List[NormalizedRace]) -> List[NormalizedRace]:\n    \"\"\"Ported from the Checkmate Monitor JavaScript, this filters a list of races\n    to find 'Checkmate' opportunities based on the odds of the top two favorites.\"\"\"\n    opportunities = []\n    for race in races:\n        # The JS logic only applies to Thoroughbreds. The adapters should ideally provide this,\n        # but for now, we assume they are returning relevant race types.\n        if not race.runners or not (2 <= len(race.runners) < 7):\n            continue\n\n        # Ensure all runners have odds before sorting\n        valid_runners = [r for r in race.runners if r.odds is not None]\n        if len(valid_runners) < 2:\n            continue\n\n        sorted_runners = sorted(valid_runners, key=lambda r: r.odds)\n        thresholds = get_dynamic_odds_thresholds(len(sorted_runners))\n\n        fav = sorted_runners[0]\n        second = sorted_runners[1]\n\n        if fav.odds > thresholds[\"fav\"] and second.odds > thresholds[\"secondFav\"]:\n            opportunities.append(race)\n    return opportunities\n\nclass PredictionEngine:\n    \"\"\"\n    The first engine in the \"Closed Loop\" architecture. It finds pre-race\n    \"Checkmate\" opportunities and logs them to a permanent database.\n    \"\"\"\n    def __init__(self, db_path: str = \"paddock_parser.db\"):\n        self.db_manager = DatabaseManager(db_path)\n        # Ensure tables exist before running\n        self.db_manager.create_tables()\n        self.adapters = {\n            \"TwinSpires\": TwinSpiresAdapter(),\n            \"PointsBet\": PointsBetAdapter()\n            # RacingPost is an offline adapter and cannot be used in the live waterfall.\n        }\n\n    async def run_waterfall(self) -> List[NormalizedRace]:\n        \"\"\"\n        Attempts to fetch race data from a series of adapters in a waterfall sequence.\n        It stops and returns the data from the first successful adapter.\n        \"\"\"\n        logging.info(\"Starting data acquisition waterfall...\")\n        # Order matches the \"Gold -> Silver -> Contender\" logic from the monitor\n        waterfall_order = [\"TwinSpires\", \"PointsBet\"]\n\n        for adapter_name in waterfall_order:\n            adapter = self.adapters.get(adapter_name)\n            if not adapter:\n                continue\n\n            logging.info(f\"Attempting to fetch data from {adapter_name}...\")\n            try:\n                races = await adapter.fetch()\n                if races:\n                    logging.info(f\"Successfully fetched {len(races)} races from {adapter_name}.\")\n                    # Add source information to each race\n                    for race in races:\n                        race.source = adapter_name\n                    return races\n            except Exception as e:\n                logging.error(f\"Failed to fetch data from {adapter_name}: {e}\", exc_info=True)\n\n        logging.warning(\"Waterfall complete. No data was fetched from any source.\")\n        return []\n\n    def process_and_log_opportunities(self, opportunities: List[NormalizedRace]):\n        \"\"\"\n        Processes a list of opportunity races and saves them as Prediction records\n        in the database.\n        \"\"\"\n        if not opportunities:\n            logging.info(\"No new checkmate opportunities found.\")\n            return\n\n        logging.info(f\"Found {len(opportunities)} new checkmate opportunities. Logging to database...\")\n        for opp in opportunities:\n            sorted_runners = sorted([r for r in opp.runners if r.odds is not None], key=lambda r: r.odds)\n            fav = sorted_runners[0]\n\n            # Create a more robust race_id for the database\n            race_id = f\"{opp.source}-{opp.track}-{opp.race_time.strftime('%Y%m%d')}-R{opp.race_number}\"\n\n            prediction = Prediction(\n                race_id=race_id,\n                track=opp.track,\n                race_number=opp.race_number,\n                predicted_at=datetime.now(),\n                favorite_name=fav.name,\n                favorite_odds=fav.odds,\n            )\n            self.db_manager.save_prediction(prediction)\n\n        logging.info(f\"Successfully logged {len(opportunities)} predictions.\")\n\n    async def run(self):\n        \"\"\"Main execution method for the engine.\"\"\"\n        logging.info(\"Prediction Engine run started.\")\n        races = await self.run_waterfall()\n        opportunities = find_checkmate_opportunities(races)\n        self.process_and_log_opportunities(opportunities)\n        self.db_manager.close()\n        logging.info(\"Prediction Engine run finished.\")\n\nasync def main():\n    \"\"\"Asynchronous entry point for the script.\"\"\"\n    engine = PredictionEngine()\n    await engine.run()\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n"
}