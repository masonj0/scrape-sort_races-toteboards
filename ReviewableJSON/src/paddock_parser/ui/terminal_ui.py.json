{
    "filepath": "./src/paddock_parser/ui/terminal_ui.py",
    "content": "from datetime import datetime\nfrom typing import List, Optional\n\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.progress import Progress\nfrom rich.logging import RichHandler\n\nfrom ..base import NormalizedRace\nfrom ..pipeline import run_pipeline\nfrom ..scorer import score_races\nfrom ..models import Race as ScorerRace, Runner as ScorerRunner\nfrom ..config import LOG_FILE_PATH\nfrom ..log_analyzer import analyze_log_file\n\n\ndef _convert_normalized_to_scorer_race(norm_race: NormalizedRace) -> Optional[ScorerRace]:\n    \"\"\"Converts a NormalizedRace to the ScorerRace model for use with scorer functions.\"\"\"\n    if not norm_race.post_time:\n        return None\n\n    scorer_runners = [ScorerRunner(name=r.name, odds=r.odds) for r in norm_race.runners]\n    is_handicap = norm_race.race_type and \"handicap\" in norm_race.race_type.lower()\n\n    return ScorerRace(\n        race_id=norm_race.race_id,\n        venue=norm_race.track_name,\n        race_number=norm_race.race_number,\n        race_time=norm_race.post_time.strftime(\"%H:%M\"),\n        number_of_runners=norm_race.number_of_runners,\n        is_handicap=is_handicap,\n        runners=scorer_runners,\n        # The score and scores attributes will be added by the pipeline\n    )\n\n\nclass TerminalUI:\n    \"\"\"\n    A class to handle all terminal output using the rich library.\n    \"\"\"\n    def __init__(self, console: Console = None):\n        self.console = console or Console()\n        self.progress = None\n        self.progress_task = None\n        self.log_handler = None\n\n    def display_scoring_report(self, races: List[NormalizedRace]):\n        \"\"\"\n        Displays the dynamic scoring report in a rich, formatted table.\n        NOTE: This expects races to already be sorted by the pipeline.\n        \"\"\"\n        if not races:\n            self.console.print(\"[bold yellow]No races were found to score.[/bold yellow]\")\n            return\n\n        table = Table(title=\"[bold green]Dynamic Scoring Report[/bold green]\")\n        table.add_column(\"Race Time\", style=\"cyan\")\n        table.add_column(\"Venue\", style=\"magenta\")\n        table.add_column(\"Race #\", style=\"white\")\n        table.add_column(\"Runners\", style=\"white\")\n        table.add_column(\"Handicap\", style=\"white\")\n        table.add_column(\"Fav Odds\", style=\"yellow\")\n        table.add_column(\"Contention\", style=\"yellow\")\n        table.add_column(\"Field Size\", style=\"yellow\")\n        table.add_column(\"Total Score\", style=\"bold green\")\n\n        for race in races:\n            scores = getattr(race, 'scores', {})\n            post_time_str = race.post_time.strftime(\"%H:%M\") if race.post_time else \"N/A\"\n            is_handicap_str = \"Yes\" if (race.race_type and \"handicap\" in race.race_type.lower()) else \"No\"\n\n            table.add_row(\n                post_time_str,\n                race.track_name,\n                str(race.race_number),\n                str(race.number_of_runners),\n                is_handicap_str,\n                f\"{scores.get('favorite_odds_score', 0):.2f}\",\n                f\"{scores.get('contention_score', 0):.2f}\",\n                f\"{scores.get('field_size_score', 0):.3f}\",\n                f\"{scores.get('total_score', 0):.2f}\",\n            )\n        self.console.print(table)\n\n    def display_log_analysis_report(self):\n        \"\"\"\n        Analyzes the log file and displays a summary report.\n        \"\"\"\n        self.console.print(f\"\\n[bold]Analyzing log file at:[/] [cyan]{LOG_FILE_PATH}[/cyan]\")\n        log_counts = analyze_log_file(LOG_FILE_PATH)\n\n        if not log_counts:\n            self.console.print(\"[yellow]No log data found or file could not be read.[/yellow]\")\n            return\n\n        table = Table(title=\"[bold blue]Log File Analysis[/bold blue]\")\n        table.add_column(\"Log Level\", style=\"cyan\")\n        table.add_column(\"Count\", style=\"magenta\", justify=\"right\")\n\n        for level, count in sorted(log_counts.items()):\n            table.add_row(level, str(count))\n        self.console.print(table)\n\n    def start_fetching_progress(self, num_tasks: int):\n        \"\"\"Initializes and starts a progress bar for fetching races.\"\"\"\n        self.progress = Progress(console=self.console)\n        self.progress.start()\n        self.progress_task = self.progress.add_task(\"Fetching races...\", total=num_tasks)\n\n    def update_fetching_progress(self):\n        \"\"\"Advances the fetching progress bar by one step.\"\"\"\n        if self.progress and self.progress_task is not None:\n            self.progress.update(self.progress_task, advance=1)\n\n    def stop_fetching_progress(self):\n        \"\"\"Stops the progress bar and cleans up.\"\"\"\n        if self.progress:\n            self.progress.stop()\n            self.progress = None\n            self.progress_task = None\n\n    def setup_logging(self):\n        \"\"\"Creates a RichHandler and sets it up.\"\"\"\n        self.log_handler = RichHandler(console=self.console, show_path=False)\n\n    def _display_main_menu(self):\n        \"\"\"Displays the main menu options.\"\"\"\n        self.console.print(\"\\n[bold magenta]Paddock Parser NG - Main Menu[/bold magenta]\")\n        self.console.print(\"1. Get Dynamic Scoring Report\")\n        self.console.print(\"2. View Log Analysis Report\")\n        self.console.print(\"3. Quit\")\n\n    async def start_interactive_mode(self):\n        \"\"\"Starts the main interactive loop for the UI.\"\"\"\n        while True:\n            self._display_main_menu()\n            choice = self.console.input(\"[bold]Select an option: [/bold]\")\n            if choice == '1':\n                await self._run_scoring_report()\n            elif choice == '2':\n                self.display_log_analysis_report()\n            elif choice == '3':\n                self.console.print(\"[yellow]Goodbye![/yellow]\")\n                break\n            else:\n                self.console.print(\"[bold red]Invalid option, please try again.[/bold red]\")\n\n    async def _run_scoring_report(self):\n        \"\"\"Runs the full pipeline and displays the dynamic scoring report.\"\"\"\n        with self.console.status(\"Fetching data from providers...\", spinner=\"dots\"):\n            scored_races = await run_pipeline(min_runners=0, specific_source=None)\n\n        if not scored_races:\n            self.console.print(\"[yellow]No races were found by the pipeline.[/yellow]\")\n            return\n        self.display_scoring_report(scored_races)\n"
}