{
    "filepath": "src/paddock_parser/adapters/pointsbet_adapter.py",
    "content": "#!/usr/bin/env python3\n\"\"\"\nA V3-compliant adapter for PointsBet's public racing API.\nThis is the second adapter of the V4 Polyglot Renaissance.\nLogic translated from a Ruby open-source project.\n\"\"\"\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import List, Optional, Dict, Any\n\nfrom ..base import BaseAdapterV3, NormalizedRace, NormalizedRunner\nfrom ..fetcher import get_page_content\n\nclass PointsBetAdapter(BaseAdapterV3):\n    \"\"\" An adapter for the PointsBet public API (AU). \"\"\"\n\n    SOURCE_ID = \"pointsbet\"\n    API_URL = \"https://api.au.pointsbet.com/api/v2/racing/races/today\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n\n    async def fetch(self) -> List[NormalizedRace]:\n        \"\"\" Fetches today's racing events from the PointsBet AU API. \"\"\"\n        text_content = await get_page_content(self.API_URL)\n        if not text_content:\n            return []\n\n        try:\n            json_content = json.loads(text_content)\n        except json.JSONDecodeError:\n            logging.error(\"Failed to decode JSON from PointsBet API.\")\n            return []\n\n        if 'events' not in json_content:\n            return []\n\n        return self.parse(json_content.get('events', []))\n\n    def parse(self, events: List[Dict[str, Any]]) -> List[NormalizedRace]:\n        \"\"\" Parses the JSON response from the PointsBet API. \"\"\"\n        all_races = []\n        for event in events:\n            try:\n                # We only want to process events that are actual races with runners\n                if not event.get('runners') or not event.get('meetingName'):\n                    continue\n\n                runners = []\n                for runner in event.get('runners', []):\n                    # PointsBet provides fixed odds for win, which is what we need\n                    odds = runner.get('fixedWinOdds', {}).get('price')\n                    program_number = runner.get('runnerNumber')\n                    if odds and program_number:\n                        runners.append(NormalizedRunner(\n                            name=runner.get('name'),\n                            odds=float(odds),\n                            program_number=int(program_number)\n                        ))\n\n                if runners:\n                    race_id = event.get('key')\n                    track_name = event.get('meetingName')\n                    if not race_id:\n                        # Fallback if key is not present\n                        race_number = event.get('raceNumber')\n                        race_id = f\"{track_name.replace(' ', '')}-{race_number}\"\n\n                    all_races.append(NormalizedRace(\n                        race_id=race_id,\n                        track_name=track_name,\n                        race_number=event.get('raceNumber'),\n                        post_time=datetime.fromisoformat(event.get('startTime')),\n                        number_of_runners=len(runners),\n                        runners=runners\n                    ))\n            except (KeyError, TypeError, ValueError) as e:\n                # This prevents a single malformed event from crashing the whole process\n                logging.warning(f\"Skipping a malformed event in PointsBet parse: {e}\")\n                continue\n        return all_races\n\n    def parse_races(self, html_content: str) -> List[NormalizedRace]:\n        \"\"\"Not used for API-based adapters, but required by BaseAdapterV3.\"\"\"\n        return []\n"
}