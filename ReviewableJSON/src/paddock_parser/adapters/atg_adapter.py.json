{
    "filepath": "src/paddock_parser/adapters/atg_adapter.py",
    "content": "import httpx\nimport json\nfrom datetime import datetime, timezone\nfrom typing import List, Optional, Dict, Any\n\nfrom ..base import BaseAdapterV3, NormalizedRace, NormalizedRunner\n\nclass AtgAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for the ATG GraphQL API.\n    \"\"\"\n    SOURCE_ID = \"atg\"\n    API_ENDPOINT = \"https://www.atg.se/services/v1/games/\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n\n    async def fetch(self) -> List[NormalizedRace]:\n        \"\"\"\n        Fetches data from the ATG GraphQL API.\n        \"\"\"\n        today_str = datetime.now().strftime(\"%Y-%m-%d\")\n        game_id = f\"V75_{today_str}\"\n\n        query = {\n            \"query\": \"query Game($gameId: String!) { game(id: $gameId) { id status races { id name startTime horses { id name money results { place } scratched } } } }\",\n            \"variables\": { \"gameId\": game_id }\n        }\n\n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.post(self.API_ENDPOINT, json=query, headers={\"Content-Type\": \"application/json\"})\n                response.raise_for_status()\n                return self.parse_races(await response.json())\n        except (httpx.RequestError, httpx.HTTPStatusError) as e:\n            print(f\"Error fetching data from ATG: {e}\")\n            return []\n\n    def parse_races(self, json_data: Dict[str, Any]) -> List[NormalizedRace]:\n        \"\"\"\n        Parses the JSON response from the ATG API into a list of NormalizedRace objects.\n        \"\"\"\n        races = []\n        game_data = json_data.get(\"data\", {}).get(\"game\")\n        if not game_data:\n            return races\n\n        for race_data in game_data.get(\"races\", []):\n            runners = []\n            for horse_data in race_data.get(\"horses\", []):\n                if not horse_data.get(\"scratched\"):\n                    runners.append(\n                        NormalizedRunner(\n                            name=horse_data.get(\"name\"),\n                            program_number=0, # Not available in data\n                        )\n                    )\n\n            if not runners:\n                continue\n\n            try:\n                post_time = datetime.fromisoformat(race_data.get(\"startTime\")).astimezone(timezone.utc)\n            except (ValueError, TypeError):\n                post_time = None\n\n            races.append(\n                NormalizedRace(\n                    race_id=race_data.get(\"id\"),\n                    track_name=\"ATG\", # Not available in data, using source name\n                    race_number=0, # Not available in data\n                    race_type=race_data.get(\"name\"),\n                    post_time=post_time,\n                    number_of_runners=len(runners),\n                    runners=runners,\n                )\n            )\n        return races\n"
}