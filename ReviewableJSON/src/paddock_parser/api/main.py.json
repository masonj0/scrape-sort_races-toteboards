{
    "content": "# src/paddock_parser/api/main.py\n\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, ConfigDict\n\n# The core logic of our application is in the pipeline\nfrom src.paddock_parser.pipeline import run_pipeline\n\n# Pydantic Models (Schemas) for the API response.\n# These will ensure the output is validated and serialized correctly.\n# The 'from_attributes=True' mode (via ConfigDict) allows creating these\n# models directly from our existing dataclasses (e.g., NormalizedRace).\n\nclass RunnerSchema(BaseModel):\n    \"\"\"Pydantic schema for a single runner.\"\"\"\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    program_number: int\n\n\nclass RaceSchema(BaseModel):\n    \"\"\"Pydantic schema for a single race, including a list of runners.\"\"\"\n    model_config = ConfigDict(from_attributes=True)\n\n    race_id: str\n    track_name: str\n    race_number: int\n    post_time: datetime\n    number_of_runners: int\n    runners: List[RunnerSchema]\n    score: int\n\n\n# Create the FastAPI application instance\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    \"\"\"\n    Root endpoint to confirm the API is running.\n    \"\"\"\n    return {\"message\": \"Paddock Parser API is running.\"}\n\n\n@app.get(\"/api/v1/races\", response_model=List[RaceSchema])\nasync def get_races(min_runners: Optional[int] = None, source: Optional[str] = None):\n    \"\"\"\n    Retrieves a list of races from the pipeline, optionally filtered by the\n    minimum number of runners or a specific data source.\n    \"\"\"\n    # The API exposes 'source' as the query parameter for user convenience,\n    # but the underlying pipeline function expects 'specific_source'.\n    # We perform the mapping here.\n    races = await run_pipeline(min_runners=min_runners, specific_source=source)\n    return races\n"
}
