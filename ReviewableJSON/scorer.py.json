{
    "filepath": "src/paddock_parser/scorer.py",
    "content": "import math\nfrom typing import List, Dict, Optional\n\nfrom .config import SCORER_WEIGHTS\nfrom .models import Race, Runner\n\nclass RaceScorer:\n    \"\"\"\n    Analyzes a Race to produce a score based on a weighted combination of factors.\n    The weights for each factor are drawn from config.py to allow for easy tuning.\n    \"\"\"\n    def __init__(self, weights: Optional[Dict[str, float]] = None):\n        \"\"\"Initializes the scorer with weights, falling back to the config file.\"\"\"\n        self.weights = weights if weights is not None else SCORER_WEIGHTS\n\n    def _get_sorted_runners(self, race: Race) -> List[Runner]:\n        \"\"\"Returns runners sorted by their odds, lowest first.\"\"\"\n        return sorted(race.runners, key=lambda r: r.odds or float('inf'))\n\n    def _calculate_field_size_score(self, race: Race) -> float:\n        \"\"\"\n        Calculates the field size score. A smaller field is generally considered\n        less competitive, so we reward it with a higher score (inverse relationship).\n        \"\"\"\n        if not race.number_of_runners:\n            return 0.0\n        return 1 / race.number_of_runners\n\n    def _calculate_favorite_odds_score(self, race: Race, sorted_runners: List[Runner]) -> float:\n        \"\"\"\n        Calculates the favorite's odds score. A higher-odds favorite suggests\n        a more open race, which can be a valuable signal.\n        \"\"\"\n        if not sorted_runners:\n            return 0.0\n        return sorted_runners[0].odds or 0.0\n\n    def _calculate_contention_score(self, race: Race, sorted_runners: List[Runner]) -> float:\n        \"\"\"\n        Calculates the contention score. This measures the gap between the favorite\n        and the second favorite. A large gap (low contention) is rewarded with a\n        higher score, as it suggests a more predictable race.\n        If there's only one runner, we use their odds as the score.\n        \"\"\"\n        if len(sorted_runners) < 2:\n            return self._calculate_favorite_odds_score(race, sorted_runners)\n\n        fav_odds = sorted_runners[0].odds or 0.0\n        second_fav_odds = sorted_runners[1].odds or 0.0\n        return abs(second_fav_odds - fav_odds)\n\n    def score(self, race: Race) -> Dict[str, float]:\n        \"\"\"\n        Calculates a weighted score for a race based on various factors.\n        Returns a dictionary with the total score and the individual factor scores\n        for transparency and potential UI display.\n        \"\"\"\n        if not race.runners:\n            return {\"total_score\": 0.0, \"field_size_score\": 0.0, \"favorite_odds_score\": 0.0, \"contention_score\": 0.0}\n\n        sorted_runners = self._get_sorted_runners(race)\n\n        # Calculate raw scores for each factor\n        field_size_score = self._calculate_field_size_score(race)\n        favorite_odds_score = self._calculate_favorite_odds_score(race, sorted_runners)\n        contention_score = self._calculate_contention_score(race, sorted_runners)\n\n        # Apply weights from config\n        weighted_field_size = field_size_score * self.weights.get(\"FIELD_SIZE_WEIGHT\", 0)\n        weighted_favorite_odds = favorite_odds_score * self.weights.get(\"FAVORITE_ODDS_WEIGHT\", 0)\n        weighted_contention = contention_score * self.weights.get(\"CONTENTION_WEIGHT\", 0)\n\n        # Calculate the final total score\n        total_score = weighted_field_size + weighted_favorite_odds + weighted_contention\n\n        return {\n            \"total_score\": total_score,\n            \"field_size_score\": field_size_score,\n            \"favorite_odds_score\": favorite_odds_score,\n            \"contention_score\": contention_score,\n        }\n\ndef score_races(races: List[Race]) -> List[Race]:\n    \"\"\"\n    A helper function to score a list of races and attach the scoring\n    details back to each race object.\n    \"\"\"\n    scorer = RaceScorer()\n    for race in races:\n        scores = scorer.score(race)\n        # Attach the detailed dictionary for the UI\n        setattr(race, 'scores', scores)\n        # Attach the final score for sorting and filtering\n        setattr(race, 'score', scores.get('total_score', 0.0))\n    return races\n\n\ndef _get_dynamic_odds_thresholds(field_size: int) -> Dict[str, float]:\n    \"\"\"\n    Returns the required odds thresholds for the favorite and second-favorite\n    based on the number of runners in the race.\n    \"\"\"\n    if field_size >= 7:\n        return {\"fav\": 1.0, \"second_fav\": 4.0}\n    if field_size == 6:\n        return {\"fav\": 1.0, \"second_fav\": 3.5}\n    if field_size == 5:\n        return {\"fav\": 0.8, \"second_fav\": 3.0}\n    if field_size == 4:\n        return {\"fav\": 0.5, \"second_fav\": 2.0}\n    return {\"fav\": 0.0, \"second_fav\": 0.0}  # Default for very small fields\n\n\ndef find_checkmate_opportunities(races: List[Race]) -> List[Race]:\n    \"\"\"\n    Filters a list of races to find those that meet the dynamic \"Checkmate\" criteria.\n    \"\"\"\n    checkmate_races = []\n    for race in races:\n        if not race.runners or not race.number_of_runners:\n            continue\n\n        thresholds = _get_dynamic_odds_thresholds(race.number_of_runners)\n\n        sorted_runners = sorted(race.runners, key=lambda r: r.odds or float('inf'))\n\n        if len(sorted_runners) < 2:\n            continue\n\n        favorite_odds = sorted_runners[0].odds or 0.0\n        second_favorite_odds = sorted_runners[1].odds or 0.0\n\n        if (\n            favorite_odds > thresholds[\"fav\"]\n            and second_favorite_odds > thresholds[\"second_fav\"]\n        ):\n            checkmate_races.append(race)\n\n    return checkmate_races\n"
}