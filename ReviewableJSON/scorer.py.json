{
    "filepath": "src/paddock_parser/scorer.py",
    "content": "from datetime import datetime, timedelta\nfrom typing import List\n\nfrom .base import NormalizedRace\nfrom .models import Race\n\ndef _convert_odds_to_float(odds_str: str) -> float:\n    \"\"\"Converts odds string to a float. Handles 'EVS' and fractions.\"\"\"\n    if isinstance(odds_str, str):\n        odds_str = odds_str.strip().upper()\n        if odds_str == 'EVS':\n            return 1.0\n        if '/' in odds_str:\n            try:\n                num, den = map(int, odds_str.split('/'))\n                return num / den\n            except (ValueError, ZeroDivisionError):\n                return float('inf')\n    return float('inf')\n\ndef get_high_roller_races(races: List[Race], now: datetime) -> List[Race]:\n    \"\"\"\n    Filters and scores races to find \"High Roller\" opportunities.\n    \"\"\"\n    valid_races = []\n    max_time_to_post = timedelta(minutes=25)\n\n    for race in races:\n        # 1. Time filtering\n        try:\n            race_hour, race_minute = map(int, race.race_time.split(':'))\n            race_dt = now.replace(hour=race_hour, minute=race_minute, second=0, microsecond=0)\n            if race_dt < now - timedelta(hours=1):\n                race_dt += timedelta(days=1)\n        except ValueError:\n            continue\n\n        time_to_post = race_dt - now\n        if not (timedelta(minutes=0) < time_to_post <= max_time_to_post):\n            continue\n\n        # 2. Runner count filtering (must be less than 7)\n        if not (0 < len(race.runners) < 7):\n            continue\n\n        # 3. Scoring based on favorite's odds\n        min_odds = float('inf')\n        for runner in race.runners:\n            odds = _convert_odds_to_float(runner.odds)\n            if odds < min_odds:\n                min_odds = odds\n\n        if min_odds != float('inf'):\n            # The test expects a 'high_roller_score' attribute for sorting.\n            # We add it dynamically to the model instance.\n            setattr(race, 'high_roller_score', min_odds)\n            valid_races.append(race)\n\n    # 4. Sort by the dynamically added score\n    valid_races.sort(key=lambda r: r.high_roller_score, reverse=True)\n\n    return valid_races\n\n\nclass RaceScorer:\n    \"\"\"Analyzes a NormalizedRace to produce a score based on specific criteria.\"\"\"\n    def score(self, race: NormalizedRace) -> float:\n        \"\"\"Calculates a score for a single normalized race based on the number of runners.\"\"\"\n        if not race.number_of_runners:\n            return 0.0\n        field_size = race.number_of_runners\n        if 5 <= field_size <= 7:\n            return 100.0\n        if 8 <= field_size <= 10:\n            return 80.0\n        if 3 <= field_size <= 4:\n            return 60.0\n        if 11 <= field_size <= 12:\n            return 40.0\n        return 20.0\n\n\ndef calculate_weighted_score(race: Race, weights: dict) -> float:\n    \"\"\"\n    Calculates a weighted score for a race based on various factors.\n    \"\"\"\n    if not race.runners:\n        return 0.0\n\n    # Find the favorite (lowest odds)\n    favorite_odds = float('inf')\n    for runner in race.runners:\n        odds = _convert_odds_to_float(runner.odds)\n        if odds < favorite_odds:\n            favorite_odds = odds\n\n    if favorite_odds == float('inf'):\n        favorite_odds = 0 # Or handle as an error/default case\n\n    # Calculate score components\n    field_size_component = (1 / len(race.runners)) * weights.get(\"FIELD_SIZE_WEIGHT\", 0)\n    favorite_odds_component = favorite_odds * weights.get(\"FAVORITE_ODDS_WEIGHT\", 0)\n\n    # Calculate final score\n    score = field_size_component + favorite_odds_component\n    return score\n"
}