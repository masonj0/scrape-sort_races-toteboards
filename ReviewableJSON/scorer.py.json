{
    "filepath": "src/paddock_parser/scorer.py",
    "content": "from datetime import datetime, timedelta\nfrom typing import List\n\nfrom .models import Race, Runner\n\ndef _convert_odds_to_float(odds_str: str) -> float:\n    \"\"\"Converts odds string to a float. Handles 'EVS' and fractions.\"\"\"\n    if isinstance(odds_str, str):\n        odds_str = odds_str.strip().upper()\n        if odds_str == 'EVS':\n            return 1.0\n        if '/' in odds_str:\n            try:\n                num, den = map(int, odds_str.split('/'))\n                return num / den\n            except (ValueError, ZeroDivisionError):\n                return float('inf')\n    return float('inf')\n\ndef get_high_roller_races(races: List[Race], now: datetime) -> List[Race]:\n    \"\"\"\n    Filters and scores races to find \"High Roller\" opportunities.\n    \"\"\"\n    valid_races = []\n    max_time_to_post = timedelta(minutes=25)\n\n    for race in races:\n        # 1. Time filtering\n        try:\n            race_hour, race_minute = map(int, race.race_time.split(':'))\n            race_dt = now.replace(hour=race_hour, minute=race_minute, second=0, microsecond=0)\n            if race_dt < now - timedelta(hours=1):\n                race_dt += timedelta(days=1)\n        except ValueError:\n            continue\n\n        time_to_post = race_dt - now\n        if not (timedelta(minutes=0) < time_to_post <= max_time_to_post):\n            continue\n\n        # 2. Runner count filtering (must be less than 7)\n        if not (0 < len(race.runners) < 7):\n            continue\n\n        # 3. Scoring based on favorite's odds\n        min_odds = float('inf')\n        for runner in race.runners:\n            odds = _convert_odds_to_float(runner.odds)\n            if odds < min_odds:\n                min_odds = odds\n        \n        if min_odds != float('inf'):\n            # The test expects a 'high_roller_score' attribute for sorting.\n            # We add it dynamically to the model instance.\n            setattr(race, 'high_roller_score', min_odds)\n            valid_races.append(race)\n\n    # 4. Sort by the dynamically added score\n    valid_races.sort(key=lambda r: r.high_roller_score, reverse=True)\n    \n    return valid_races\n"
}