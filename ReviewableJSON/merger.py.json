{
    "filepath": "./src/paddock_parser/merger.py",
    "content": "from typing import List\nfrom collections import defaultdict\nfrom .models import Race\n\n# Define the priority of the sources. Lower index = higher priority.\nSOURCE_PRIORITY = [\"FanDuel\", \"SkySports\", \"AtTheRaces\"]\n\ndef get_source_priority(source: str) -> int:\n    \"\"\"Returns the priority of a source, with lower numbers being better.\"\"\"\n    try:\n        return SOURCE_PRIORITY.index(source)\n    except ValueError:\n        return len(SOURCE_PRIORITY) # Lowest priority if not in the list\n\ndef smart_merge(races: List[Race]) -> List[Race]:\n    \"\"\"\n    Deduplicates and merges a list of Race objects based on race_id.\n\n    - Merges runner data, prioritizing odds from higher-priority sources.\n    - Merges top-level metadata, taking it from the highest-priority source.\n    - Tracks the provenance of the merged data in the 'sources' field.\n    \"\"\"\n    # 1. Group races by race_id\n    grouped_races = defaultdict(list)\n    for race in races:\n        grouped_races[race.race_id].append(race)\n\n    merged_races = []\n    for race_id, race_group in grouped_races.items():\n        # 2. If only one race in the group, it's unique.\n        if len(race_group) == 1:\n            unique_race = race_group[0]\n            # Initialize its provenance list\n            unique_race.sources = [unique_race.source]\n            merged_races.append(unique_race)\n            continue\n\n        # 3. If multiple races, merge them.\n        # Sort the group by source priority to find the primary record.\n        race_group.sort(key=lambda r: get_source_priority(r.source))\n\n        primary_race = race_group[0]\n\n        import logging\n        # Create the new merged race object from the primary race's metadata.\n        logging.info(f\"Primary race number for {race_id}: {primary_race.race_number}\")\n        merged_race = Race(\n            race_id=primary_race.race_id,\n            venue=primary_race.venue,\n            race_time=primary_race.race_time,\n            race_number=primary_race.race_number,\n            is_handicap=primary_race.is_handicap,\n            source=primary_race.source # The source of the primary record\n        )\n\n        # 4. Track provenance\n        merged_race.sources = sorted([r.source for r in race_group], key=get_source_priority)\n\n        # 5. Merge runners, respecting priority\n        merged_runners = {}\n        # Iterate in reverse priority order (worst to best) so that higher priority\n        # sources overwrite lower priority ones.\n        for race in sorted(race_group, key=lambda r: get_source_priority(r.source), reverse=True):\n            for runner in race.runners:\n                merged_runners[runner.name] = runner\n\n        merged_race.runners = list(merged_runners.values())\n\n        merged_races.append(merged_race)\n\n    return merged_races\n"
}