{
    "filepath": "./checkmate_web/main.py",
    "content": "# main.py\nfrom fastapi import FastAPI, HTTPException, BackgroundTasks\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import HTMLResponse\nimport asyncio\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List\nimport logging\n\nfrom engine import DataSourceOrchestrator, TrifectaAnalyzer, Settings, Race, RaceDataSchema, HorseSchema\n\napp = FastAPI(title=\"Checkmate Live Racing Analysis\")\napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n\nCACHE = {\n    \"last_update\": None, \"races\": [], \"adapter_status\": [],\n    \"analysis_results\": [], \"is_fetching\": False\n}\nsettings = Settings()\norchestrator = DataSourceOrchestrator()\nanalyzer = TrifectaAnalyzer()\n\ndef convert_race_to_schema(race: Race) -> RaceDataSchema:\n    horses = [HorseSchema(name=r.name, number=r.program_number, odds=r.odds) for r in race.runners if r.odds is not None]\n    return RaceDataSchema(id=race.race_id, track=race.track_name, raceNumber=race.race_number, postTime=race.post_time.isoformat() if race.post_time else None, horses=horses)\n\nasync def fetch_and_analyze_races():\n    if CACHE[\"is_fetching\"]: return\n    CACHE[\"is_fetching\"] = True\n    try:\n        raw_races, adapter_statuses = orchestrator.get_races()\n        CACHE[\"races\"] = raw_races\n        CACHE[\"adapter_status\"] = adapter_statuses\n\n        analysis_results = []\n        for race in raw_races:\n            race_schema = convert_race_to_schema(race)\n            # Use the single, global settings instance for analysis\n            analysis = analyzer.analyze_race(race_schema, settings)\n            analysis_results.append({\n                \"race_id\": race.race_id, \"track_name\": race.track_name, \"race_number\": race.race_number,\n                \"post_time\": race.post_time.isoformat() if race.post_time else None,\n                \"runners\": [{\"name\": r.name, \"odds\": r.odds, \"number\": r.program_number} for r in race.runners],\n                \"qualified\": analysis[\"qualified\"], \"checkmate_score\": analysis[\"checkmateScore\"],\n                \"trifecta_factors\": analysis.get(\"trifectaFactors\", {}), \"source\": getattr(race, 'source', 'unknown')\n            })\n        CACHE[\"analysis_results\"] = analysis_results\n        CACHE[\"last_update\"] = datetime.now().isoformat()\n    finally:\n        CACHE[\"is_fetching\"] = False\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    asyncio.create_task(fetch_and_analyze_races())\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def serve_frontend():\n    with open(\"static/index.html\", \"r\") as f: return HTMLResponse(content=f.read())\n\n@app.get(\"/api/status\")\nasync def get_system_status():\n    return {\n        \"status\": \"online\",\n        \"is_fetching\": CACHE[\"is_fetching\"], \"last_update\": CACHE[\"last_update\"],\n        \"races_count\": len(CACHE[\"races\"]),\n        \"qualified_count\": len([r for r in CACHE[\"analysis_results\"] if r[\"qualified\"]])\n    }\n\n@app.get(\"/api/races/all\")\nasync def get_all_races():\n    return {\"races\": CACHE[\"analysis_results\"], \"last_update\": CACHE[\"last_update\"]}\n\n@app.get(\"/api/races/qualified\")\nasync def get_qualified_races():\n    qualified = [r for r in CACHE[\"analysis_results\"] if r[\"qualified\"]]\n    return {\"qualified_races\": qualified, \"count\": len(qualified), \"last_update\": CACHE[\"last_update\"]}\n\n@app.get(\"/api/adapters/status\")\nasync def get_adapter_status():\n    return {\"adapters\": CACHE[\"adapter_status\"], \"timestamp\": datetime.now().isoformat()}\n\n@app.post(\"/api/refresh\")\nasync def trigger_refresh(background_tasks: BackgroundTasks):\n    if CACHE[\"is_fetching\"]: raise HTTPException(status_code=409, detail=\"Already fetching data\")\n    background_tasks.add_task(fetch_and_analyze_races)\n    return {\"status\": \"refresh_started\"}\n\n@app.get(\"/api/settings\")\nasync def get_settings():\n    return settings.model_dump()\n\n@app.post(\"/api/settings\")\nasync def update_settings(new_settings: Dict):\n    try:\n        for key, value in new_settings.items():\n            if hasattr(settings, key.upper()):\n                setattr(settings, key.upper(), value)\n        # After updating settings, re-analyze existing data\n        asyncio.create_task(fetch_and_analyze_races())\n        return {\"status\": \"settings_updated\", \"settings\": settings.model_dump()}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\n        \"status\": \"healthy\",\n        \"timestamp\": datetime.now().isoformat(),\n        \"adapters_count\": len(orchestrator.adapters),\n        \"last_successful_fetch\": CACHE.get(\"last_update\")\n    }"
}