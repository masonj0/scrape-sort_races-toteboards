{
    "filepath": "./attic/portable_demo_v2.py",
    "content": "import streamlit as st\nimport pandas as pd\nimport httpx\nfrom datetime import datetime, timedelta\nimport asyncio\nimport pytz\n\n# --- V3 RPB2B Adapter Logic ---\n# This section is a simplified, self-contained version of the V3 rpb2b_adapter.\n# In the real application, this would be a separate, more robust module.\n\nAPI_URL = \"https://api.beta.racingpost.com/v3/cards\"\nAPI_HEADERS = {\"X-Api-Key\": \"23pub-2WqDqDqXp2aA4aB6bC8d\"}\n\nasync def get_races_from_api(date_str: str, jurisdiction: str = \"GB\", surface: str = \"aw\", limit: int = 20):\n    \"\"\"\n    Fetches race data from the Racing Post B2B API for a specific date and jurisdiction.\n    \"\"\"\n    params = {\n        \"date\": date_str,\n        \"jurisdiction\": jurisdiction,\n        \"surface\": surface,\n        \"limit\": limit,\n        \"include\": \"odds\"  # Include odds data\n    }\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(API_URL, headers=API_HEADERS, params=params)\n            response.raise_for_status()\n            return response.json().get(\"data\", [])\n    except (httpx.RequestError, httpx.HTTPStatusError) as e:\n        st.error(f\"API Error: Failed to fetch race data. {e}\")\n        return []\n\ndef parse_races(api_data):\n    \"\"\"\n    Parses the raw API data into a more usable list of dictionaries.\n    \"\"\"\n    parsed_races = []\n    for race_data in api_data:\n        # Basic race details\n        race = {\n            \"race_id\": race_data.get(\"id\"),\n            \"track_name\": race_data.get(\"course\", {}).get(\"name\"),\n            \"race_time\": race_data.get(\"raceTime\"),\n            \"race_title\": race_data.get(\"name\"),\n            \"distance_miles_furlongs\": race_data.get(\"distance\", {}).get(\"miles_furlongs\"),\n            \"age_band\": race_data.get(\"ageBand\"),\n            \"race_class\": race_data.get(\"raceClass\"),\n            \"runners\": []\n        }\n\n        # Runner details\n        for runner_data in race_data.get(\"runners\", []):\n            runner = {\n                \"runner_id\": runner_data.get(\"id\"),\n                \"horse_name\": runner_data.get(\"name\"),\n                \"saddle_cloth_number\": runner_data.get(\"saddleClothNumber\"),\n                \"draw\": runner_data.get(\"draw\"),\n                \"jockey_name\": runner_data.get(\"jockey\", {}).get(\"name\"),\n                \"trainer_name\": runner_data.get(\"trainer\", {}).get(\"name\"),\n                \"owner_name\": runner_data.get(\"owner\", {}).get(\"name\"),\n                \"age\": runner_data.get(\"age\"),\n                \"sex\": runner_data.get(\"sex\"),\n                \"odds\": \"N/A\"\n            }\n            # Find the latest odds from the included odds data\n            if \"odds\" in race_data and race_data[\"odds\"]:\n                for odds_entry in race_data[\"odds\"]:\n                    if odds_entry.get(\"runnerId\") == runner[\"runner_id\"]:\n                        latest_odds = odds_entry.get(\"latestOdds\", [{}])[0]\n                        runner[\"odds\"] = latest_odds.get(\"decimal\", \"N/A\")\n                        break\n            race[\"runners\"].append(runner)\n\n        parsed_races.append(race)\n    return parsed_races\n\n# --- Dynamic Checkmate Scorer ---\n# This is a simplified version of the scorer.py module.\n\ndef calculate_checkmate_score(runner, race):\n    \"\"\"\n    Calculates a 'Checkmate Score' for a runner based on a set of criteria.\n    This is a simplified example. A real-world scorer would be more complex.\n    \"\"\"\n    score = 0\n    # Rule 1: High score for low saddle cloth numbers (potential bias)\n    if runner.get(\"saddle_cloth_number\") in [1, 2, 3]:\n        score += 25\n\n    # Rule 2: High score for specific jockeys (based on historical performance)\n    if runner.get(\"jockey_name\") in [\"William Buick\", \"Ryan Moore\", \"Frankie Dettori\"]:\n        score += 30\n\n    # Rule 3: Bonus for favorable draw in smaller fields\n    if len(race.get(\"runners\", [])) <= 8 and runner.get(\"draw\", 99) <= 4:\n        score += 15\n\n    # Rule 4: Bonus for competitive odds (e.g., between 3.0 and 10.0)\n    try:\n        odds = float(runner.get(\"odds\", 0))\n        if 3.0 <= odds <= 10.0:\n            score += 20\n    except (ValueError, TypeError):\n        pass # Ignore if odds are not a valid number\n\n    # Rule 5: Penalty for very young or very old horses\n    if runner.get(\"age\") not in [3, 4, 5]:\n        score -= 10\n\n    return max(0, score) # Ensure score is not negative\n\n# --- Streamlit UI ---\n\nst.set_page_config(page_title=\"Pocket Renaissance\", layout=\"wide\")\n\nst.title(\"Pocket Renaissance: The Checkmate Alert System\")\nst.write(\"\"\"\nThis is a portable demonstration of the \"Checkmate Alert System,\" a real-time tool\nfor identifying high-potential betting opportunities based on a dynamic scoring model.\n\"\"\")\n\n# --- Live Monitoring Controls ---\nst.sidebar.header(\"Live Monitoring Controls\")\nauto_refresh = st.sidebar.checkbox(\"Enable Auto-Refresh\", value=True)\nrefresh_interval = st.sidebar.slider(\"Refresh Interval (seconds)\", 5, 60, 10)\nmin_checkmate_score = st.sidebar.slider(\"Minimum Checkmate Score\", 0, 100, 50)\n\n# --- Main Application Logic ---\n\n# Use a session state to store the race data to avoid re-fetching on every interaction\nif 'race_data' not in st.session_state:\n    st.session_state['race_data'] = []\nif 'last_fetch_time' not in st.session_state:\n    st.session_state['last_fetch_time'] = datetime.min.replace(tzinfo=pytz.UTC)\n\n# Placeholder for the main race display\nplaceholder = st.empty()\n\nasync def update_race_data():\n    \"\"\"\n    Fetches the latest race data from the API and updates the session state.\n    \"\"\"\n    utc_now = datetime.now(pytz.UTC)\n    # Only fetch if it's been more than the refresh interval since the last fetch\n    if (utc_now - st.session_state['last_fetch_time']).total_seconds() > refresh_interval:\n        date_str = utc_now.strftime(\"%Y-%m-%d\")\n        api_data = await get_races_from_api(date_str)\n        if api_data:\n            st.session_state['race_data'] = parse_races(api_data)\n            st.session_state['last_fetch_time'] = utc_now\n\nasync def main():\n    \"\"\"\n    The main execution loop for the Streamlit application.\n    \"\"\"\n    while True:\n        await update_race_data()\n\n        with placeholder.container():\n            st.header(f\"Race Analysis (Last Updated: {st.session_state['last_fetch_time'].strftime('%Y-%m-%d %H:%M:%S %Z')})\")\n\n            if not st.session_state['race_data']:\n                st.warning(\"No race data available. Waiting for the next fetch...\")\n            else:\n                all_runners = []\n                for race in st.session_state['race_data']:\n                    for runner in race['runners']:\n                        score = calculate_checkmate_score(runner, race)\n                        if score >= min_checkmate_score:\n                            all_runners.append({\n                                \"Track\": race.get(\"track_name\"),\n                                \"Time\": race.get(\"race_time\"),\n                                \"Race\": race.get(\"race_title\"),\n                                \"Horse\": runner.get(\"horse_name\"),\n                                \"No.\": runner.get(\"saddle_cloth_number\"),\n                                \"Jockey\": runner.get(\"jockey_name\"),\n                                \"Trainer\": runner.get(\"trainer_name\"),\n                                \"Odds\": runner.get(\"odds\"),\n                                \"Checkmate Score\": score\n                            })\n\n                if all_runners:\n                    df = pd.DataFrame(all_runners)\n                    df = df.sort_values(by=\"Checkmate Score\", ascending=False)\n                    st.dataframe(df, use_container_width=True)\n                else:\n                    st.info(f\"No runners meet the minimum Checkmate Score of {min_checkmate_score}.\")\n\n        if not auto_refresh:\n            break\n\n        await asyncio.sleep(refresh_interval)\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except Exception as e:\n        st.error(f\"An unexpected error occurred: {e}\")\n"
}