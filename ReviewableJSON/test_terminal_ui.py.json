{"content": "\"\"\"\nTest-as-Spec for Terminal UI Module\nPath: tests/ui/test_terminal_ui.py\n\"\"\"\n\nimport pytest\nfrom unittest.mock import Mock, patch, MagicMock, call\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport logging\n\n# Assume these data structures will be imported from the project\nfrom paddock_parser.base import NormalizedRace, NormalizedRunner\n\n\nclass TestTerminalUIInitialization:\n    @patch('paddock_parser.ui.terminal_ui.Console')\n    def test_terminal_ui_can_be_initialized(self, mock_console_class):\n        from paddock_parser.ui.terminal_ui import TerminalUI\n        mock_console = Mock()\n        mock_console_class.return_value = mock_console\n        terminal_ui = TerminalUI()\n        assert terminal_ui is not None\n        mock_console_class.assert_called_once()\n        assert terminal_ui.console == mock_console\n\nclass TestDynamicRaceTable:\n    @patch('paddock_parser.ui.terminal_ui.Table')\n    @patch('paddock_parser.ui.terminal_ui.Console')\n    def test_display_races_creates_table_with_correct_headers(self, mock_console_class, mock_table_class):\n        from paddock_parser.ui.terminal_ui import TerminalUI\n        mock_table = Mock()\n        mock_table_class.return_value = mock_table\n        terminal_ui = TerminalUI(console=Mock())\n        terminal_ui.display_races([])\n        mock_table_class.assert_called_once_with(title=\"Race Information\")\n        expected_headers = [\"Track\", \"Race #\", \"Post Time\", \"Runners\", \"Score\"]\n        header_calls = mock_table.add_column.call_args_list\n        assert len(header_calls) == len(expected_headers)\n        for i, expected_header in enumerate(expected_headers):\n            assert header_calls[i] == call(expected_header, justify=\"left\")\n\n    @patch('paddock_parser.ui.terminal_ui.Table')\n    @patch('paddock_parser.ui.terminal_ui.Console')\n    def test_display_races_adds_correct_rows(self, mock_console_class, mock_table_class):\n        from paddock_parser.ui.terminal_ui import TerminalUI\n        mock_table = Mock()\n        mock_table_class.return_value = mock_table\n        terminal_ui = TerminalUI(console=Mock())\n        races = [\n            NormalizedRace(race_id=\"C1\", track_name=\"Churchill\", race_number=1, post_time=datetime(2024, 5, 4, 14, 30), number_of_runners=8, score=85),\n            NormalizedRace(race_id=\"B3\", track_name=\"Belmont\", race_number=3, post_time=datetime(2024, 5, 4, 15, 45), number_of_runners=12, score=92)\n        ]\n        terminal_ui.display_races(races)\n        assert mock_table.add_row.call_count == 2\n        row_calls = mock_table.add_row.call_args_list\n        assert call(\"Churchill\", \"1\", \"14:30\", \"8\", \"85\") in row_calls\n        assert call(\"Belmont\", \"3\", \"15:45\", \"12\", \"92\") in row_calls\n\nclass TestProgressBarFunctionality:\n    @patch('paddock_parser.ui.terminal_ui.Progress')\n    def test_progress_bar_workflow(self, mock_progress_class):\n        from paddock_parser.ui.terminal_ui import TerminalUI\n        mock_progress = Mock()\n        mock_progress_class.return_value = mock_progress\n        mock_task_id = \"task_123\"\n        mock_progress.add_task.return_value = mock_task_id\n        \n        terminal_ui = TerminalUI(console=Mock())\n        num_tasks = 5\n        \n        terminal_ui.start_fetching_progress(num_tasks)\n        mock_progress_class.assert_called_once()\n        mock_progress.start.assert_called_once()\n        mock_progress.add_task.assert_called_once_with(\"Fetching races...\", total=num_tasks)\n        \n        terminal_ui.update_fetching_progress()\n        mock_progress.update.assert_called_once_with(mock_task_id, advance=1)\n        \n        terminal_ui.stop_fetching_progress()\n        mock_progress.stop.assert_called_once()\n        assert terminal_ui.progress is None\n\nclass TestLoggingIntegration:\n    @patch('paddock_parser.ui.terminal_ui.Console')\n    def test_terminal_ui_captures_log_messages(self, mock_console_class):\n        from paddock_parser.ui.terminal_ui import TerminalUI\n        mock_console = Mock()\n        terminal_ui = TerminalUI(console=mock_console)\n        terminal_ui.setup_logging()\n        \n        logger = logging.getLogger(\"test_logger\")\n        logger.setLevel(logging.INFO) # Explicitly set the level for the test logger\n        logger.addHandler(terminal_ui.log_handler) # In a real scenario, the handler would be added to the root logger\n        \n        test_message = \"This is a test log message\"\n        logger.info(test_message)\n        \n        mock_console.print.assert_called()\n"}
