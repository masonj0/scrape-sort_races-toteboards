{
    "filepath": "src/paddock_parser/adapters/rpb2b_adapter.py",
    "content": "import asyncio\nimport json\nfrom datetime import datetime, UTC\nfrom typing import Dict, List, Optional\n\nfrom ..base import BaseAdapterV3, NormalizedRace, NormalizedRunner\nfrom ..fetcher import get_page_content\n\n\ndef _convert_odds_to_float(odds_str: Optional[str]) -> Optional[float]:\n    \"\"\"Converts fractional odds string to a float.\"\"\"\n    if not odds_str or not isinstance(odds_str, str):\n        return None\n\n    odds_str = odds_str.strip().upper()\n    if \"SP\" in odds_str:\n        return None\n\n    if \"/\" in odds_str:\n        try:\n            numerator, denominator = map(int, odds_str.split(\"/\"))\n            if denominator == 0:\n                return None\n            return (numerator / denominator) + 1.0\n        except (ValueError, ZeroDivisionError):\n            return None\n    return None\n\n\nclass Rpb2bAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for the Racing Post B2B API.\n    \"\"\"\n\n    SOURCE_ID = \"rpb2b\"\n    BASE_URL = \"https://backend-us-racecards.widget.rpb2b.com/v2\"\n\n    async def fetch(self, race_ids: Optional[List[str]] = None) -> List[NormalizedRace]:\n        \"\"\"\n        If `race_ids` are provided, fetches details for only those races.\n        Otherwise, fetches all daily races.\n        \"\"\"\n        if not race_ids:\n            today = datetime.now(UTC).strftime(\"%Y-%m-%d\")\n            index_url = f\"{self.BASE_URL}/racecards/daily/{today}\"\n            index_json_str = await get_page_content(index_url)\n            \n            if not index_json_str:\n                return []\n\n            race_list = json.loads(index_json_str)\n            \n            race_id_to_track_map = {\n                race[\"id\"]: course.get(\"name\", \"Unknown\")\n                for course in race_list\n                for race in course.get(\"races\", [])\n            }\n            race_ids = list(race_id_to_track_map.keys())\n        else:\n            # If race_ids are provided, we don't have the track map.\n            # This is a limitation of this more efficient approach.\n            # The track name will be parsed from the detail response if available,\n            # otherwise it will be \"Unknown\".\n            race_id_to_track_map = {}\n\n        tasks = [\n            get_page_content(f\"{self.BASE_URL}/racecards/{race_id}?include=odds\")\n            for race_id in race_ids\n        ]\n        race_json_pages = await asyncio.gather(*tasks, return_exceptions=True)\n\n        all_races = []\n        for html_or_exc, race_id in zip(race_json_pages, race_ids):\n            if isinstance(html_or_exc, Exception):\n                continue\n            \n            race_detail = json.loads(html_or_exc)\n            track_name = race_id_to_track_map.get(race_id, \"Unknown\")\n            \n            race = self._parse_race(race_detail, race_id, track_name)\n            if race:\n                all_races.append(race)\n\n        return all_races\n\n    def _parse_race(\n        self, race_detail: Dict, race_id: str, track_name: str\n    ) -> Optional[NormalizedRace]:\n        \"\"\"Parses the race detail JSON to extract all available data.\"\"\"\n        try:\n            runners = []\n            if race_detail.get(\"results\") and race_detail[\"results\"].get(\"result\"):\n                for runner_data in race_detail[\"results\"][\"result\"]:\n                    runner = NormalizedRunner(\n                        name=runner_data.get(\"horseId\"),\n                        odds=_convert_odds_to_float(runner_data.get(\"startingPrice\")),\n                        program_number=runner_data.get(\"draw\"),\n                    )\n                    runners.append(runner)\n\n            return NormalizedRace(\n                race_id=race_id,\n                track_name=track_name,\n                race_number=race_detail.get(\"raceNumber\"),\n                race_type=race_detail.get(\"raceType\"),\n                number_of_runners=race_detail.get(\"numberOfRunners\"),\n                runners=runners,\n            )\n        except (KeyError, TypeError):\n            return None\n\n    def parse_races(self, html_content: str) -> List[NormalizedRace]:\n        \"\"\"This adapter is for live fetching, so offline parsing is not supported.\"\"\"\n        return []\n"
}