{
    "filepath": "./src/paddock_parser/adapters/timeform_adapter.py",
    "content": "import logging\nfrom bs4 import BeautifulSoup\nfrom paddock_parser.base import BaseAdapterV3, NormalizedRace\nfrom datetime import datetime\nfrom typing import List\n\nclass TimeformAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for timeform.com.\n    \n    This adapter is a 'minimalist' implementation that parses the main racecards\n    summary page. It extracts a list of all races for the day but does not\n    currently fetch the individual detail page for each race to get runner info.\n    \"\"\"\n    SOURCE_ID = \"timeform\"\n\n    def __init__(self, config=None):\n        super().__init__(config)\n        logging.getLogger(__name__).setLevel(self.config.get('log_level', logging.INFO))\n\n    async def fetch(self) -> List[NormalizedRace]:\n        \"\"\"This is an offline adapter and should not be fetched by the pipeline.\"\"\"\n        raise NotImplementedError(\"TimeformAdapter is an offline adapter and does not support live fetching.\")\n\n    def parse_races(self, html_content: str) -> list[NormalizedRace]:\n        \"\"\"\n        Parses the HTML content of a Timeform race card index page.\n        \n        This implementation extracts the basic details for all races listed on the\n        summary page. It does not contain runner information as that requires\n        fetching individual race pages, which is not supported by the current\n        mock data.\n        \"\"\"\n        if not html_content:\n            logging.warning(\"HTML content for TimeformAdapter is empty.\")\n            return []\n\n        soup = BeautifulSoup(html_content, 'lxml')\n        races = []\n\n        meeting_blocks = soup.select(\"div.w-racecard-grid-meeting\")\n        logging.info(f\"Found {len(meeting_blocks)} meeting blocks on the page.\")\n\n        for meeting in meeting_blocks:\n            track_name_tag = meeting.select_one(\"h2\")\n            if not track_name_tag:\n                logging.warning(\"Could not find track name for a meeting block.\")\n                continue\n            \n            track_name = track_name_tag.text.strip()\n\n            race_list_items = meeting.select(\"ul.w-racecard-grid-meeting-races-compact > li\")\n            for i, race_item in enumerate(race_list_items):\n                time_tag = race_item.select_one(\"b\")\n                if not time_tag:\n                    logging.warning(f\"Could not find time for a race at {track_name}.\")\n                    continue\n                \n                race_time_str = time_tag.text.strip()\n\n                try:\n                    # Use today's date for the datetime object\n                    post_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n                except ValueError:\n                    logging.warning(f\"Could not parse time '{race_time_str}' for a race at {track_name}.\")\n                    post_time = None\n\n                # NOTE: The number of runners is not available on the summary page.\n                # A full implementation would require fetching the detail page for each race.\n                race = NormalizedRace(\n                    race_id=f\"{track_name.replace(' ', '')}-{race_time_str}\",\n                    track_name=track_name,\n                    race_number=i + 1,\n                    post_time=post_time,\n                    runners=[],\n                    number_of_runners=0\n                )\n                races.append(race)\n        \n        logging.info(f\"Successfully parsed {len(races)} races from Timeform.\")\n        return races\n"
}