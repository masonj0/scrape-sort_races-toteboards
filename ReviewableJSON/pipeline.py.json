{
    "filepath": "src/paddock_parser/pipeline.py",
    "content": "import inspect\nimport logging\nfrom typing import List, Optional\n\nfrom . import adapters\nfrom .scorer import RaceScorer\nfrom .base import BaseAdapter, BaseAdapterV3, NormalizedRace\nfrom .merger import smart_merge\nfrom .models import Race, Runner\n\n# The TerminalUI class is forward-declared using a string to avoid circular import.\nif False:\n    from .ui.terminal_ui import TerminalUI\n\ndef load_adapters(specific_source: str = None) -> List[type]:\n    \"\"\"Dynamically loads adapter classes from the adapters module.\"\"\"\n    adapter_classes = []\n    for name, obj in inspect.getmembers(adapters, inspect.isclass):\n        if issubclass(obj, (BaseAdapter, BaseAdapterV3)) and obj not in (BaseAdapter, BaseAdapterV3):\n            if specific_source and hasattr(obj, 'SOURCE_ID') and obj.SOURCE_ID != specific_source:\n                continue\n            adapter_classes.append(obj)\n    return adapter_classes\n\ndef _convert_to_model_race(norm_race: NormalizedRace, source: str) -> Race:\n    \"\"\"Converts a NormalizedRace from the base model to a Race from the app model.\"\"\"\n    return Race(\n        race_id=norm_race.race_id,\n        venue=norm_race.track_name,\n        race_time=norm_race.post_time.strftime(\"%H:%M\") if norm_race.post_time else \"\",\n        is_handicap=norm_race.race_type == \"Handicap\", # Assumption\n        source=source,\n        runners=[Runner(name=r.name, odds=str(r.odds) if r.odds else \"SP\") for r in norm_race.runners]\n    )\n\ndef _convert_to_normalized_race(model_race: Race) -> NormalizedRace:\n    \"\"\"Converts a Race from the app model back to a NormalizedRace for pipeline output.\"\"\"\n    from datetime import datetime, date\n    try:\n        post_time = datetime.combine(date.today(), datetime.strptime(model_race.race_time, \"%H:%M\").time())\n    except (ValueError, TypeError):\n        post_time = None\n\n    return NormalizedRace(\n        race_id=model_race.race_id,\n        track_name=model_race.venue,\n        race_number=0, # This data is lost in the conversion\n        post_time=post_time,\n        number_of_runners=len(model_race.runners),\n        race_type=\"Handicap\" if model_race.is_handicap else \"Unknown\",\n        # The 'sources' field from the merged race is not stored in NormalizedRace\n    )\n\nasync def run_pipeline(\n    min_runners: int, \n    specific_source: str = None, \n    ui: Optional['TerminalUI'] = None\n) -> List[NormalizedRace]:\n    \"\"\"Orchestrates the end-to-end pipeline.\"\"\"\n    logging.info(\"--- Paddock Parser NG Pipeline Start ---\")\n\n    unmerged_races = []\n    adapter_classes = load_adapters(specific_source)\n\n    if not adapter_classes:\n        logging.warning(\"No adapters found.\")\n        return []\n\n    if ui:\n        ui.start_fetching_progress(len(adapter_classes))\n\n    for adapter_class in adapter_classes:\n        adapter = adapter_class()\n        source_id = getattr(adapter, 'SOURCE_ID', 'Unknown')\n        logging.info(f\"Running adapter: {source_id}...\")\n\n        try:\n            normalized_races = []\n            if isinstance(adapter, BaseAdapterV3):\n                races = await adapter.fetch()\n                normalized_races.extend(races)\n            elif isinstance(adapter, BaseAdapter):\n                raw_data = adapter.fetch_data()\n                normalized_races = adapter.parse_data(raw_data)\n\n            if normalized_races:\n                logging.info(f\"Parsed {len(normalized_races)} races from {source_id}.\")\n                # Convert to the application's Race model for merging\n                for norm_race in normalized_races:\n                    unmerged_races.append(_convert_to_model_race(norm_race, source_id))\n            else:\n                logging.warning(f\"No races parsed for {source_id}.\")\n\n        except Exception as e:\n            logging.error(f\"Adapter {source_id} failed: {e}\", exc_info=True)\n        finally:\n            if ui:\n                ui.update_fetching_progress()\n\n    if ui:\n        ui.stop_fetching_progress()\n\n    if not unmerged_races:\n        logging.info(\"No races were successfully parsed from any source.\")\n        return []\n\n    # Merge the races\n    logging.info(f\"Merging {len(unmerged_races)} race records...\")\n    merged_model_races = smart_merge(unmerged_races)\n    logging.info(f\"Merged down to {len(merged_model_races)} unique races.\")\n\n    # Convert back to NormalizedRace for scoring and final output\n    final_normalized_races = [_convert_to_normalized_race(r) for r in merged_model_races]\n\n    if min_runners > 1:\n        final_normalized_races = [r for r in final_normalized_races if r.number_of_runners and r.number_of_runners >= min_runners]\n\n    scorer = RaceScorer()\n    for race in final_normalized_races:\n        race.score = scorer.score(race)\n\n    final_normalized_races.sort(key=lambda r: r.score or 0, reverse=True)\n\n    logging.info(\"--- Pipeline End ---\")\n    return final_normalized_races\n"
}