{
    "filepath": "portable_demo.py",
    "content": "\"\"\"\nPaddock Parser NG - Portable Checkmate Demo\n\nThis script is a self-contained demonstration of the \"Checkmate Alert System\".\nIt encapsulates the essential logic from the main application, focusing on the \nrpb2b.com API as the sole data source.\n\nRequired Dependencies:\n- streamlit\n- httpx\n\nHow to Run:\n1. Make sure you have the required dependencies installed:\n   pip install streamlit httpx\n2. Run the script from your terminal:\n   streamlit run portable_demo.py\n\"\"\"\n\nimport asyncio\nimport json\nimport time\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta, UTC\nfrom typing import Dict, List, Optional\n\nimport httpx\nimport streamlit as st\n\n# --- \"The Guardian\" (Models) ---\n\n@dataclass\nclass NormalizedRunner:\n    name: str\n    program_number: int\n    odds: Optional[float] = None\n    scratched: bool = False\n    jockey: Optional[str] = None\n    trainer: Optional[str] = None\n\n@dataclass\nclass NormalizedRace:\n    race_id: str\n    track_name: str\n    race_number: int\n    post_time: Optional[datetime] = None\n    race_type: Optional[str] = None\n    minutes_to_post: Optional[int] = None\n    number_of_runners: Optional[int] = None\n    score: Optional[float] = None\n    scores: Dict[str, float] = field(default_factory=dict)\n    runners: List[NormalizedRunner] = field(default_factory=list)\n\n# --- \"The Template\" (Adapter Logic) ---\n\nBASE_URL = \"https://backend-us-racecards.widget.rpb2b.com/v2\"\n\ndef _convert_odds_to_float(odds_str: Optional[str]) -> Optional[float]:\n    if not odds_str or not isinstance(odds_str, str):\n        return None\n    odds_str = odds_str.strip().upper()\n    if \"SP\" in odds_str:\n        return None\n    if \"/\" in odds_str:\n        try:\n            num, den = map(int, odds_str.split(\"/\"))\n            return (num / den) + 1.0 if den != 0 else None\n        except (ValueError, ZeroDivisionError):\n            return None\n    return None\n\ndef _parse_race(race_detail: Dict, race_id: str, track_name: str) -> Optional[NormalizedRace]:\n    try:\n        runners = [\n            NormalizedRunner(\n                name=runner_data.get(\"horseId\"),\n                odds=_convert_odds_to_float(runner_data.get(\"startingPrice\")),\n                program_number=runner_data.get(\"draw\"),\n            )\n            for runner_data in race_detail.get(\"results\", {}).get(\"result\", [])\n        ]\n        \n        post_time_str = race_detail.get(\"datetimeUtc\")\n        post_time = datetime.fromisoformat(post_time_str) if post_time_str else None\n\n        return NormalizedRace(\n            race_id=race_id,\n            track_name=track_name,\n            race_number=race_detail.get(\"raceNumber\"),\n            race_type=race_detail.get(\"raceType\"),\n            number_of_runners=race_detail.get(\"numberOfRunners\"),\n            post_time=post_time,\n            runners=runners,\n        )\n    except (KeyError, TypeError):\n        return None\n\nasync def fetch_rpb2b_data(race_ids: Optional[List[str]] = None) -> List[NormalizedRace]:\n    race_id_to_track_map = {}\n    if not race_ids:\n        today = datetime.now(UTC).strftime(\"%Y-%m-%d\")\n        index_url = f\"{BASE_URL}/racecards/daily/{today}\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(index_url)\n        race_list = response.json()\n        race_id_to_track_map = {\n            race[\"id\"]: course.get(\"name\", \"Unknown\")\n            for course in race_list for race in course.get(\"races\", [])\n        }\n        race_ids = list(race_id_to_track_map.keys())\n\n    async with httpx.AsyncClient() as client:\n        tasks = [client.get(f\"{BASE_URL}/racecards/{race_id}?include=odds\") for race_id in race_ids]\n        responses = await asyncio.gather(*tasks, return_exceptions=True)\n\n    all_races = []\n    for response, race_id in zip(responses, race_ids):\n        if isinstance(response, Exception):\n            continue\n        race_detail = response.json()\n        track_name = race_id_to_track_map.get(race_id, \"Unknown\")\n        race = _parse_race(race_detail, race_id, track_name)\n        if race:\n            all_races.append(race)\n    return all_races\n\n# --- \"The Brain\" (Scorer Logic) ---\n\ndef _get_dynamic_odds_thresholds(field_size: int) -> Dict[str, float]:\n    if field_size >= 7: return {\"fav\": 1.0, \"second_fav\": 4.0}\n    if field_size == 6: return {\"fav\": 1.0, \"second_fav\": 3.5}\n    if field_size == 5: return {\"fav\": 0.8, \"second_fav\": 3.0}\n    if field_size == 4: return {\"fav\": 0.5, \"second_fav\": 2.0}\n    return {\"fav\": 0.0, \"second_fav\": 0.0}\n\ndef find_checkmate_opportunities(races: List[NormalizedRace]) -> List[NormalizedRace]:\n    checkmate_races = []\n    for race in races:\n        if not race.runners or not race.number_of_runners: continue\n        thresholds = _get_dynamic_odds_thresholds(race.number_of_runners)\n        sorted_runners = sorted(race.runners, key=lambda r: r.odds or float('inf'))\n        if len(sorted_runners) < 2: continue\n        \n        fav_odds = sorted_runners[0].odds or 0.0\n        second_fav_odds = sorted_runners[1].odds or 0.0\n        \n        if fav_odds > thresholds[\"fav\"] and second_fav_odds > thresholds[\"second_fav\"]:\n            checkmate_races.append(race)\n    return checkmate_races\n\n# --- \"The Face\" (Dashboard Logic) ---\n\nst.set_page_config(layout=\"wide\")\nst.title(\"Portable Checkmate Alert System\")\n\nif 'monitoring' not in st.session_state:\n    st.session_state.monitoring = False\nif 'daily_races' not in st.session_state:\n    st.session_state.daily_races = []\nif 'last_full_fetch' not in st.session_state:\n    st.session_state.last_full_fetch = None\n\nif st.button(\"Start Monitoring\", type=\"primary\"):\n    st.session_state.monitoring = True\n    st.session_state.last_full_fetch = None\n    st.experimental_rerun()\n\nif st.button(\"Stop Monitoring\"):\n    st.session_state.monitoring = False\n    st.experimental_rerun()\n\nif st.session_state.monitoring:\n    st.success(\"Monitoring for Checkmate opportunities...\")\n    \n    placeholder = st.empty()\n    \n    while st.session_state.monitoring:\n        now = datetime.now(UTC)\n        \n        if (st.session_state.last_full_fetch is None or \n            (now - st.session_state.last_full_fetch) > timedelta(minutes=15)):\n            with st.spinner(\"Performing full daily race refresh...\"):\n                st.session_state.daily_races = asyncio.run(fetch_rpb2b_data())\n                st.session_state.last_full_fetch = now\n        \n        with placeholder.container():\n            imminent_races = [\n                r for r in st.session_state.daily_races\n                if r.post_time and (now - timedelta(minutes=1)) < r.post_time <= (now + timedelta(minutes=5))\n            ]\n            \n            if imminent_races:\n                live_races = asyncio.run(fetch_rpb2b_data(race_ids=[r.race_id for r in imminent_races]))\n                checkmate_races = find_checkmate_opportunities(live_races)\n                \n                if checkmate_races:\n                    for race in checkmate_races:\n                        st.toast(f\"\ud83d\udea8 CHECKMATE! {race.track_name} - Race {race.race_number}\")\n                        st.write(f\"\ud83d\udea8 CHECKMATE! {race.track_name} - Race {race.race_number}\")\n            \n            st.write(f\"Last check: {now.strftime('%Y-%m-%d %H:%M:%S')} UTC\")\n\n        time.sleep(60)\n        st.experimental_rerun()\nelse:\n    st.info(\"Monitoring is stopped.\")\n"
}