{
    "filepath": "ReviewableJSON/equibase.py.json",
    "content": "{\n    \"filepath\": \"./src/paddock_parser/parsers/equibase.py\",\n    \"content\": \"from bs4 import BeautifulSoup\\nfrom paddock_parser.models.race import NormalizedRace, RaceStatus\\nfrom paddock_parser.models.runner import NormalizedRunner, RunnerStatus\\nfrom paddock_parser.parsers.base import BaseAdapterV3\\nimport re\\nfrom datetime import datetime\\n\\nclass EquibaseAdapter(BaseAdapterV3):\\n    SOURCE_NAME = \\\"equibase\\\"\\n\\n    def parse_races(self, html: str) -> list[NormalizedRace]:\\n        soup = BeautifulSoup(html, \\\"html.parser\\\")\\n        races = []\\n\\n        track_id = self._parse_track_id(soup)\\n        race_date = self._parse_race_date(soup)\\n\\n        race_rows = soup.select(\\\"table#entryRaces tbody tr\\\")\\n\\n        for row in race_rows:\\n            cells = row.find_all(\\\"td\\\")\\n            if not cells:\\n                continue\\n\\n            race_number_anchor = cells[0].find(\\\"a\\\")\\n            if not race_number_anchor:\\n                continue\\n\\n            race_number = race_number_anchor.text.strip()\\n            purse = self._parse_purse(cells[1].text.strip())\\n            race_type = cells[2].text.strip()\\n            distance = cells[3].text.strip()\\n            surface = cells[4].text.strip()\\n            starters = int(cells[5].text.strip())\\n\\n            # Since we don't have runner details, we'll create placeholder runners\\n            runners = [NormalizedRunner(source_id=str(i+1), name=f\\\"Runner {i+1}\\\") for i in range(starters)]\\n\\n            races.append(\\n                NormalizedRace(\\n                    race_id=f\\\"{track_id}-{race_date}-{race_number}\\\",\\n                    source_id=f\\\"{track_id}-{race_date}-{race_number}\\\",\\n                    source_name=self.SOURCE_NAME,\\n                    name=race_type,\\n                    status=RaceStatus.OPEN,\\n                    purse=purse,\\n                    distance=distance,\\n                    surface=surface,\\n                    runners=runners,\\n                )\\n            )\\n\\n        return races\\n\\n    def _parse_track_id(self, soup):\\n        track_name_element = soup.find(\\\"h1\\\", id=\\\"pageHeader\\\")\\n        if track_name_element:\\n            track_name = track_name_element.text.strip().split(\\\" \\\")[0]\\n            # This is a hack, we need a proper track code mapping\\n            if \\\"Saratoga\\\" in track_name:\\n                return \\\"SAR\\\"\\n        return \\\"UNKNOWN\\\"\\n\\n    def _parse_race_date(self, soup):\\n        date_element = soup.find(\\\"div\\\", class_=\\\"breadcrumbs\\\")\\n        if date_element:\\n            date_anchors = date_element.find_all(\\\"a\\\")\\n            if len(date_anchors) > 2:\\n                date_text = date_anchors[2].text.strip() # \\\"August 22, 2025\\\"\\n                try:\\n                    # Attempt to parse the date string\\n                    dt_object = datetime.strptime(date_text, \\\"%B %d, %Y\\\")\\n                    return dt_object.strftime(\\\"%Y-%m-%d\\\")\\n                except (ValueError, IndexError):\\n                    pass\\n        # Fallback for mobile view\\n        mobile_header = soup.find(\\\"h1\\\", id=\\\"pageHeaderMobile\\\")\\n        if mobile_header:\\n            # \\\"Saratoga | Aug 22, 2025\\\"\\n            parts = mobile_header.text.split(\\\"|\\\")\\n            if len(parts) > 1:\\n                date_text = parts[1].strip()\\n                try:\\n                    dt_object = datetime.strptime(date_text, \\\"%b %d, %Y\\\")\\n                    return dt_object.strftime(\\\"%Y-%m-%d\\\")\\n                except ValueError:\\n                    pass\\n\\n        return \\\"UNKNOWN-DATE\\\"\\n\\n    def _parse_purse(self, purse_string: str) -> int:\\n        return int(re.sub(r'[$,]', '', purse_string))\\n\\n    def _parse_odds(self, odds_string: str) -> float:\\n        if \\\"/\\\" in odds_string:\\n            numerator, denominator = odds_string.split(\\\"/\\\")\\n            return float(numerator) / float(denominator)\\n        return float(odds_string)\\n\"\n}"
}