{
    "filepath": "src/paddock_parser/http_client.py",
    "content": "import httpx\nimport random\nimport asyncio\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n\nclass ForagerClient:\n    \"\"\"\n    A robust data fetching client with User-Agent rotation and retry mechanism.\n    \"\"\"\n    USER_AGENTS = [\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n        \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\",\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36\",\n    ]\n\n    def __init__(self, max_retries: int = 3, backoff_factor: float = 0.5):\n        self.max_retries = max_retries\n        self.backoff_factor = backoff_factor\n\n    async def fetch(self, url: str) -> str:\n        \"\"\"\n        Fetches HTML content from a URL using an async HTTP client, with a\n        randomly selected User-Agent and exponential backoff for retries.\n        \"\"\"\n        last_exception = None\n        for attempt in range(self.max_retries):\n            try:\n                async with httpx.AsyncClient() as client:\n                    headers = {\n                        \"User-Agent\": random.choice(self.USER_AGENTS)\n                    }\n                    response = await client.get(url, headers=headers, follow_redirects=True)\n                    response.raise_for_status()\n                    return response.text\n            except (httpx.RequestError, httpx.HTTPStatusError) as e:\n                last_exception = e\n                if isinstance(e, httpx.HTTPStatusError) and 400 <= e.response.status_code < 500:\n                    logging.warning(f\"Client error {e.response.status_code} for {url}. Not retrying.\")\n                    break\n\n                logging.warning(f\"Attempt {attempt + 1}/{self.max_retries} failed for {url}: {e}. Retrying...\")\n                if attempt < self.max_retries - 1:\n                    wait_time = self.backoff_factor * (2 ** attempt)\n                    await asyncio.sleep(wait_time)\n\n        logging.error(f\"All {self.max_retries} attempts failed for {url}. Last error: {last_exception}\")\n        return \"\"\n"
}