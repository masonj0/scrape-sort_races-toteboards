{
    "filepath": "./src/paddock_parser/run.py",
    "content": "import argparse\nimport logging\nimport asyncio\n\nfrom .pipeline import run_pipeline\nfrom .ui.terminal_ui import TerminalUI\nfrom . import __version__\nfrom . import config\n\ndef main():\n    \"\"\"\n    The main entry point for the Paddock Parser application.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=f\"Paddock Parser NG (Version {__version__}) - A toolkit for analyzing racecards.\"\n    )\n\n    parser.add_argument(\n        '--source',\n        type=str,\n        help='Specify a single adapter to run (e.g., \"skysports\").'\n    )\n\n    parser.add_argument(\n        '--min-runners',\n        type=int,\n        default=config.MIN_RUNNERS,\n        help='The minimum number of runners for a race to be considered interesting.'\n    )\n    \n    parser.add_argument(\n        '--time-window',\n        type=int,\n        default=config.TIME_WINDOW_MINUTES,\n        help='The time window in minutes from now to include races.'\n    )\n\n    parser.add_argument(\n        '-v', '--verbose',\n        action='store_true',\n        help='Enable verbose logging output.'\n    )\n\n    args = parser.parse_args()\n\n    log_level = logging.INFO if args.verbose else logging.WARNING\n    logging.basicConfig(level=log_level, format='%(asctime)s - %(levelname)s - %(message)s')\n\n    # The pipeline now returns the data, so we need to handle the display here.\n    ui = TerminalUI()\n    ui.setup_logging() # The UI can still manage the logging format.\n\n    races = asyncio.run(run_pipeline(\n        min_runners=args.min_runners,\n        time_window_minutes=args.time_window,\n        specific_source=args.source,\n        ui=ui # Pass the UI for progress updates\n    ))\n\n    if races:\n        ui.display_races(races)\n\nif __name__ == \"__main__\":\n    main()\n"
}