{"content": "import json\nfrom datetime import datetime\nfrom typing import List, Optional, Dict, Any\n\nfrom bs4 import BeautifulSoup\n\nfrom paddock_parser.adapters.base import BaseAdapterV3, NormalizedRace, NormalizedRunner\n\n\nclass GreyhoundRecorderAdapter(BaseAdapterV3):\n    \"\"\"\n    Adapter for greyhoundrecorder.co.uk racecards.\n    Parses data from a JSON blob embedded in the HTML.\n    \"\"\"\n    SOURCE_ID = \"greyhoundrecorder\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n\n    async def fetch(self) -> List[NormalizedRace]:\n        \"\"\"This is an offline adapter and should not be fetched by the pipeline.\"\"\"\n        raise NotImplementedError(\"GreyhoundRecorderAdapter is an offline adapter and does not support live fetching.\")\n\n    def parse_races(self, html_content: str) -> List[NormalizedRace]:\n        \"\"\"Public method to parse races, fulfilling the BaseAdapterV3 contract.\"\"\"\n        if not html_content:\n            return []\n\n        soup = BeautifulSoup(html_content, 'lxml')\n        race_data_json = self._extract_race_data_json(soup)\n        if not race_data_json:\n            return []\n        \n        return self._parse_races_from_json(race_data_json)\n\n    def _extract_race_data_json(self, soup: BeautifulSoup) -> Optional[Dict[str, Any]]:\n        \"\"\"Extracts the JSON data blob from the page's script tags.\"\"\"\n        script_tag = soup.find('script', {'id': '__NEXT_DATA__'})\n        if script_tag and script_tag.string:\n            try:\n                return json.loads(script_tag.string)\n            except json.JSONDecodeError:\n                return None\n        return None\n\n    def _parse_races_from_json(self, race_data: Dict[str, Any]) -> List[NormalizedRace]:\n        \"\"\"Parses all race information from the main JSON data object.\"\"\"\n        races = []\n        try:\n            tracks_data = race_data['props']['pageProps']['tracks']\n            for track in tracks_data:\n                track_name = track.get('name')\n                for race_info in track.get('races', []):\n                    runners = []\n                    for runner_info in race_info.get('traps', []):\n                        runner_name = runner_info.get('dog', {}).get('name')\n                        if not runner_name:  # Skip empty traps\n                            continue\n                        \n                        runners.append(\n                            NormalizedRunner(\n                                name=runner_name,\n                                program_number=runner_info.get('trap'),\n                                jockey=None,  # Not applicable for greyhounds\n                                trainer=runner_info.get('trainer', {}).get('name')\n                            )\n                        )\n                    \n                    post_time_str = race_info.get('time')\n                    post_time = self._parse_datetime(post_time_str) if post_time_str else None\n\n                    races.append(\n                        NormalizedRace(\n                            race_id=str(race_info.get('id')),\n                            track_name=track_name,\n                            race_number=race_info.get('race'),\n                            post_time=post_time,\n                            race_type=None,  # Not available in data\n                            number_of_runners=len(runners),\n                            runners=runners\n                        )\n                    )\n        except (KeyError, TypeError):\n            # Handle cases where the JSON structure is not as expected\n            return []\n            \n        return races\n\n    def _parse_datetime(self, dt_string: str) -> Optional[datetime]:\n        \"\"\"Parses a datetime string like '2023-10-21T10:31:00.000Z'.\"\"\"\n        try:\n            # Strip the 'Z' and milliseconds for compatibility\n            dt_string = dt_string.split('.')[0]\n            return datetime.fromisoformat(dt_string)\n        except (ValueError, TypeError):\n            return None\n"}
