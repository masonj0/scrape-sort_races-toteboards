{
    "filepath": "src/checkmate_v7/headless_monitor.py",
    "content": "import requests\nimport time\nimport datetime\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.panel import Panel\nfrom rich.live import Live\n\nAPI_URL = \"http://127.0.0.1:8000\" # Base URL for the API\nconsole = Console()\n\ndef get_mtp_style(minutes: float) -> str:\n    \"\"\"Returns the rich style string based on minutes to post.\"\"\"\n    if minutes < 5:\n        return \"bold red\"\n    elif 5 <= minutes <= 10:\n        return \"bold yellow\"\n    else:\n        return \"bold green\"\n\ndef generate_layout() -> Panel:\n    \"\"\"Fetches all data from the API and builds a rich layout.\"\"\"\n    \n    # In a real implementation, health and perf would be fetched.\n    # For this focused recreation, we only need the predictions.\n    try:\n        preds_data = requests.get(f\"{API_URL}/predictions/active\").json()\n    except requests.exceptions.RequestException as e:\n        return Panel(f\"Error: Cannot connect to the Checkmate API. Is it running?\\n{e}\", style=\"bold red\")\n\n    # Build Predictions Table\n    preds_table = Table(\"Race Key\", \"Status\", \"MTP\", \"Score\")\n    # Sort by MTP to show most urgent races first\n    for pred in sorted(preds_data, key=lambda p: p.get('minutes_to_post', 999)):\n        mtp = pred.get('minutes_to_post', -1)\n        score = pred.get('score_total') or 0\n        \n        style = get_mtp_style(mtp)\n        mtp_display = f\"[{style}]{mtp:.1f}[/]\"\n        \n        preds_table.add_row(\n            pred.get('race_key', 'N/A'), \n            pred.get('status', 'N/A'), \n            mtp_display,\n            f\"{score:.2f}\"\n        )\n\n    # Combine into a master layout\n    layout_str = f\"[b]Checkmate V7 Live Cockpit[/b] - Last Updated: {datetime.datetime.now().strftime('%H:%M:%S')}\\n\\n{preds_table}\"\n    return Panel(layout_str)\n\nif __name__ == \"__main__\":\n    # A check to ensure the API is running would be good here.\n    # For now, assume it is.\n    with Live(generate_layout(), screen=True, redirect_stderr=False, refresh_per_second=0.1) as live:\n        while True:\n            time.sleep(30) # Refresh interval\n            live.update(generate_layout())\n"
}