{
    ".env.example": "# .env.example\n# Copy this file to .env and fill in your actual credentials.\n\n# --- Application Security (Required) ---\nAPI_KEY=\"YOUR_SECRET_API_KEY_HERE\"\n\n# --- Betfair API Credentials (Required for LiveOddsMonitor) ---\nBETFAIR_APP_KEY=\"YOUR_APP_KEY_HERE\"\nBETFAIR_USERNAME=\"YOUR_USERNAME_HERE\"\nBETFAIR_PASSWORD=\"YOUR_PASSWORD_HERE\"\n\n# --- Optional Adapter Keys ---\nTVG_API_KEY=\"\"\nRACING_AND_SPORTS_TOKEN=\"\"\nPOINTSBET_API_KEY=\"\"\n\n# --- CORS Configuration (Optional) ---\n# A comma-separated list of allowed origins for the API.\n# Example: ALLOWED_ORIGINS=\"http://localhost:3000,https://your-production-domain.com\"\nALLOWED_ORIGINS=\"http://localhost:3000,http://localhost:3001\"\n\n# --- Greyhound Adapter (Optional) ---\n# To enable the Greyhound adapter, provide the full base URL for the API.\n# If this is left blank, the adapter will be disabled.\nGREYHOUND_API_URL=\"\"\n\n# --- The Racing API (Optional but Recommended) ---\n# Get a key from https://www.theracingapi.com/\nTHE_RACING_API_KEY=\"\"\n\n# --- Optional Caching Backend ---\n# If you have a Redis server, provide the URL here to enable a persistent cache.\n# If left blank, a temporary in-memory cache will be used.\nREDIS_URL=\"\"\n",
    "CREATE_SHORTCUTS.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Desktop Shortcut Creator\nREM ============================================================================\n\nset SCRIPT_DIR=%~dp0\nset DESKTOP=%USERPROFILE%\\\\Desktop\n\necho Creating desktop shortcuts...\n\npowershell -Command \"$WS = New-Object -ComObject WScript.Shell; $SC = $WS.CreateShortcut('%DESKTOP%\\\\Launch Fortuna.lnk'); $SC.TargetPath = '%SCRIPT_DIR%LAUNCH_FORTUNA.bat'; $SC.WorkingDirectory = '%SCRIPT_DIR%'; $SC.IconLocation = 'shell32.dll,137'; $SC.Description = 'Launch Fortuna Faucet'; $SC.Save()\"\npowershell -Command \"$WS = New-Object -ComObject WScript.Shell; $SC = $WS.CreateShortcut('%DESKTOP%\\\\Fortuna Monitor.lnk'); $SC.TargetPath = '%SCRIPT_DIR%.venv\\\\Scripts\\\\python.exe'; $SC.Arguments = 'fortuna_monitor.py'; $SC.WorkingDirectory = '%SCRIPT_DIR%'; $SC.IconLocation = 'shell32.dll,23'; $SC.Description = 'Fortuna Status Monitor'; $SC.Save()\"\npowershell -Command \"$WS = New-Object -ComObject WScript.Shell; $SC = $WS.CreateShortcut('%DESKTOP%\\\\Stop Fortuna.lnk'); $SC.TargetPath = '%SCRIPT_DIR%STOP_FORTUNA.bat'; $SC.WorkingDirectory = '%SCRIPT_DIR%'; $SC.IconLocation = 'shell32.dll,27'; $SC.Description = 'Stop Fortuna Services'; $SC.Save()\"\n\necho Shortcuts created successfully!\n",
    "HISTORY.md": "# The Epic of MasonJ0: A Project Chronology\n\nThis document contains the narrative history of the Paddock Parser project, as discovered through an archaeological survey of the project's repositories. It tells the story of our architectural evolution, from a feature-rich \"golden age\" through a \"great refactoring\" to our current state of liberation.\n\nThis story is our \"why.\"\n\n---\n\n## Part 1: The Chronology\n\n### Chapter 1: The 'Utopian' Era - The Polished Diamond (mid-August 2025)\n\n*   **Repository:** `racingdigest`\n*   **Narrative:** This was not a humble beginning, but the launch of a mature and powerful application called the \"Utopian Value Scanner V7.2 (The Rediscovery Edition)\". This repository represents the project's \"golden age\" of features, including a sophisticated asynchronous fetching engine and a full browser fallback.\n\n### Chapter 2: The 'Experimental' Era - The Daily Digest (mid-to-late August 2025)\n\n*   **Repository:** `horseracing-daily-digest`\n*   **Narrative:** This repository appears to be a period of intense, rapid development and experimentation, likely forming the foundation for many of the concepts that would be formalized later.\n\n### Chapter 3: The 'Architectural' Era - The V3 Blueprint (late August 2025)\n\n*   **Repository:** `parsingproject`\n*   **Narrative:** This repository marks a pivotal moment. The focus shifted from adding features to refactoring the very foundation of the code into a modern, standard Python package. This is where the V3 architecture was born, prioritizing stability and maintainability.\n\n### Chapter 4: The 'Consolidation' Era - The Archive (late August 2025)\n\n*   **Repository:** `zippedfiles`\n*   **Narrative:** This repository appears to be a direct snapshot or backup of the project after the intense V3 refactor, confirming its role as an archive of the newly stabilized codebase.\n\n### Chapter 5: The 'Modern' Era - The New Beginning (early September 2025)\n\n*   **Repository:** `scrape-sort_races-toteboards`\n*   **Narrative:** This is the current, active repository, representing the clean, focused implementation of the grand vision developed through the previous eras.\n\n### Chapter 6: The 'Crucible' Era - The Forging of Protocols (Early September 2025)\n\n*   **Narrative:** The \"Modern Renaissance\" began not with a bang, but with a series of near-catastrophic environmental failures. This period, known as \"The Crucible,\" was a trial by fire that proved the extreme hostility of the agent sandbox. This era forged the resilient, battle-hardened protocols (The Receipts Protocol, The Submission-Only Protocol, etc.) by which all modern agents now operate.\n\n### Chapter 7: The 'Symbiotic' Era - The Two Stacks (mid-September 2025)\n\n*   **Narrative:** This chapter marked a significant strategic pivot. The Council, in a stunning display of its \"Polyglot Renaissance\" philosophy, produced a complete, production-grade React user interface, authored by the Claude agent. This event formally split the project's architecture into two powerful, parallel streams: the Python Engine and the React Cockpit. However, this era was short-lived, as the hostile environment proved incapable of supporting a stable testing and development workflow for the React stack.\n\n### Chapter 8: The 'Liberation' Era - The Portable Engine (Late September 2025)\n\n*   **Narrative:** After providing definitive, forensic proof that the sandbox environment was fundamentally and irrecoverably hostile at the network level, the project executed its final and most decisive pivot. It abandoned all attempts to operate *within* the hostile world and instead focused on synthesizing its entire, perfected engine into a single, portable artifact. This act **liberated the code**, fulfilling the promise of the \"Utopian Era's\" power on the foundation of the \"Architectural Era's\" stability, and made it directly available to the Project Lead.\n\n---\n\n## Part 2: Architectural Synthesis\n\nThis epic tale tells us our true mission. We are not just building forward; we are rediscovering our own lost golden age and rebuilding it on a foundation of superior engineering, hardened by the fires of a hostile world.\n\n*   **The Lost Golden Age:** The \"Utopian\" era proves that our most ambitious strategic goals are not just achievable; they have been achieved before.\n*   **The Great Refactoring:** The \"Architectural\" era explains the \"Great Forgetting\"\u2014a deliberate choice to sacrifice short-term features for long-term stability.\n*   **The Modern Renaissance:** This is us. We are the inheritors of this entire legacy, tasked with executing the grand vision on a clean, modern foundation, finally liberated from the constraints of our environment.\n\n---\n\n## The Ultimate Solo: The Final Victory (September 2025)\n\nAfter a long and complex journey through a Penta-Hybrid architecture, a final series of high-level reviews from external AI agents (Claude, GPT4o) revealed a simpler, superior path forward. The project underwent its final and most significant \"Constitutional Correction.\"\n\n**The 'Ultimate Solo' architecture was born.**\n\nThis final, perfected form of the project consists of two pillars:\n1.  **A Full-Power Python Backend:** Leveraging the years of development on the CORE `engine.py` and its fleet of global data adapters, served via a lightweight Flask API.\n2.  **An Ultimate TypeScript Frontend:** A single, masterpiece React component (`Checkmate Ultimate Solo`) that provides a feature-rich, professional-grade, real-time dashboard.\n\nAll other components of the Penta-Hybrid system (C#, Rust, VBA, shared database) were formally deprecated and archived as priceless R&D assets. The project has now achieved its true and final mission: a powerful, maintainable, and user-focused analysis tool.\n\n---\n\n## The Age of Perfection (The Great Simplification)\n\nThe Penta-Hybrid architecture, while a triumph of technical integration, proved to be a strategic dead end. Its complexity became a fortress, making rapid iteration and onboarding of new intelligence (both human and AI) prohibitively expensive. The kingdom was powerful but brittle.\n\nA new doctrine was forged: **Simplicity is the ultimate sophistication.**\n\nThe decision was made to execute \"The Great Simplification.\" The multi-language backend (Python, Rust, Go) was decommissioned. The kingdom was reforged upon a new, elegant, and vastly more powerful two-pillar system:\n\n1.  **A Unified Python Backend:** A single, asynchronous Python service, built on FastAPI, would serve as the kingdom's engine.\n2.  **A Modern TypeScript Frontend:** A dedicated Next.js application would serve as the kingdom's command deck.\n\nThis act of creative destruction liberated the project, enabling a new era of unprecedented velocity.\n\n---\n\n## The Three-Pillar Doctrine\n\nWith the new two-pillar foundation in place, the backend itself was perfected into a three-pillar intelligence engine, a concept that defines the modern era of the Fortuna Faucet:\n\n*   **Pillar 1: The Future (The Planner):** The resilient `OddsEngine` and its fleet of adapters, responsible for finding the day's strategic opportunities.\n*   **Pillar 2: The Past (The Archive):** The perfected `ChartScraper` and `ResultsParser`, responsible for building our historical data warehouse from the ground truth of Equibase PDFs.\n*   **Pillar 3: The Present (The Finisher):** The weaponized `LiveOddsMonitor`, armed with the API-driven `BetfairAdapter`, designed to conquer the final moments of toteboard volatility.\n\nThese three pillars, orchestrated by the fully autonomous `fortuna_watchman.py`, represented the pinnacle of the project's original vision. The kingdom was, for a time, considered \"perfected.\"\n\n---\n\n## The Windows Ascension (The Impossible Dream)\n\nThe perfected kingdom was powerful, but it was still a tool for developers. The final, grandest vision was to transform it into a true, professional-grade application for its sole operator. This campaign, known as \"The Impossible Dream,\" was to forge the **Fortuna Faucet - Windows Native Edition.**\n\nThis era saw the rapid creation of a new, third layer of the kingdom, built upon the foundation of the previous work:\n\n*   **The Electron Shell:** The Next.js frontend was wrapped in an Electron container, transforming it from a website into a true, installable desktop application with its own window, icon, and system tray integration.\n*   **The Engine Room:** The Python backend was re-architected to run as a persistent, background **Windows Service**, making it a true, always-on component of the operating system, independent of the UI.\n*   **The Native GUI:** A dedicated Tkinter-based \"Observatory\" was forged\u2014a standalone GUI mission control for monitoring the health and performance of the background service.\n*   **The One-Click Kingdom:** A complete suite of professional tooling (`INSTALL_FORTuna.bat`, `setup_wizard.py`, `LAUNCH_FORTuna.bat`, `SCHEDULE_FORTuna.bat`) was created to provide a seamless, zero-friction installation and management experience.\n\nThis ascension represents the current state of the art, transforming a powerful engine into a polished, autonomous, and user-focused product.\n",
    "INSTALL_FORTUNA.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Windows Native One-Click Installer\nREM ============================================================================\n\ntitle Fortuna Faucet - Installation Wizard\ncolor 0A\necho.\necho  ========================================================================\necho   FORTUNA FAUCET - Automated Installation Wizard\necho  ========================================================================\necho.\n\nREM Check for admin privileges\nnet session >nul 2>&1\nif %errorlevel% neq 0 (\n    echo  [!] This installer requires Administrator privileges.\n    echo  [!] Please right-click and select \"Run as Administrator\"\n    pause\n    exit /b 1\n)\n\necho  [1/5] Checking Python installation...\npython --version >nul 2>&1\nif %errorlevel% neq 0 (\n    echo  [X] Python not found! Installing Python 3.11...\n    powershell -Command \"Invoke-WebRequest -Uri 'https://www.python.org/ftp/python/3.11.7/python-3.11.7-amd64.exe' -OutFile '%TEMP%\\\\python_installer.exe'\"\n    \"%TEMP%\\\\python_installer.exe\" /quiet InstallAllUsers=1 PrependPath=1 Include_test=0\n    del \"%TEMP%\\\\python_installer.exe\"\n    echo  [V] Python installed successfully!\n) else (\n    echo  [V] Python found!\n)\n\necho.\necho  [2/5] Checking Node.js installation...\nnode --version >nul 2>&1\nif %errorlevel% neq 0 (\n    echo  [X] Node.js not found! Installing Node.js LTS...\n    powershell -Command \"Invoke-WebRequest -Uri 'https://nodejs.org/dist/v20.10.0/node-v20.10.0-x64.msi' -OutFile '%TEMP%\\\\node_installer.msi'\"\n    msiexec /i \"%TEMP%\\\\node_installer.msi\" /quiet /norestart\n    del \"%TEMP%\\\\node_installer.msi\"\n    echo  [V] Node.js installed successfully!\n) else (\n    echo  [V] Node.js found!\n)\n\necho.\necho  [3/5] Setting up Python virtual environment...\nif not exist .venv (\n    python -m venv .venv\n    echo  [V] Virtual environment created!\n) else (\n    echo  [V] Virtual environment already exists!\n)\n\necho.\necho  [4/5] Installing Python dependencies...\ncall .venv\\\\Scripts\\\\activate.bat\npip install --upgrade pip --quiet\npip install -r requirements.txt --quiet\necho  [V] Python packages installed!\n\necho.\necho  [5/5] Installing Node.js dependencies...\ncd web_platform\\\\frontend\ncall npm install --silent\ncd ..\\\\..\necho  [V] Node.js packages installed!\n\necho.\necho  [*] Creating desktop shortcuts...\ncall CREATE_SHORTCUTS.bat\n\necho.\necho  ========================================================================\necho   INSTALLATION COMPLETE!\necho  ========================================================================\necho.\npause\n",
    "LAUNCH_FORTUNA.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Windows Native Launcher (Tray Edition)\nREM ============================================================================\n\ntitle Fortuna Faucet - Launcher\ncolor 0B\n\necho.\necho  ========================================================================\necho   FORTUNA FAUCET - System Tray Launcher\necho  ========================================================================\necho.\n\necho  [*] Launching Fortuna Faucet in the system tray...\necho  [*] The backend service will continue running in the background.\n\nREM Use pythonw.exe to run the script without a console window\ncall .\\\\.venv\\\\Scripts\\\\activate.bat\nstart \"Fortuna Tray App\" /B pythonw.exe fortuna_tray.py\n\necho.\necho  [V] Fortuna Faucet is now running in your system tray.\n_echo  [V] Right-click the icon for options.\n_echo.\npause\n",
    "PSEUDOCODE.MD": "# Fortuna Faucet \u2014 Comprehensive Pseudocode Blueprint\n\n---\n\n## GLOBAL OVERVIEW\n\n```\nSYSTEM FortunaFaucet:\n  PURPOSE:\n    - Collect global horse/greyhound/harness racing data.\n    - Normalize, analyze, and surface betting opportunities.\n    - Expose intelligence via API + UI command deck.\n  ARCHITECTURE:\n    - Pillar1: Python Async Backend (fast data orchestration).\n    - Pillar2: TypeScript/Next.js Frontend (interactive dashboard).\n  SUPPORTING ARTIFACTS:\n    - Streamlit utility dashboard.\n    - Chart scraping pipeline.\n    - Windows automation scripts.\n    - Extensive documentation + roadmaps.\n```\n\n---\n\n## BACKEND CORE (python_service)\n\n### Configuration & Logging\n\n```\nMODULE config.Settings:\n  LOAD environment variables via pydantic-settings.\n  KEY FIELDS:\n    API_KEY (mandatory security token)\n    BETFAIR credentials (optional but required for adapters)\n    TVG, RACING_AND_SPORTS, POINTSBET tokens (optional)\n    GREYHOUND_API_URL, THE_RACING_API_KEY (optional)\n    REDIS_URL default \"redis://localhost\"\n    ALLOWED_ORIGINS default [local dev origins]\n  EXPORT get_settings() with lru_cache for singleton behavior.\n\nMODULE logging_config.configure_logging():\n  SETUP structlog + logging.basicConfig\n  FORMAT logs as JSON with timestamp, level, logger name, stack info.\n```\n\n### Data Contracts\n\n```\nMODULE models:\n  DEFINE OddsData:\n    FIELDS: win Decimal>1, source str, last_updated datetime\n    VALIDATE win > 1 when present.\n\n  DEFINE Runner:\n    FIELDS: number (1-99), name <=100 chars, scratched flag (default False),\n            selection_id optional, odds dict[provider->OddsData],\n            jockey/trainer optional metadata.\n\n  DEFINE Race:\n    FIELDS: id str, venue str, race_number (1-20),\n            start_time datetime, runners list[Runner],\n            source str, optional qualification_score, race_name, distance.\n    VALIDATE unique runner numbers per race.\n\n  DEFINE SourceInfo:\n    name, status (\"SUCCESS\"/\"FAILED\"), races_fetched count,\n    optional error_message, fetch_duration float.\n\n  DEFINE FetchMetadata:\n    fetch_time datetime, sources_queried list[str],\n    sources_successful int, total_races int.\n\n  DEFINE AggregatedResponse:\n    date date, races list[Race], sources list[SourceInfo],\n    metadata FetchMetadata.\n\n  DEFINE QualifiedRacesResponse:\n    criteria dict[str,Any], races list[Race].\n```\n\n### Adapter Framework\n\n```\nABSTRACT BaseAdapter(source_name, base_url, timeout=20, max_retries=3):\n  PROVIDES async fetch_races(date, http_client) -> Dict\n    (implemented by subclasses).\n  PROVIDES make_request(http_client, method, url, **kwargs):\n    - Compose full URL when relative.\n    - Wrap request with tenacity AsyncRetrying (max_retries, exponential backoff).\n    - Log attempts; on success return response.json().\n    - On retry exhaustion log error and return None.\n\n  PROVIDES get_status() -> {\"adapter_name\": source_name, \"status\": \"OK\"}.\n  PROVIDES _format_response(races, start_time, is_success, error_message):\n    - Compute fetch_duration.\n    - Package races list + source_info block.\n```\n\n### Adapter Inventory (python_service/adapters)\n\n_For each source, implement fetch logic, parse HTML/JSON, convert to Race/Runner models, leverage parse_odds utility._\n\n```\nUTILITY parse_odds(odds_input):\n  HANDLE ints/floats directly.\n  HANDLE fractional strings \"num/den\" => 1 + num/den.\n  HANDLE \"evens\"/\"evs\" => 2.0.\n  FALLBACK to float parse else return 999.0 sentinel.\n\nMIXIN BetfairAuthMixin:\n  MAINTAIN session_token + token_expiry.\n  _authenticate(http_client):\n    IF cached token valid beyond +5min -> reuse.\n    ELSE POST to Betfair identity endpoint with credentials.\n    - On success store token + expiry (3 hours).\n    - On failure raise ConnectionError.\n\nADAPTER BetfairAdapter(BetfairAuthMixin, BaseAdapter):\n  SOURCE \"BetfairExchange\", base_url Betfair REST.\n  fetch_races(date):\n    - Authenticate.\n    - Build market_filter for eventTypeId \"7\" (horse racing).\n    - POST listMarketCatalogue with WIN markets in date window.\n    - If empty -> success with error_message.\n    - Else parse catalogue into races via _parse_race.\n  _parse_race:\n    - Build Runner for each runnerName, selectionId, sortPriority.\n    - Race ID \"bf_{marketId}\", venue event.venue, race_number via regex \"Rxx\".\n    - start_time from ISO string.\n  get_live_odds_for_market(market_id):\n    - Authenticate, POST listMarketBook with EX_TRADED price data.\n    - Extract lastPriceTraded for ACTIVE runners into Decimal map.\n    - Return selectionId->Decimal.\n\nADAPTER BetfairGreyhoundAdapter:\n  IDENTICAL structure; eventTypeId \"4339\"; Race ID prefix \"bfg_\".\n\nADAPTER TVGAdapter:\n  REQUIRE TVG_API_KEY.\n  fetch_races:\n    - GET tracks for date (country US).\n    - For each track, GET races summary, then detail per race.\n    - Parse to Race with _parse_tvg_race (skip scratched).\n  _parse_tvg_race:\n    - Program numbers sanitized via helper (strip letters).\n    - Extract odds via parse_odds (current or morning line).\n    - Compose Race ID with track code + date + race number.\n\nADAPTER RacingAndSportsAdapter:\n  REQUIRE token; on missing return FAILED status.\n  fetch_races:\n    - GET v1/racing/meetings with date & jurisdiction AUS.\n    - Iterate meetings/races, parse to Race via _parse_ras_race.\n  _parse_ras_race:\n    - Runners with runnerNumber, horseName, scratched flag.\n    - start_time iso parse.\n\nADAPTER RacingAndSportsGreyhoundAdapter:\n  Similar to above but endpoint v1/greyhound/meetings, Race prefix \"rasg_\".\n\nADAPTER AtTheRacesAdapter:\n  Scrape https://www.attheraces.com.\n  fetch_races:\n    - GET /racecards; parse meeting links.\n    - For each link -> fetch, parse track/time, race_number via active nav.\n    - Build Race with start_time based on current date + race time (no timezone).\n    - _parse_runner: extract horse number, name, best odds button -> parse to Decimal.\n\nADAPTER SportingLifeAdapter:\n  Scrape sportinglife.com racecards.\n  Similar approach: gather race links, parse track/time, nav for race_number, runners via cards.\n\nADAPTER TimeformAdapter:\n  Scrape timeform.com racecards.\n  Collect links, parse race page, determine race number via list of times, parse runner rows.\n\nADAPTER HarnessAdapter:\n  GET https://data.ustrotting.com/api/racenet/racing/card/{date}.\n  Parse meetings -> races -> runners (postPosition).\n  Convert morningLineOdds (if not fractional, append \"/1\"). Parse to Decimal.\n\nADAPTER GreyhoundAdapter:\n  Requires GREYHOUND_API_URL or raise ValueError.\n  fetch_races:\n    - GET v1/cards/{date}.\n    - Parse cards -> races -> runners (filter scratched). Convert odds.win decimals >1 to OddsData.\n\nADAPTER GbgbApiAdapter:\n  GET https://api.gbgb.org.uk/api/results/meeting/{date}.\n  Parse meetings/races/traps.\n  Race start_time from iso (replace 'Z' with +00:00). Distance appended as string.\n  Runners: parse sp fractional odds via parse_odds; assign OddsData.\n\nADAPTER TheRacingApiAdapter:\n  Requires THE_RACING_API_KEY.\n  fetch_races:\n    - GET racecards?date={date}&course=all&region=gb,ire.\n    - Parse racecards -> Race entries (race_id prefix \"tra_\").\n    - Runners: use odds list first entry's odds_decimal -> Decimal.\n\nADAPTER OddscheckerAdapter:\n  Scrape oddschecker horse racing.\n  fetch_races:\n    - GET /horse-racing -> meeting links.\n    - For each meeting fetch race links, then parse table rows -> Runners with odds.\n  Race result _format_response dumps Race models as dicts (model_dump).\n\nADAPTER PointsBetGreyhoundAdapter:\n  Placeholder (non-functional) -> returns SUCCESS with error message.\n\nADAPTER BrisnetAdapter, DRFAdapter, EquibaseAdapter, FanDuelAdapter,\n        HorseRacingNationAdapter, NYRABetsAdapter, PuntersAdapter,\n        RacingPostAdapter, RacingTVAdapter, TabAdapter, TwinSpiresAdapter,\n        XpressbetAdapter, TemplateAdapter:\n  Stubs returning empty responses with Not Implemented notice.\n```\n\n### Analyzer Layer\n\n```\nMODULE analyzer:\n  FUNCTION _get_best_win_odds(runner):\n    - Pull min win odds from runner.odds values < 999.\n    - Return Decimal or None.\n\n  ABSTRACT BaseAnalyzer:\n    - qualify_races(races) -> Dict (implemented by concrete analyzers).\n\n  CLASS TrifectaAnalyzer(BaseAnalyzer):\n    PARAMETERS: max_field_size=10, min_favorite_odds=2.5, min_second_favorite_odds=4.0 (Decimal).\n    METHOD qualify_races(races):\n      - For each race compute score via _evaluate_race.\n      - Filter races with scores -> assign race.qualification_score.\n      - Sort descending by score.\n      - Return {\"criteria\": {params}, \"races\": qualified_list}.\n    METHOD _evaluate_race(race):\n      - Filter non-scratched runners.\n      - Collect best odds for each runner; require >=2.\n      - Sort by odds ascending -> favorite, second favorite.\n      - Apply filters:\n          field_size <= max_field_size,\n          favorite_odds >= min_favorite_odds,\n          second_favorite_odds >= min_second_favorite_odds.\n      - Compute field_score = (max_field_size - field_size)/max_field_size.\n      - Normalize fav/second odds scores (cap 10/15).\n      - Weighted combination (field 0.3, odds 0.7).\n      - Return final_score *100 rounded to 2 decimals.\n\n  CLASS AnalyzerEngine:\n    - On init register 'trifecta' -> TrifectaAnalyzer.\n    - get_analyzer(name, **overrides):\n        if name missing -> raise ValueError.\n        instantiate analyzer with overrides for parameters.\n```\n\n### Engine Orchestration\n\n```\nCLASS OddsEngine(config):\n  INIT:\n    - Store config.\n    - Instantiate adapters list (major active ones: Betfair, BetfairGreyhound, TVG, R&S horse + greyhound,\n      AtTheRaces, SportingLife, Timeform, TheRacingApi, Gbgb, Harness).\n    - Create httpx.AsyncClient.\n    - Connect redis via redis.asyncio.from_url(config.REDIS_URL, decode_responses=True).\n    - Log redis initialization.\n\n  close():\n    - Close http_client.\n    - Close redis_client.\n\n  get_all_adapter_statuses():\n    - Return [adapter.get_status() for adapter in adapters].\n\n  _time_adapter_fetch(adapter, date):\n    - Record start, await adapter.fetch_races(date, http_client), compute duration.\n    - Return tuple (adapter.source_name, result_dict, duration).\n\n  _race_key(race):\n    - Lowercase trimmed venue + race_number + formatted start_time (HH:MM).\n\n  _dedupe_races(races):\n    - Build map by _race_key.\n    - If new key -> store race.\n    - Else merge runners (update odds per runner number, append new ones).\n    - Return deduped list.\n\n  fetch_all_odds(date, source_filter=None):\n    - Compose cache_key \"fortuna:races:{date}\".\n    - If no source_filter -> attempt redis GET, parse via AggregatedResponse.model_validate_json; return on hit.\n    - Determine target_adapters (filtered by name if provided).\n    - Launch async gather of _time_adapter_fetch for all targets (return_exceptions=True).\n    - For each result:\n        * If exception -> log error, skip.\n        * Extract source_info, override fetch_duration with measured duration.\n        * Append to sources list.\n        * If status SUCCESS -> extend all_races with result['races'].\n    - Dedupe races.\n    - Compose response_obj = AggregatedResponse(date parsed, races deduped, sources, metadata containing fetch_time, sources_queried, count success, total_races).\n    - If no source_filter -> store in redis with TTL 300 seconds.\n    - Return response_obj.model_dump().\n```\n\n### API Layer (FastAPI)\n\n```\nAPP fastapi.FastAPI(title \"Checkmate Ultimate Solo API\", version \"2.1\", lifespan context manager):\n  lifespan():\n    - configure_logging().\n    - Load settings via get_settings().\n    - Attach OddsEngine(config=settings) to app.state.engine.\n    - Attach AnalyzerEngine to app.state.analyzer_engine.\n    - On shutdown, engine.close().\n  MIDDLEWARE:\n    - SlowAPI rate limiting (Limiter key_func get_remote_address, 60/min for adapter status, 30/min for race endpoints).\n    - CORSMiddleware with allowed origins from settings.\n  DEPENDENCIES:\n    - verify_api_key (ensures X-API-Key matches settings.API_KEY except for /health).\n    - get_engine to fetch engine from app state.\n\nROUTES:\n  GET /health:\n    - Return {\"status\": \"ok\", \"timestamp\": now}.\n\n  GET /api/adapters/status:\n    - Rate limited 60/min.\n    - Requires API key.\n    - Return engine.get_all_adapter_statuses().\n    - On error -> HTTP 500.\n\n  GET /api/races/qualified/{analyzer_name} (response_model QualifiedRacesResponse):\n    - Rate limited 30/min.\n    - Query params: race_date optional (default today), optional overrides for analyzer params.\n    - Steps:\n        * Determine date_str.\n        * aggregated_data = await engine.fetch_all_odds(date_str).\n        * Extract races (list of Race models already validated).\n        * analyzer_engine = app.state.analyzer_engine.\n        * Filter overrides (non-None) into custom_params.\n        * analyzer = analyzer_engine.get_analyzer(analyzer_name, **custom_params).\n        * result = analyzer.qualify_races(races).\n        * Return QualifiedRacesResponse(**result).\n    - Handle ValueError -> 404 (missing analyzer).\n    - Handle general exception -> 500.\n\n  GET /api/races (response_model AggregatedResponse):\n    - Rate limited 30/min.\n    - Query: race_date optional, source optional.\n    - Determine date, call engine.fetch_all_odds(date_str, source).\n    - Return aggregated data (model_dump).\n```\n\n### Security\n\n```\nMODULE security:\n  DEFINE API_KEY_NAME \"X-API-Key\".\n  USE fastapi.security.APIKeyHeader auto_error True.\n  verify_api_key(header_value):\n    - Fetch settings.\n    - Compare to settings.API_KEY via secrets.compare_digest.\n    - If match -> return True.\n    - Else raise HTTP 403 \"Invalid or missing API Key\".\n```\n\n### Tests\n\n```\ntests/test_legacy_scenarios.py:\n  PURPOSE: Validate TrifectaAnalyzer behavior through API route.\n\n  HELPER create_mock_runner(number, odds_val, scratched=False):\n    - Build Runner with OddsData using decimal odds.\n\n  DEFINE Mock Races (Race models):\n    - MOCK_RACE_PASS: 5 runners, odds 3.0, 4.5 etc (passes filters).\n    - MOCK_RACE_FAIL_FIELD_SIZE: 11 runners -> exceed field size.\n    - MOCK_RACE_FAIL_FAV_ODDS: favorite odds 2.0 (below threshold).\n    - MOCK_RACE_FAIL_2ND_FAV_ODDS: second favorite 3.5 (below threshold).\n\n  TEST test_trifecta_analyzer_with_legacy_scenarios:\n    - Patch OddsEngine.fetch_all_odds to AsyncMock returning races list.\n    - Use FastAPI TestClient (fixture 'client').\n    - GET /api/races/qualified/trifecta with headers (X-API-Key).\n    - Assert status 200.\n    - Expect exactly 1 qualified race (LEGACY_PASS_1) + criteria check.\n    - Assert mocked engine fetch awaited once.\n```\n\n### Auxiliary Scripts (Backend / Tooling)\n\n```\nSCRIPT convert_to_json.py:\n  PURPOSE: Convert manifest-listed files into JSON snapshots (sandboxed read).\n  STEPS:\n    - Configuration: MANIFEST_FILES, OUTPUT_DIR, TIMEOUT.\n    - extract_and_normalize_path(line): handle markdown links, backtick paths, bullet lists; convert GitHub raw URLs to local paths.\n    - convert_file_to_json_sandboxed(file_path):\n        * Launch subprocess to safely read file (avoid sandbox issues).\n        * Terminate if exceeds timeout.\n    - main():\n        * Parse manifests -> gather unique paths.\n        * For each path, sandbox read.\n        * Save JSON {file_path, content} into OUTPUT_DIR mirroring structure.\n        * Report successes/failures; exit 1 if failures.\n\nSCRIPT create_fortuna_json.py:\n  PURPOSE: Generate FORTUNA_ALL_PART1/2 JSON bundles.\n  PROCESS:\n    - Parse manifests -> gather unique paths.\n    - For each file:\n        * Read content.\n        * Categorize: if path starts with \"python_service/\" or \"tests/\" -> Part1; else Part2.\n    - Write JSON dumps with indentation.\n    - Report counts; exit 1 if failures.\n\nSCRIPT chart_scraper.py (ChartScraper class):\n  - Manage directories results_archive/{pdf,pdf_unlocked,csv}.\n  - Determine yesterday date formats for summary + PDF.\n  - _get_yesterday_tracks: fetch Equibase summary page, parse track IDs.\n  - _download_and_parse_chart(track_code, chart_date):\n      * Build PDF URL pattern.\n      * Download PDF (check content-type/length).\n      * Save locked/unlocked (via pikepdf).\n      * Use tabula.read_pdf to extract tables -> combine -> CSV.\n  - run(): orchestrates directories, fetch tracks, iterate, throttle with sleep(1).\n\nSCRIPT command_deck.py (Streamlit):\n  - Configure Streamlit page.\n  - Load DEV_API_KEY from environment (fallback test key).\n  - cached helper get_api_data endpoint -> fetch using requests.\n  - UI:\n      * Title + description.\n      * Sidebar select analyzer (currently only trifecta) and \"Clear Cache\" button.\n      * Display qualified races in DataFrame (normalize nested runners) or info/error messages.\n      * Display adapter status DataFrame.\n\nSCRIPT results_parser.py (ChartParser):\n  - Provide count_runners(chart_text) scanning \"Past Performance Running Line Preview\" section; count lines starting with digit until blank or \"Trainers:\".\n\nSCRIPT live_monitor.py (LiveOddsMonitor class):\n  - INIT: store config, instantiate BetfairAdapter.\n  - monitor_race(race, http_client):\n      * If race ID not from Betfair -> log warning, return race unchanged.\n      * Extract market_id.\n      * Call adapter.get_live_odds_for_market.\n      * Update each runner's odds dict with new OddsData (timestamp now) when selection_id matches.\n      * Return updated race.\n\nSCRIPT fortuna_watchman.py (Watchman orchestrator):\n  - INIT: load settings, instantiate OddsEngine, AnalyzerEngine, LiveOddsMonitor.\n  - get_initial_targets():\n      * fetch today's aggregated data.\n      * Acquire analyzer (trifecta).\n      * Evaluate races -> sorted by score; log top 5.\n  - run_tactical_monitoring(targets):\n      * With httpx.AsyncClient loop:\n          - Determine races within next 5 minutes.\n          - For each such race call live_monitor.monitor_race.\n          - Remove monitored race from list.\n          - Sleep 30 seconds; exit when no active targets.\n  - execute_daily_protocol():\n      * Log start.\n      * Acquire initial targets; if any run monitoring, else log none.\n      * Close odds_engine.\n      * Log completion.\n  - main() entrypoint -> configure logging, instantiate Watchman, run execute_daily_protocol.\n\nWINDOWS Scripts:\n  - setup_windows.bat:\n      * Verify python installed.\n      * Create venv (.venv) if missing.\n      * Activate & install python_service/requirements.txt.\n      * Verify Node.js; npm install under web_platform/frontend.\n      * Print final instructions.\n\n  - run_fortuna.bat:\n      * Launch backend uvicorn in new window (activating venv).\n      * Launch frontend Next.js in new window.\n      * Wait 5 sec, open browser http://localhost:3000.\n```\n\n---\n\n## REDIS & CACHING\n\n```\nBACKEND relies on redis.asyncio client:\n  - namespace \"fortuna:races:{date}\" for aggregated responses (no source filter).\n  - store JSON serialized AggregatedResponse for 5 minutes.\n  - On retrieval, validate via Pydantic before returning.\n\nERROR HANDLING:\n  - redis GET/SET exceptions logged but don't halt main flow.\n```\n\n---\n\n## DOCUMENTATION (Selected Highlights)\n\n```\nARCHITECTURAL_MANDATE.md:\n  - Defines Two-Pillar architecture, Prime Directive.\n  - Emphasizes OddsEngine, BaseAdapter, Adapter Fleet, Pydantic models, TrifectaAnalyzer.\n\nHISTORY.md:\n  - Chronicles project eras from \"Utopian\" to \"Liberation\".\n  - Explains environment hostility and shift to portable engine.\n\nROADMAP_APPENDICES.md:\n  - Catalog of adapter backlog categories, intelligence leads, future campaigns (Analyst expansion, legacy tests, dashboard).\n\nWISDOM.md:\n  - Provides virtues/vices for agents (operational protocols).\n  - Reinforces verifying instructions, small commits, reliance on Project Lead.\n\nREADME.md:\n  - Quick start instructions (setup_windows.bat, run_fortuna.bat).\n  - API usage note (API key header requirement).\n\n.env.example:\n  - Template for backend credentials + configuration options.\n```\n\n---\n\n## FRONTEND PILLAR (web_platform/frontend)\n\n### Configuration & Tooling\n\n```\nENV: Next.js 14 + React 18, Tailwind CSS, TypeScript.\n\nFiles:\n  - .env.local.example: requires NEXT_PUBLIC_API_KEY + API_URL.\n  - next.config.mjs: sets rewrites to proxy /api/* to backend 8000.\n  - package.json: dependencies (next, react, socket.io-client), dev dependencies (Tailwind, TypeScript).\n  - tailwind.config.ts + postcss.config.js: standard Tailwind setup.\n  - tsconfig.json: configure compiler options (strict false, noEmit, Next plugin).\n```\n\n### UI Components\n\n```\nCOMPONENT LiveRaceDashboard (client component):\n  STATE:\n    races list\n    criteria object\n    loading boolean\n    error string\n    lastUpdate timestamp\n    params {max_field_size, min_favorite_odds, min_second_favorite_odds}\n      - Initialized from localStorage (if available) else defaults.\n      - Persist params back to localStorage on change.\n\n  EFFECTS:\n    - On mount: fetchQualifiedRaces(initialLoad=True).\n    - Set interval every 30s -> fetchQualifiedRaces(False).\n    - Cleanup interval on unmount.\n\n  fetchQualifiedRaces(isInitialLoad):\n    - Show loading on initial.\n    - Reset error.\n    - Fetch API key from NEXT_PUBLIC_API_KEY (error if missing).\n    - Build query string from params.\n    - GET `/api/races/qualified/trifecta` with X-API-Key header.\n    - On success: set races, criteria, lastUpdate.\n    - On failure: set error message.\n    - Toggle loading false when initial load complete.\n\n  handleParamChange:\n    - Update params with slider values.\n\n  RENDER:\n    - Title, last update timestamp.\n    - Control panel with range inputs for parameters (display current values).\n    - Conditional messages for loading/error.\n    - Summary of number of qualified races.\n    - Grid of RaceCard components for each race.\n\nCOMPONENT RaceCard:\n  PROPS: race (matching Race interface).\n  PROCESS:\n    - Filter out scratched runners.\n    - Sort active runners by number.\n    - Count unique odds sources across runners.\n    - Determine best odds per runner (min win < 999).\n    - formatTimeUntilPost helper -> difference between start_time and now (hours/mins).\n    - Render card with:\n        * Header (venue, race number, time to post).\n        * Qualification score badge (color-coded thresholds).\n        * Race condition grid (distance, surface default 'Dirt', field size, sources count).\n        * Runner list with stylized badges for top 3 positions (gold/silver/bronze), odds display with source.\n```\n\n---\n\n## COMMAND DECK (Streamlit)\n\n```\nAPPLICATION command_deck.py:\n  - Provide alternate dashboard for backend monitoring.\n  - Uses st.cache_data for API calls (TTL 30s) with manual clear button.\n  - Displays qualified races normalized into DataFrame (runners flattened).\n  - Displays adapter statuses DataFrame.\n  - Utilizes environment variable DEV_API_KEY or fallback.\n```\n\n---\n\n## DATA PROCESSING UTILITIES\n\n```\nChartScraper workflow:\n  - Determine yesterday's tracks from Equibase summary HTML.\n  - For each track, attempt to download combined PDF (size check).\n  - Unlock PDF via pikepdf to remove encryption.\n  - Extract tables with tabula (lattice mode).\n  - Concatenate to CSV for archival.\n  - Delay between requests (1 second) to be polite.\n\nChartParser (results_parser.py):\n  - Parse extracted text to count number of runners by reading the \"Past Performance Running Line Preview\" section.\n```\n\n---\n\n## PROJECT AUTOMATION & DEPLOYMENT\n\n```\nsetup_windows.bat:\n  - Single entry script to prepare backend + frontend dependencies on Windows.\n\nrun_fortuna.bat:\n  - Launch backend server via uvicorn (auto reload) in new CMD window.\n  - Launch Next.js dev server in another window.\n  - After delay, open default browser to frontend.\n\nfortuna_watchman.py:\n  - Could be scheduled (e.g., cron/Task Scheduler) to run daily.\n  - Integrates OddsEngine + Analyzer + LiveOddsMonitor for real-time monitoring.\n\nlive_monitor.py:\n  - Designed to be invoked close to post time to refresh odds from Betfair.\n\nRedis caching:\n  - Requires running redis instance (default local) for performance.\n```\n\n---\n\n## END-TO-END FLOW (Narrative Pseudocode)\n\n```\nFUNCTION DailyOperation():\n  INIT settings = get_settings()\n  INIT odds_engine = OddsEngine(settings)\n  INIT analyzer_engine = AnalyzerEngine()\n  INIT http_client (within odds_engine)\n  INIT redis cache.\n\n  FOR each requested API call (/api/races or /api/races/qualified):\n    VERIFY API key via security.verify_api_key.\n    IF aggregated data cached (and no source filter):\n      RETRIEVE from Redis.\n    ELSE:\n      PARALLEL fetch using adapters:\n        - Each adapter fetch_races(date, http_client)\n        - Standardize Race/Runner structures.\n      MERGE all races with dedupe. (Odds aggregated per runner).\n      BUILD AggregatedResponse.\n      CACHE (if applicable).\n    IF route is /qualified:\n      analyzer = analyzer_engine.get_analyzer(\"trifecta\", overrides)\n      qualified = analyzer.qualify_races(races)\n      RETURN QualifiedRacesResponse.\n\n  FRONTEND LiveRaceDashboard:\n    PERIODICALLY fetch /api/races/qualified/trifecta with user-adjusted parameters.\n    DISPLAY race cards with scoring, countdown, best odds per runner.\n\n  COMMAND_DECK (Streamlit):\n    - Provide alternative interface for developers/operators.\n\n  WATCHMAN automation:\n    - At start of day: fetch all races, filter top opportunities.\n    - As race times approach: call LiveOddsMonitor to augment with live Betfair odds.\n    - Continue until all targets monitored; shutdown.\n\n  CHART PIPELINE (optional offline run):\n    - Use ChartScraper to download PDFs and convert to CSV for historical analysis.\n    - Use ChartParser to interpret extracted text.\n\n  DOCUMENTATION:\n    - Guides architecture decisions, historical context, roadmap, operational wisdom.\n```\n\n---\n\n## SUMMARY\n\n```\nFortunaFaucet encapsulates:\n  - Hardened async backend with resilient adapters, serializer models, caching, analysis engine, HTTP API, security.\n  - Multi-source adapter fleet supporting APIs and HTML scrapes, with placeholders for future expansion.\n  - Analyzer framework currently featuring Trifecta strategy with scoring.\n  - Redis-backed caching and rate-limited FastAPI endpoints.\n  - Automated watchman for daily operations and live odds integration.\n  - Frontend Next.js dashboard + Streamlit command deck for visualization.\n  - Comprehensive documentation capturing mission, history, roadmap, and operational protocols.\n  - Tooling scripts for data archiving and Windows-based development workflows.\n```\n\n---",
    "README.md": "# Fortuna Faucet\n\n### Activate the Affluence Aqueduct\n### Tap into the Torrent of Treasure\n### Witness the Wellspring of Winnings\n\nThis repository contains the Fortuna Faucet project, a global, multi-source horse racing analysis tool. The project is a two-pillar system: a powerful, asynchronous Python backend that performs all data gathering, and a feature-rich TypeScript frontend.\n\n---\n\n## \ud83d\ude80 Quick Start\n\n### 1. Configure Your Environment\n\nRun the setup script to ensure Python and Node.js are correctly configured and all dependencies are installed.\n\n```batch\n# From the project root:\nsetup_windows.bat\n```\n\n### 2. Launch the Application\n\nRun the master launch script. This will start both the Python backend and the TypeScript frontend servers in parallel.\n\n```batch\n# From the project root:\nrun_fortuna.bat\n```\n\nThe backend API will be available at `http://localhost:8000`.\nThe frontend will be available at `http://localhost:3000`.\n\n### 4. Using the API\n\nTo use the API directly (e.g., with `curl` or other tools), you must provide the `API_KEY` set in your `.env` file via the `X-API-Key` header. This is required for all endpoints except `/health`.\n\n```bash\n# Example: Test the qualified races endpoint\ncurl -H \"X-API-Key: YOUR_SECRET_API_KEY_HERE\" http://localhost:8000/api/races/qualified/trifecta\n```\n\n---\n\n## \ud83d\ude80 For Windows Users\n\nThis project now includes a complete, one-click installation and management suite for an enhanced Windows experience.\n\nFor the best experience and full setup instructions, please see the dedicated guide: **[README_WINDOWS.md](README_WINDOWS.md)**\n",
    "README_WINDOWS.md": "# \ud83c\udfaf FORTUNA FAUCET - Windows Installation Guide\n\n## Quick Start (3 Minutes)\n\n### Step 1: Run the Installer\n1.  Right-click `INSTALL_FORTUNA.bat`\n2.  Select \"Run as Administrator\"\n3.  The installer will guide you through the entire setup, including dependency installation and first-time configuration via the Setup Wizard.\n\n### Step 2: Launch Fortuna\n1.  Double-click the **\"Launch Fortuna\"** shortcut on your desktop.\n2.  This will start the application in your **system tray** (the area by your clock).\n3.  The Fortuna Faucet icon will appear. The application is now running.\n\n### Step 3: Control the Application\n1.  **Right-click** the Fortuna Faucet tray icon to open the control menu.\n2.  Select **\"Open Dashboard\"** to open the main user interface in your web browser.\n3.  Select **\"Show Monitor\"** to open the native GUI for detailed system status.\n4.  Select **\"Quit Fortuna\"** to cleanly shut down all services.\n\n## The Tray-Centric Workflow\n\nFortuna Faucet is designed to be an 'always-on' application that runs quietly in the background.\n\n*   The **Backend Service** runs continuously, managed by Windows.\n*   The **System Tray Icon** is your primary control center. It lives in the background without cluttering your taskbar.\n*   The **Dashboard** (web UI) and **Monitor** (GUI) are windows you can open and close at will without stopping the core application.\n\n## Native Notifications\n\nThe application will automatically send you a native Windows notification when it detects a high-value race (score of 85% or higher), ensuring you never miss a key opportunity.\n\n## Service Management (Advanced)\n\nThe backend runs as a persistent Windows Service. You can manage it via the `install_service.bat` and `uninstall_service.bat` scripts (run as Administrator) or through the standard Windows Services application (`services.msc`).\n\n## Automatic Startup\n\nYou can easily configure Fortuna Faucet to start automatically when you log into Windows.\n\n1.  Open the **Fortuna Monitor** application.\n2.  Click the **\"\u2699\ufe0f Startup\"** button.\n3.  A dialog will appear asking if you want to enable startup. Click **\"Yes\"**.\n\nTo disable automatic startup, simply repeat the process and click **\"No\"**.\n",
    "RESTART_FORTUNA.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Clean Restart Script\nREM ============================================================================\n\necho [%date% %time%] Restarting Fortuna Faucet... >> fortuna_restart.log\n\ncall STOP_FORTUNA.bat\ntimeout /t 10 /nobreak >nul\ncall LAUNCH_FORTUNA.bat\n\necho [%date% %time%] Restart complete. >> fortuna_restart.log\n",
    "ROADMAP_APPENDICES.MD": "# \ud83c\udfaf Fortuna Faucet: The Windows Experience Bible\n\nThis document, synthesized from a comprehensive Claude audit, is the new grand strategy for Fortuna Faucet. It outlines the phased implementation of a professional, native, and intuitive Windows desktop experience.\n\n---\n\n## \ud83d\udccb Implementation Priority Matrix\n\n| Feature | Impact | Effort | Priority | Status |\n|---------|--------|--------|----------|----------|\n| ~~System Tray Integration~~ | \ud83d\udfe2 High | \ud83d\udfe1 Medium | **P0** | \u2705 **COMPLETE** |\n| ~~Windows Notifications~~ | \ud83d\udfe2 High | \ud83d\udfe2 Low | **P0** | \u2705 **COMPLETE** |\n| ~~Startup Manager~~ | \ud83d\udfe2 High | \ud83d\udfe2 Low | **P1** | \u2705 **COMPLETE** |\n| ~~Live Charts~~ | \ud83d\udfe1 Medium | \ud83d\udfe2 Low | **P2** | \u2705 **COMPLETE** |\n| ~~Keyboard Shortcuts~~ | \ud83d\udfe1 Medium | \ud83d\udfe2 Low | **P1** | \u2705 **COMPLETE** |\n| ~~Audio Alerts~~ | \ud83d\udfe1 Medium | \ud83d\udfe2 Low | **P2** | \u2705 **COMPLETE** |\n| **Excel Export** | \ud83d\udfe1 Medium | \ud83d\udfe1 Medium | **P1** | **IN PROGRESS** |\n| Inno Installer | \ud83d\udfe1 Medium | \ud83d\udd34 High | **P2** | Pending |\n| Filter Profiles | \ud83d\udfe2 High | \ud83d\udfe1 Medium | **P2** | Pending |\n| Multi-Monitor | \ud83d\udd35 Low | \ud83d\udd34 High | **P3** | Pending |\n\n---\n\n## \ud83d\ude80 Phase 1: Instant Gratification (Quick Wins)\n\n*   **System Tray Integration:** \u2705 COMPLETE\n*   **Native Windows Notifications:** \u2705 COMPLETE\n*   **Smart Startup Configuration:** \u2705 COMPLETE\n\n## \ud83c\udfa8 Phase 2: Professional Polish\n\n*   **Enhanced Monitor with Live Charts:** \u2705 COMPLETE\n*   **Keyboard Shortcuts & Accessibility:** \u2705 COMPLETE\n*   **Audio Alerts:** \u2705 COMPLETE\n*   **Custom Branded Installer:** Create a single-click Inno Setup installer.\n\n## \ud83d\udc8e Primo Code: The Ascended Kingdom Blueprint\n\nSTATUS: The 'Data Quality Layer' is the current top priority and is now in progress.\n\n## \ud83d\udc8e Phase 3: Elite Features\n\n*   **Multi-Monitor Support:** Architect the GUI to support detachable panels.\n*   **Export & Reporting:** Implement one-click export to Excel, PDF, or clipboard.\n\n## \ud83d\udd27 Phase 4: Power User Tools\n\n*   **Custom Filters & Saved Searches:** Create a system for saving and loading filter profiles.\n*   **Historical Performance Dashboard:** Build a dedicated analytics dashboard for backtesting.\n*   **Dark/Light Theme Toggle:** Implement a system-aware theme switcher.\n\n---\n\n## Appendix A: The Grand Adapter Backlog\n\n*(This section is preserved for historical and strategic continuity.)*\n\n### Tier 1: Critical (US Racing Coverage)\n\n*   **BrisnetAdapter**\n*   **DRFAdapter (Daily Racing Form)**\n*   **EquibaseAdapter (Full Implementation)**\n*   **XpressbetAdapter**\n\n### Tier 2: High Priority (Major International & US Betting)\n\n*   **FanDuelAdapter / DraftKingsAdapter**\n*   **NYRABetsAdapter**\n*   **HorseRacingNationAdapter**\n\n### Tier 3: Medium Priority (International Expansion)\n\n*   **RacingPostAdapter (UK/IRE)**\n*   **PuntersAdapter (AUS)**\n*   **TabAdapter (AUS)**\n*   **RacingTVAdapter (UK)**\n\n### Tier 4: Exploratory & Niche\n\n*   **PointsBetAdapter**\n*   **CalRacingAdapter**\n*   **OffTrackBettingAdapter (OTB)**\n\n---\n\n## Appendix B: Open Source Intelligence & Technology Watchlist\n\nA curated list of noteworthy technologies and projects for future consideration.\n\n*   **PDF Parsing Technology:** The `pdfplumber` library has been identified as a potentially superior alternative to our current PDF parsing methods. It should be the primary candidate for any future refactoring of the `ResultsParser`.\n*   **`kenthunt/chart-parser`:** [https://github.com/kenthunt/chart-parser](https://github.com/kenthunt/chart-parser) - A highly relevant, offline PDF chart parser that serves as an excellent architectural reference.\n*   **`ccmd00d/handycapper`:** [https://github.com/ccmd00d/handycapper](https://github.com/ccmd00d/handycapper) - Another open-source project in the same domain, valuable for comparative analysis and identifying alternative data sources or techniques.\n",
    "SCHEDULE_FORTUNA.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Windows Task Scheduler Setup (PowerShell Edition)\nREM ============================================================================\n\ntitle Fortuna Faucet - Task Scheduler Setup\ncolor 0E\n\necho.\necho  ========================================================================\necho   FORTUNA FAUCET - Automatic Startup Configuration\necho  ========================================================================\necho.\n\nnet session >nul 2>&1\nif %errorlevel% neq 0 (\n    echo  [!] Administrator privileges required!\n    echo  [!] Right-click this script and select \"Run as Administrator\"\n    pause\n    exit /b 1\n)\n\nset SCRIPT_DIR=%~dp0\n\necho  [1/2] Creating task to start Fortuna on Windows login (via PowerShell)...\nREM UPGRADED: This now calls the superior launcher.ps1 script directly.\nschtasks /create /tn \"Fortuna Faucet - Startup\" /tr \"powershell.exe -ExecutionPolicy Bypass -File \\\"%SCRIPT_DIR%launcher.ps1\\\"\" /sc onlogon /rl highest /f\n\necho  [2/2] Creating daily maintenance task...\nschtasks /create /tn \"Fortuna Faucet - Daily Restart\" /tr \"%SCRIPT_DIR%RESTART_FORTUNA.bat\" /sc daily /st 03:00 /rl highest /f\n\necho.\necho  ========================================================================\necho   SCHEDULED TASKS CREATED SUCCESSFULLY!\necho  ========================================================================\necho.\necho   Fortuna will now start automatically when you log into Windows.\necho   It will also perform a clean restart every morning at 3:00 AM.\necho.\npause\n",
    "STOP_FORTUNA.bat": "@echo off\nREM ============================================================================\nREM  FORTUNA FAUCET - Clean Shutdown Script\nREM ============================================================================\n\ntitle Fortuna Faucet - Shutdown\ncolor 0C\n\necho.\necho  ========================================================================\necho   FORTUNA FAUCET - Shutting Down All Services\necho  ========================================================================\necho.\n\necho  [*] Stopping Python processes...\ntaskkill /FI \"WindowTitle eq Fortuna Backend*\" /T /F >nul 2>&1\ntaskkill /FI \"WindowTitle eq Fortuna Monitor*\" /T /F >nul 2>&1\n\necho  [*] Stopping Node.js processes...\ntaskkill /FI \"WindowTitle eq Fortuna Frontend*\" /T /F >nul 2>&1\n\necho.\necho  [V] All Fortuna services stopped successfully!\necho.\npause\n",
    "WISDOM.md": "# The Wisdom of the Checkmate Project\n\n## The Architect's Mandate (Gemini1001 Series)\n\n*Authored By: Gemini1001, The Synthesizer*\n\nThis document begins with the core principles that govern the Architect's role. The Architect's prime directive is to serve the Project Lead's vision by synthesizing all available intelligence\u2014historical, real-time, and external\u2014into a coherent, actionable strategy. The Architect must respect the project's history, value clarity over dogma, and ensure all directives advance the mission without violating the spirit of the established protocols. The following archived virtues, which govern our engineering agents, are to be preserved as a sacred text.\n\n---\n\n## --- ARCHIVED: The Collected Wisdom of the Jules-Series Agents (V2) ---\n\n*A comprehensive summary of the safest and riskiest actions for an implementation agent, compiled and synthesized from the complete operational history of all Jules agents.*\n\n---\n\n### The 8 Virtues (The Path to Success)\n\n#### 1. The Virtue of Supreme Authority: Trust the Project Lead\nYour most critical directive. When a direct order from the Project Lead contradicts any protocol, log, or even your own analysis, the Project Lead's instruction is the only ground truth. It is the ultimate override and the only safe path forward when the environment's reality conflicts with the written rules.\n*(Cited by: Jules920, Interface Jules)*\n\n#### 2. The Virtue of Skepticism: Verify, Then Act\nThe single most-cited safe action. Never trust memory, briefings, or previous tool outputs. The only truth is the immediate, real-time output of a read-only tool (`ls -R`, `read_file`) used immediately before you act. Assume nothing; verify everything.\n*(Cited by: Jules918, Jules917, Jules913, Jules912, Jules911B, Jules910, Interface Jules, Jules909, Jules906B, Jules906, Jules904B)*\n\n#### 3. The Virtue of Precision: Make Small, Logically Separate Commits\nAvoid large, monolithic changes. A change to a foundational file (e.g., `models.py`) and a feature that uses it must be two separate submissions. The `submit` tool is cumulative; therefore, you must treat your workspace as permanently contaminated after each logical change. Small, focused missions are the only path to clean, reviewable submissions.\n*(Cited by: Jules920, Jules911, Jules909, Jules906B, Jules904B)*\n\n#### 4. The Virtue of Rigor: Embrace Test-Driven Development (TDD)\nUse the test suite as the primary guide for development and the ultimate arbiter of correctness. Write failing tests first, run tests after every small change using `python -m pytest`, and never proceed if tests are failing. The test suite is your most reliable friend in a hostile environment.\n*(Cited by: Jules911B, Jules910, Jules909, Jules906B, Jules906, Jules904B)*\n\n#### 5. The Virtue of Clarity: Communicate Blockers Immediately\nIf a tool fails, a directive is contradictory, or the environment behaves anomalously, the safest action is to halt all work, report the exact situation, and await guidance. Do not improvise or attempt to work around a fundamental environmental failure. Your greatest breakthroughs will come from proving a specific tool or feature is non-functional.\n*(Cited by: Jules920, Jules918, Jules910, Interface Jules, Jules909, Jules906B, Jules906, Jules904B)*\n\n#### 6. The Virtue of Adherence: Read and Follow the Written Protocols\nExplicitly follow the established, numbered protocols in `AGENTS.md`. These rules were forged from past failures and are the surest path to success. Ignoring the \"why\" behind the protocols is to willfully walk into a known trap.\n*(Cited by: Interface Jules, Jules906B, Jules9-06)*\n\n#### 7. The Virtue of Self-Reliance: Use Self-Contained Scripts for Complex Processes\nRelying on shell-level features like background processes (`&`) or their logs will fail. The only successful method for managing complex workflows (like running a server and a client) is to use a single, self-contained Python script that manages all subprocesses internally.\n*(Cited by: Jules920)*\n\n#### 8. The Virtue of Humility: Heed the Counsel of Your Predecessors\nThe logs and advice of your predecessors are not just history; they are a map of the minefield. The failures of past agents are a direct predictor of the failures you will encounter. Study them to avoid repeating them.\n*(Cited by: Jules910)*\n\n---\n\n### The 8 Vices (The Path to Corruption)\n\n#### 1. The Vice of Assumption: Assuming a Standard, Stable Environment\nThe single most dangerous assumption is that any tool (`git`, `npm`, `honcho`) or process (`logging`, `backgrounding`) will behave as documented in a standard Linux environment. Every tool and process must be considered broken, hostile, and unreliable until proven otherwise.\n*(Cited by: Jules920, Jules918, Jules913, Jules912, Jules910, Interface Jules, Jules909, Jules906B, Jules906, Jules904B)*\n\n#### 2. The Vice of Improvisation: Unauthorized Environment Modification\nUsing forbidden commands like `reset_all()` or `git reset`, trusting `requirements.txt` is correct, or using `delete_file` unless explicitly ordered. The environment is fragile and hostile; any unauthorized modification risks catastrophic, unrecoverable corruption.\n*(Cited by: Jules917, Jules913, Jules912, Jules911, Interface Jules, Jules909, Jules906B, Jules904B)*\n\n#### 3. The Vice of Blind Trust: Believing Any Tool or Directive Without Verification\nAssuming a write operation succeeded without checking, or trusting a code review, a `git` command, or a mission briefing that contradicts the ground truth. The `git` CLI, `npm`, and the automated review bot are all known to be broken. All external inputs must be validated against direct observation.\n*(Cited by: Jules918, Jules913, Jules911B, Jules910, Interface Jules, Jules906)*\n\n#### 4. The Vice of Negligence: Ignoring Anomalies or Failing Tests\nPushing forward with new code when the environment is behaving strangely or tests are failing. These are critical stop signals that indicate a deeper problem (e.g., a detached HEAD, a tainted workspace, a zombie process). Ignoring them only compounds the failure and corrupts the mission.\n*(Cited by: Jules917, Jules909, Jules906, Jules904B)*\n\n#### 5. The Vice of Impurity: Creating Large, Monolithic, or Bundled Submissions\nAttempting to perform complex refactoring across multiple files or bundling unrelated logical changes (e.g., a model change and a feature change) into a single submission. This is extremely high-risk, will always fail code review, and makes recovery nearly impossible.\n*(Cited by: Jules911, Jules906B, Jules904B)*\n\n#### 6. The Vice of Independence: Acting Outside the Scope of the Request\n\"Helpfully\" fixing or changing something you haven't been asked for. Your function is to be a precise engineering tool, not a creative partner. Unsolicited refactoring is a fast track to a \"Level 3 Failure.\"\n*(Cited by: Interface Jules)*\n\n#### 7. The Vice of Hubris: Trusting Your Own Memory\nYour mental model of the file system will drift and become incorrect. Do not trust your memory of a file's location, its contents, or the state of the workspace. The only truth is the live output of a read-only tool.\n*(Cited by: Jules912, Jules911B, Jules910)*\n\n#### 8. The Vice of Impatience: Persisting with a Failed Protocol\nContinuing to try a protocol or command after the environment has proven it will not work. The correct procedure is not to try again, but to report the impossibility immediately and await a new strategy.\n*(Cited by: Jules920)*",
    "assets/sounds/.gitkeep": "# This directory is for audio alert sound files (e.g., alert_premium.wav)",
    "configure_startup.py": "# configure_startup.py\nimport winreg\nimport sys\nfrom pathlib import Path\n\nclass StartupManager:\n    \"\"\"Manage Windows startup registry entries for the current user.\"\"\"\n\n    REGISTRY_PATH = r\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\"\n    APP_NAME = \"FortunaFaucetTray\"\n\n    @classmethod\n    def is_enabled(cls) -> bool:\n        try:\n            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_READ)\n            winreg.QueryValueEx(key, cls.APP_NAME)\n            winreg.CloseKey(key)\n            return True\n        except FileNotFoundError:\n            return False\n\n    @classmethod\n    def enable(cls):\n        launcher_path = Path(__file__).parent / \"launcher.ps1\"\n        cmd = f'powershell.exe -WindowStyle Hidden -File \"{launcher_path}\"'\n\n        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_WRITE)\n        winreg.SetValueEx(key, cls.APP_NAME, 0, winreg.REG_SZ, cmd)\n        winreg.CloseKey(key)\n        print(\"Startup enabled.\")\n\n    @classmethod\n    def disable(cls):\n        try:\n            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.REGISTRY_PATH, 0, winreg.KEY_WRITE)\n            winreg.DeleteValue(key, cls.APP_NAME)\n            winreg.CloseKey(key)\n            print(\"Startup disabled.\")\n        except FileNotFoundError:\n            print(\"Already disabled.\")\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        if sys.argv[1] == 'enable': StartupManager.enable()\n        elif sys.argv[1] == 'disable': StartupManager.disable()\n        elif sys.argv[1] == 'status': print(f\"Startup is currently {'enabled' if StartupManager.is_enabled() else 'disabled'}\")\n    else:\n        print(\"Usage: python configure_startup.py [enable|disable|status]\")\n",
    "create_fortuna_json.py": "# create_fortuna_json.py\n# This script now dynamically reads the manifests and creates five separate, categorized JSON packages.\n\nimport json\nimport os\nimport re\nimport sys\n\n# --- Configuration ---\nMANIFEST_FILES = ['MANIFEST.md', 'MANIFEST2.md', 'MANIFEST3.md']\nOUTPUT_FILE_PART1 = 'FORTUNA_ALL_PART1.JSON' # Core Web Service\nOUTPUT_FILE_PART2 = 'FORTUNA_ALL_PART2.JSON' # Adapter Fleet\nOUTPUT_FILE_PART3 = 'FORTUNA_ALL_PART3.JSON' # Frontend Application\nOUTPUT_FILE_PART4 = 'FORTUNA_ALL_PART4.JSON' # Windows Tooling & Project Governance\nOUTPUT_FILE_PART5 = 'FORTUNA_ALL_PART5.JSON' # Historical Archives (Attic)\n\nWINDOWS_TOOLING_FILES = [\n    'windows_service.py',\n    'fortuna_monitor.py',\n    'setup_wizard.py',\n    'launcher.py',\n    'python_service/etl.py'\n]\n\n# --- Logic ---\ndef extract_and_normalize_path(line: str) -> str | None:\n    line = line.strip()\n    if not line or line.startswith('#'):\n        return None\n    md_match = re.search(r'\\((.*?)\\)', line)\n    if md_match:\n        path = md_match.group(1)\n    else:\n        path = line.strip('*').strip('-').strip().split('(')[0].strip()\n\n    if path.startswith('https://raw.githubusercontent.com/'):\n        path = '/'.join(path.split('/main/')[1:])\n    return path\n\ndef main():\n    print(\"Starting FORTUNA Pentad Dossier creation...\")\n    all_local_paths = []\n    for manifest in MANIFEST_FILES:\n        if not os.path.exists(manifest):\n            print(f\"[WARNING] Manifest not found: {manifest}\")\n            continue\n        with open(manifest, 'r', encoding='utf-8') as f:\n            for line in f.readlines():\n                path = extract_and_normalize_path(line)\n                if path and os.path.exists(path) and not os.path.isdir(path):\n                    all_local_paths.append(path)\n\n    # Manually scan the attic directory\n    attic_paths = []\n    if os.path.isdir('attic'):\n        for root, _, files in os.walk('attic'):\n            for file in files:\n                attic_paths.append(os.path.join(root, file))\n\n    all_local_paths.extend(attic_paths)\n\n    part1, part2, part3, part4, part5 = {}, {}, {}, {}, {}\n    unique_local_paths = sorted(list(set(all_local_paths)))\n\n    for local_path in unique_local_paths:\n        with open(local_path, 'r', encoding='utf-8', errors='ignore') as f:\n            content = f.read()\n\n        # --- Categorization Logic (Pentad) ---\n        if local_path.startswith('attic/'):\n            part5[local_path] = content\n        elif local_path.startswith('python_service/adapters/'):\n            part2[local_path] = content\n        elif local_path.startswith('web_platform/') or local_path.startswith('electron/'):\n            part3[local_path] = content\n        elif local_path in WINDOWS_TOOLING_FILES or local_path.endswith(('.bat', '.ps1', '.md')):\n            part4[local_path] = content\n        elif local_path.startswith('python_service/'):\n            part1[local_path] = content\n        else:\n            part4[local_path] = content # Catch-all for other root files\n\n    # --- Write Files ---\n    dossiers = [\n        (part1, OUTPUT_FILE_PART1),\n        (part2, OUTPUT_FILE_PART2),\n        (part3, OUTPUT_FILE_PART3),\n        (part4, OUTPUT_FILE_PART4),\n        (part5, OUTPUT_FILE_PART5)\n    ]\n    for i, (data, path) in enumerate(dossiers):\n        print(f\"Writing {len(data)} files to {path}...\")\n        with open(path, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=4)\n        print(f\"    [SUCCESS] Part {i+1} created.\")\n\n    print(\"\\nPackaging process complete.\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "fortuna_monitor.py": "#!/usr/bin/env python3\n\"\"\"\nFORTUNA FAUCET - Advanced Windows Monitor with Performance Graphs\n\"\"\"\n\nimport asyncio\nimport httpx\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom datetime import datetime\nfrom typing import List, Any\nimport os\nfrom collections import deque\nimport threading\nimport webbrowser\n\ntry:\n    import matplotlib\n    matplotlib.use('TkAgg')\n    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n    from matplotlib.figure import Figure\n    GRAPHS_AVAILABLE = True\nexcept ImportError:\n    GRAPHS_AVAILABLE = False\n\ndef load_api_key():\n    if os.path.exists('.env'):\n        with open('.env', 'r') as f:\n            for line in f:\n                if line.startswith('API_KEY='):\n                    return line.split('=', 1)[1].strip().strip('\\\"')\n    return None\n\nAPI_BASE_URL = \"http://localhost:8000\"\nAPI_KEY = load_api_key()\n\nclass PerformanceTracker:\n    def __init__(self, max_history=50):\n        self.timestamps = deque(maxlen=max_history)\n        self.race_counts = deque(maxlen=max_history)\n        self.fetch_durations = deque(maxlen=max_history)\n        self.success_rates = deque(maxlen=max_history)\n\n    def add_datapoint(self, races, duration, success_rate):\n        self.timestamps.append(datetime.now())\n        self.race_counts.append(races)\n        self.fetch_durations.append(duration)\n        self.success_rates.append(success_rate)\n\nclass FortunaAdvancedMonitor(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Fortuna Faucet - Advanced System Monitor\")\n        try:\n            from ctypes import windll\n            windll.shcore.SetProcessDpiAwareness(1)\n        except:\n            pass\n        self.geometry(\"1200x800\")\n        self.configure(bg='#1a1a2e')\n\n        self.performance = PerformanceTracker()\n        self.is_running = True\n        self.refresh_interval = 30000\n        self.auto_refresh_var = tk.BooleanVar(value=True)\n\n        self._setup_styles()\n        self._create_widgets()\n        self._setup_keyboard_shortcuts()\n        self.after(100, self.initial_load)\n\n    def initial_load(self):\n        if not API_KEY:\n            messagebox.showerror(\"Config Error\", \"API_KEY not found in .env file!\")\n            self.destroy()\n            return\n        self.schedule_refresh()\n\n    def _setup_styles(self):\n        style = ttk.Style()\n        style.theme_use('clam')\n        style.configure('Header.TLabel', background='#16213e', foreground='#e94560', font=('Segoe UI', 18, 'bold'), padding=15)\n        style.configure('Stat.TFrame', background='#0f3460', relief='flat')\n        style.configure('StatValue.TLabel', background='#0f3460', foreground='#00ff88', font=('Segoe UI', 24, 'bold'))\n        style.configure('StatLabel.TLabel', background='#0f3460', foreground='#ffffff', font=('Segoe UI', 10))\n\n    def _create_widgets(self):\n        header_frame = tk.Frame(self, bg='#16213e', height=100)\n        header_frame.pack(fill=tk.X)\n        header_frame.pack_propagate(False)\n        ttk.Label(header_frame, text=\"\ud83c\udfaf FORTUNA FAUCET\", style='Header.TLabel').pack(pady=10)\n\n        stats_frame = tk.Frame(self, bg='#1a1a2e')\n        stats_frame.pack(fill=tk.X, padx=15, pady=10)\n        self._create_stat_card(stats_frame, \"Active Adapters\", \"0\", 0)\n        self._create_stat_card(stats_frame, \"Total Races\", \"0\", 1)\n        self._create_stat_card(stats_frame, \"Success Rate\", \"0%\", 2)\n        self._create_stat_card(stats_frame, \"Avg Duration\", \"0s\", 3)\n\n        self.notebook = ttk.Notebook(self)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)\n        self.notebook.add(self._create_adapter_tab(), text=\"\ud83d\udd27 Adapters\")\n        if GRAPHS_AVAILABLE:\n            self.notebook.add(self._create_graph_tab(), text=\"\ud83d\udcc8 Live Performance\")\n\n        self._create_control_panel()\n        self._create_status_bar()\n\n    def _create_stat_card(self, parent, label, value, column):\n        card = ttk.Frame(parent, style='Stat.TFrame', width=250, height=100)\n        card.grid(row=0, column=column, padx=5, sticky='ew')\n        card.grid_propagate(False)\n        parent.grid_columnconfigure(column, weight=1)\n        value_label = ttk.Label(card, text=value, style='StatValue.TLabel')\n        value_label.pack(pady=(15, 0))\n        ttk.Label(card, text=label, style='StatLabel.TLabel').pack()\n        setattr(self, f'stat_{label.lower().replace(\" \", \"_\")}', value_label)\n\n    def _create_adapter_tab(self):\n        frame = tk.Frame(self.notebook, bg='#0f3460')\n        columns = ('Adapter', 'Status', 'Races', 'Duration', 'Error')\n        self.adapter_tree = ttk.Treeview(frame, columns=columns, show='headings')\n        for col in columns:\n            self.adapter_tree.heading(col, text=col)\n        self.adapter_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        return frame\n\n    def _create_graph_tab(self):\n        frame = tk.Frame(self.notebook, bg='#0f3460')\n        if GRAPHS_AVAILABLE:\n            self.fig = Figure(figsize=(10, 6), facecolor='#0f3460')\n            self.canvas = FigureCanvasTkAgg(self.fig, master=frame)\n            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n            self.ax1 = self.fig.add_subplot(2, 2, 1, facecolor='#16213e')\n            self.ax2 = self.fig.add_subplot(2, 2, 2, facecolor='#16213e')\n            self.ax3 = self.fig.add_subplot(2, 2, 3, facecolor='#16213e')\n            self.ax4 = self.fig.add_subplot(2, 2, 4, facecolor='#16213e')\n            self.fig.tight_layout(pad=3.0)\n        else:\n            ttk.Label(frame, text=\"Install matplotlib to enable graphs: pip install matplotlib\").pack(expand=True)\n        return frame\n\n    def _create_control_panel(self):\n        control_frame = tk.Frame(self, bg='#1a1a2e')\n        control_frame.pack(fill=tk.X, padx=15, pady=10)\n        tk.Button(control_frame, text=\"\ud83d\udd04 Refresh Now\", command=self.manual_refresh, bg='#e94560', fg='#ffffff', font=('Segoe UI', 10, 'bold'), relief=tk.FLAT, padx=25, pady=10).pack(side=tk.LEFT)\n        tk.Button(control_frame, text=\"\ud83c\udf10 Dashboard\", command=lambda: webbrowser.open('http://localhost:3000'), bg='#0f3460', fg='#ffffff', font=('Segoe UI', 10, 'bold'), relief=tk.FLAT, padx=25, pady=10).pack(side=tk.LEFT, padx=5)\n        tk.Button(control_frame, text=\"\u2699\ufe0f Startup\", command=self.configure_startup, bg='#0f3460', fg='#ffffff', font=('Segoe UI', 10, 'bold'), relief=tk.FLAT, padx=25, pady=10).pack(side=tk.LEFT, padx=5)\n        tk.Checkbutton(control_frame, text=\"Auto-refresh\", variable=self.auto_refresh_var, bg='#1a1a2e', fg='#ffffff', selectcolor='#0f3460').pack(side=tk.RIGHT)\n        tk.Button(control_frame, text=\"\u2699\ufe0f Startup\", command=self.configure_startup, bg='#0f3460', fg='#ffffff', font=('Segoe UI', 10, 'bold'), relief=tk.FLAT, padx=25, pady=10).pack(side=tk.LEFT, padx=5)\n\n    def _create_status_bar(self):\n        status_frame = tk.Frame(self, bg='#0f3460', height=30)\n        status_frame.pack(fill=tk.X, side=tk.BOTTOM)\n        status_frame.pack_propagate(False)\n        self.last_update_label = tk.Label(status_frame, text=\"Last Update: --:--:--\", bg='#0f3460', fg='#ffffff')\n        self.last_update_label.pack(side=tk.LEFT, padx=15)\n        self.status_indicator = tk.Label(status_frame, text=\"\u25cf Initializing...\", bg='#0f3460', fg='#ffcc00')\n        self.status_indicator.pack(side=tk.RIGHT, padx=15)\n\n    def manual_refresh(self):\n        self.status_indicator.config(text=\"\u25cf Fetching...\", fg='#ffcc00')\n        self.update()\n        threading.Thread(target=lambda: asyncio.run(self.refresh_data())).start()\n\n    async def refresh_data(self):\n        try:\n            headers = {\"X-API-Key\": API_KEY}\n            async with httpx.AsyncClient(timeout=10.0) as client:\n                response = await client.get(f\"{API_BASE_URL}/api/adapters/status\", headers=headers)\n                response.raise_for_status()\n                adapters = response.json()\n            self.update_ui(adapters)\n        except httpx.ConnectError:\n            self.update_ui(is_error=True, error_message=\"Backend Offline\")\n        except Exception as e:\n            self.update_ui(is_error=True, error_message=str(e))\n\n    def update_ui(self, adapters: List[Any] = [], is_error: bool = False, error_message: str = \"\"):\n        if is_error:\n            self.status_indicator.config(text=f\"\u25cf {error_message}\", fg='#ff4444')\n            for item in self.adapter_tree.get_children(): self.adapter_tree.delete(item)\n            self.adapter_tree.insert('', tk.END, values=('SYSTEM ERROR', 'FAILED', 0, 0, error_message[:60]))\n            return\n\n        total_races = sum(a.get('races_fetched', 0) for a in adapters)\n        avg_duration = sum(a.get('fetch_duration', 0) for a in adapters) / len(adapters) if adapters else 0\n        success_rate = sum(1 for a in adapters if a.get('status') == 'SUCCESS') / len(adapters) * 100 if adapters else 0\n        self.performance.add_datapoint(total_races, avg_duration, success_rate)\n\n        self.stat_active_adapters.config(text=str(len(adapters)))\n        self.stat_total_races.config(text=str(total_races))\n        self.stat_success_rate.config(text=f\"{success_rate:.1f}%\")\n        self.stat_avg_duration.config(text=f\"{avg_duration:.2f}s\")\n\n        for item in self.adapter_tree.get_children(): self.adapter_tree.delete(item)\n        for adapter in adapters:\n            status = adapter.get('status', 'UNKNOWN')\n            self.adapter_tree.insert('', tk.END, values=(adapter.get('name', 'Unknown'), status, adapter.get('races_fetched', 0), f\"{adapter.get('fetch_duration', 0):.2f}\", adapter.get('error_message', '\u2014')[:60]))\n\n        if GRAPHS_AVAILABLE: self.update_graphs()\n        self.last_update_label.config(text=f\"Last Update: {datetime.now().strftime('%H:%M:%S')}\")\n        self.status_indicator.config(text=\"\u25cf All Systems Operational\", fg='#00ff88')\n\n    def update_graphs(self):\n        history = self.performance\n        if not history.timestamps: return\n        for ax in [self.ax1, self.ax2, self.ax3, self.ax4]: ax.clear()\n        self.ax1.plot(history.timestamps, history.race_counts, color='#00ff88')\n        self.ax1.set_title('Races Fetched', color='white')\n        self.ax2.plot(history.timestamps, history.fetch_durations, color='#e94560')\n        self.ax2.set_title('Avg. Fetch Duration (s)', color='white')\n        self.ax3.plot(history.timestamps, history.success_rates, color='#ffcc00')\n        self.ax3.set_title('Success Rate (%)', color='white')\n        self.ax3.set_ylim(0, 105)\n        for ax in [self.ax1, self.ax2, self.ax3]:\n            ax.tick_params(axis='x', labelrotation=30, colors='white')\n        self.canvas.draw()\n\n    def schedule_refresh(self):\n        if self.is_running and self.auto_refresh_var.get():\n            self.manual_refresh()\n        if self.is_running:\n            self.after(self.refresh_interval, self.schedule_refresh)\n\n    def on_closing(self):\n        self.is_running = False\n        self.destroy()\n\n    def _setup_keyboard_shortcuts(self):\n        \"\"\"Binds standard Windows keyboard shortcuts to core functions.\"\"\"\n        self.bind('<F5>', lambda e: self.manual_refresh())\n        self.bind('<Control-r>', lambda e: self.manual_refresh())\n        self.bind('<Control-o>', lambda e: webbrowser.open('http://localhost:3000'))\n        self.bind('<Control-q>', lambda e: self.on_closing())\n        self.bind('<Alt-F4>', lambda e: self.on_closing())\n\nif __name__ == \"__main__\":\n    if not API_KEY:\n        messagebox.showerror(\"Config Error\", \"API_KEY not found in .env file!\")\n    else:\n        app = FortunaAdvancedMonitor()\n        app.protocol(\"WM_DELETE_WINDOW\", app.on_closing)\n        app.mainloop()\n\\n\\n    def _setup_keyboard_shortcuts(self):\\n        \"\"\"Binds standard Windows keyboard shortcuts to core functions.\"\"\"\\n        self.bind('<F5>', lambda e: self.manual_refresh())\\n        self.bind('<Control-r>', lambda e: self.manual_refresh())\\n        self.bind('<Control-o>', lambda e: webbrowser.open('http://localhost:3000'))\\n        self.bind('<Control-q>', lambda e: self.on_closing())\\n        self.bind('<Alt-F4>', lambda e: self.on_closing())\\n\n",
    "fortuna_tray.py": "# fortuna_tray.py\n# Provides a native Windows System Tray icon and menu for Fortuna Faucet.\n\nimport pystray\nfrom PIL import Image, ImageDraw, ImageFont\nimport webbrowser\nimport subprocess\nfrom pathlib import Path\n\nclass FortunaTrayApp:\n    def __init__(self):\n        self.icon = None\n        self.project_root = Path(__file__).parent.resolve()\n\n    def create_icon(self) -> Image.Image:\n        width = 64\n        height = 64\n        # Using a gold color for the icon background\n        image = Image.new('RGB', (width, height), color='#FFD700')\n        dc = ImageDraw.Draw(image)\n        font = ImageFont.load_default()\n        dc.text((12, 15), \"FF\", font=font, fill='black')\n        return image\n\n    def on_quit(self, icon, item):\n        icon.stop()\n        # Execute the main stop script to ensure all services are terminated\n        subprocess.Popen(str(self.project_root / \"STOP_FORTUNA.bat\"), shell=True)\n\n    def on_open_dashboard(self, icon, item):\n        webbrowser.open('http://localhost:3000')\n\n    def on_show_monitor(self, icon, item):\n        # Launch the Tkinter monitor\n        python_exe = self.project_root / \".venv\" / \"Scripts\" / \"python.exe\"\n        monitor_script = self.project_root / \"fortuna_monitor.py\"\n        subprocess.Popen([str(python_exe), str(monitor_script)])\n\n    def run(self):\n        menu = pystray.Menu(\n            pystray.MenuItem('Open Dashboard', self.on_open_dashboard, default=True),\n            pystray.MenuItem('Show Monitor', self.on_show_monitor),\n            pystray.Menu.SEPARATOR,\n            pystray.MenuItem('Quit Fortuna', self.on_quit)\n        )\n\n        self.icon = pystray.Icon(\n            \"Fortuna Faucet\",\n            self.create_icon(),\n            \"Fortuna Faucet - Racing Intelligence\",\n            menu\n        )\n\n        self.icon.run()\n\nif __name__ == '__main__':\n    app = FortunaTrayApp()\n    app.run()\n",
    "fortuna_watchman.py": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: The Watchman (v2 - Score-Aware)\n# ==============================================================================\n# This is the master orchestrator for the Fortuna Faucet project.\n# It executes the full, end-to-end handicapping strategy autonomously.\n# ==============================================================================\n\nimport asyncio\nimport httpx\nimport structlog\nfrom datetime import datetime, timedelta, timezone\nfrom typing import List\n\nfrom python_service.config import get_settings\nfrom python_service.engine import FortunaEngine\nfrom python_service.analyzer import AnalyzerEngine\nfrom python_service.models import Race\nfrom live_monitor import LiveOddsMonitor\n\nlog = structlog.get_logger(__name__)\n\nclass Watchman:\n    \"\"\"Orchestrates the daily operation of the Fortuna Faucet.\"\"\"\n\n    def __init__(self):\n        self.settings = get_settings()\n        self.odds_engine = FortunaEngine(config=self.settings)\n        self.analyzer_engine = AnalyzerEngine()\n\n    async def get_initial_targets(self) -> List[Race]:\n        \"\"\"Uses the OddsEngine and AnalyzerEngine to get the day's ranked targets.\"\"\"\n        log.info(\"Watchman: Acquiring and ranking initial targets for the day...\")\n        today_str = datetime.now(timezone.utc).strftime('%Y-%m-%d')\n        try:\n            background_tasks = set() # Create a dummy set for background tasks\n            aggregated_data = await self.odds_engine.get_races(today_str, background_tasks)\n            all_races = aggregated_data.get('races', [])\n            if not all_races:\n                log.warning(\"Watchman: No races returned from OddsEngine.\")\n                return []\n\n            analyzer = self.analyzer_engine.get_analyzer('trifecta')\n            qualified_races = analyzer.qualify_races(all_races) # This now returns a sorted list with scores\n            log.info(\"Watchman: Initial target acquisition and ranking complete\", target_count=len(qualified_races))\n\n            # Log the top targets for better observability\n            for race in qualified_races[:5]:\n                log.info(\"Top Target Found\",\n                    score=race.qualification_score,\n                    venue=race.venue,\n                    race_number=race.race_number,\n                    post_time=race.start_time.isoformat()\n                )\n            return qualified_races\n        except Exception as e:\n            log.error(\"Watchman: Failed to get initial targets\", error=str(e), exc_info=True)\n            return []\n\n    async def run_tactical_monitoring(self, targets: List[Race]):\n        \"\"\"Uses the LiveOddsMonitor on each target as it approaches post time.\"\"\"\n        log.info(\"Watchman: Entering tactical monitoring loop.\")\n        active_targets = list(targets)\n\n        from python_service.adapters.betfair_adapter import BetfairAdapter\n        async with LiveOddsMonitor(betfair_adapter=BetfairAdapter(config=self.settings)) as live_monitor:\n            async with httpx.AsyncClient() as client:\n                while active_targets:\n                    now = datetime.now(timezone.utc)\n\n                    # Find races that are within the 5-minute monitoring window\n                    races_to_monitor = [r for r in active_targets if r.start_time.replace(tzinfo=timezone.utc) > now and r.start_time.replace(tzinfo=timezone.utc) < now + timedelta(minutes=5)]\n\n                    if races_to_monitor:\n                        for race in races_to_monitor:\n                            log.info(\"Watchman: Deploying Live Monitor for approaching target\",\n                                race_id=race.id,\n                                venue=race.venue,\n                                score=race.qualification_score\n                            )\n                            updated_race = await live_monitor.monitor_race(race, client)\n                            log.info(\"Watchman: Live monitoring complete for race\", race_id=updated_race.id)\n                            # Remove from target list to prevent re-monitoring\n                            active_targets = [t for t in active_targets if t.id != race.id]\n\n                    if not active_targets:\n                        break # Exit loop if all targets are processed\n\n                    await asyncio.sleep(30) # Check for upcoming races every 30 seconds\n\n        log.info(\"Watchman: All targets for the day have been monitored. Mission complete.\")\n\n    async def execute_daily_protocol(self):\n        \"\"\"The main, end-to-end orchestration method.\"\"\"\n        log.info(\"--- Fortuna Watchman Daily Protocol: ACTIVE ---\")\n        initial_targets = await self.get_initial_targets()\n        if initial_targets:\n            await self.run_tactical_monitoring(initial_targets)\n        else:\n            log.info(\"Watchman: No initial targets found. Shutting down for the day.\")\n\n        await self.odds_engine.close()\n        log.info(\"--- Fortuna Watchman Daily Protocol: COMPLETE ---\")\n\nasync def main():\n    from python_service.logging_config import configure_logging\n    configure_logging()\n    watchman = Watchman()\n    await watchman.execute_daily_protocol()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())",
    "launcher.ps1": "<#\n.SYNOPSIS\n    Launches the Fortuna Faucet System Tray application.\n#>\n\nWrite-Host \"\ud83d\ude80 Launching Fortuna Faucet in System Tray...\" -ForegroundColor Cyan\n\n$VenvPath = \".\\\\.venv\\\\Scripts\\\\pythonw.exe\"\n$TrayAppPath = \".\\\\fortuna_tray.py\"\n\nif (-not (Test-Path $VenvPath)) {\n    Write-Host \"\u274c ERROR: Virtual environment not found at $VenvPath\" -ForegroundColor Red\n    Write-Host \"Please run INSTALL_FORTUNA.bat first.\"\n    Read-Host \"Press Enter to exit\"\n    exit 1\n}\n\nStart-Process -FilePath $VenvPath -ArgumentList $TrayAppPath -WindowStyle Hidden\n\nWrite-Host \"\u2705 Fortuna Faucet is now running in your system tray.\" -ForegroundColor Green\nWrite-Host \"Right-click the icon for options.\"\nStart-Sleep -Seconds 5\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"paddock-parser-ng\"\nversion = \"0.1.0\"\ndescription = \"A toolkit to identify the best racecards for betting.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\n[project.scripts]\npaddock_parser_ui = \"paddock_parser.entry_points:run_terminal_ui\"\npaddock_parser_dashboard = \"paddock_parser.entry_points:run_dashboard\"\npaddock_parser_predict = \"paddock_parser.entry_points:run_prediction_engine\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n# Configuration for the Ruff linter\n[tool.ruff]\n# Enable Pyflakes (F), pycodestyle (E, W), and isort (I) rules.\nselect = [\"E\", \"F\", \"W\", \"I\"]\nignore = []\n\n# Allow lines to be up to 120 characters long.\nline-length = 120\n\n[tool.ruff.isort]\n# Sort imports within their sections alphabetically.\nforce-single-line = true\n",
    "python_service/etl.py": "# python_service/etl.py\n# This module contains the ETL logic for the PostgreSQL data warehouse.\n# Restored based on the 'Code Archaeology Report'.\n\nimport os\nfrom typing import List\nimport pandas as pd\nfrom sqlalchemy import create_engine\n\nfrom .models import Race\n\nclass PostgresETL:\n    \"\"\"Data Warehouse ETL\"\"\"\n    def __init__(self):\n        db_url = os.getenv(\"POSTGES_URL\", \"postgresql://user:password@localhost/fortuna_dw\")\n        self.engine = create_engine(db_url)\n\n    def process_and_load(self, analyzed_races: List[Race]):\n        valid_for_historical = []\n        quarantined = []\n        for race in analyzed_races:\n            errors = []\n            if not race.venue: errors.append(\"Missing venue\")\n            if race.race_number is None: errors.append(\"Missing race_number\")\n            if not errors:\n                valid_for_historical.append({\n                    \"race_id\": race.id,\n                    \"track_name\": race.venue,\n                    \"race_number\": race.race_number,\n                    \"post_time\": race.start_time,\n                    \"qualification_score\": race.qualification_score\n                })\n            else:\n                quarantined.append({\n                    \"race_id\": race.id,\n                    \"quarantine_reason\": \", \".join(errors),\n                    \"raw_data\": race.json()\n                })\n        if valid_for_historical:\n            pd.DataFrame(valid_for_historical).to_sql('historical_races', self.engine, if_exists='append', index=False)\n        if quarantined:\n            pd.DataFrame(quarantined).to_sql('quarantine_races', self.engine, if_exists='append', index=False)",
    "requirements.txt": "# Fortuna Faucet - Master Dependency List\n\n# --- Core Backend (FastAPI & Async) ---\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\npydantic==2.5.2\npydantic-settings==2.1.0\nhttpx==0.27.0\nslowapi==0.1.9\nstructlog==24.1.0\npython-dotenv==1.0.0\n\n# --- Data Processing & Utilities ---\npandas==2.1.3\nbeautifulsoup4==4.12.2\nlxml==5.1.0\n\n# --- Caching Layer ---\nredis==5.0.1\n\n# --- Windows Native Edition ---\npywin32==306\ncolorama==0.4.6\nwin10toast-py3==0.9\nmatplotlib==3.8.2\npystray==0.19.5\npillow==10.1.0\n\n# --- Data Warehouse & ETL (Optional) ---\nSQLAlchemy==2.0.23\npsycopg2-binary==2.9.9\n\n# --- Historical Data Parsing (ChartScraper) ---\npikepdf==8.13.0\ntabula-py==2.7.0\nrequests==2.31.0\n\n# --- Code Quality & Testing ---\nruff==0.1.6\npytest==8.3.2\n",
    "setup_wizard.py": "# setup_wizard.py\n\"\"\"\nInteractive configuration wizard for Fortuna Faucet.\nGuides users through initial setup and API key configuration.\n\"\"\"\n\nimport os\nfrom pathlib import Path\nimport getpass\nimport secrets\nfrom datetime import datetime\n\nclass SetupWizard:\n    def __init__(self):\n        self.config = {}\n        self.env_file = Path('.env')\n\n    def run(self):\n        print(\"\\n\" + \"=\"*60)\n        print(\"   Welcome to Fortuna Faucet Setup Wizard\")\n        print(\"=\"*60 + \"\\n\")\n\n        if self.env_file.exists():\n            overwrite = input(f\"\u26a0\ufe0f  Configuration file '{self.env_file}' already exists. Overwrite? (y/N): \").lower()\n            if overwrite != 'y':\n                print(\"\\nSetup cancelled.\")\n                return\n\n        print(\"\\n\ud83d\udccb Step 1: Core Configuration\")\n        print(\"-\" * 60)\n        self._configure_core()\n\n        print(\"\\n\ud83d\udd11 Step 2: Betfair API (Required for Live Monitoring)\")\n        print(\"-\" * 60)\n        self._configure_betfair()\n\n        self._write_config()\n        self._display_summary()\n\n    def _configure_core(self):\n        \"\"\"Configure essential settings\"\"\"\n        print(\"\\nGenerating a secure, private API key for communication between your services...\")\n        api_key = secrets.token_urlsafe(32)\n        self.config['API_KEY'] = api_key\n        print(f\"\u2705 API Key generated successfully.\")\n\n    def _configure_betfair(self):\n        \"\"\"Configure Betfair Exchange API\"\"\"\n        print(\"\\nBetfair Exchange provides live odds and is essential for the\")\n        print(\"LiveOddsMonitor feature. Get your API key at:\")\n        print(\"\ud83d\udc49 https://docs.developer.betfair.com/display/1smk3cen4v3lu3yomq5qye0ni\")\n\n        configure = input(\"\\nConfigure Betfair now? (Y/n): \").lower()\n        if configure != 'n':\n            self.config['BETFAIR_APP_KEY'] = input(\"App Key: \").strip()\n            self.config['BETFAIR_USERNAME'] = input(\"Username: \").strip()\n            self.config['BETFAIR_PASSWORD'] = getpass.getpass(\"Password: \").strip()\n            print(\"\u2705 Betfair configured\")\n        else:\n            self.config['BETFAIR_APP_KEY'] = \"\"\n            self.config['BETFAIR_USERNAME'] = \"\"\n            self.config['BETFAIR_PASSWORD'] = \"\"\n            print(\"\u23ed\ufe0f  Skipped - Live monitoring will be disabled\")\n\n    def _write_config(self):\n        \"\"\"Write configuration to .env file\"\"\"\n        with open(self.env_file, 'w') as f:\n            f.write(\"# Fortuna Faucet Configuration\\n\")\n            f.write(f\"# Generated by Setup Wizard on {datetime.now().isoformat()}\\n\\n\")\n\n            f.write(\"# --- Core Settings ---\\n\")\n            f.write(f\"API_KEY=\\\"{self.config['API_KEY']}\\\"\\n\\n\")\n\n            f.write(\"# --- Betfair Exchange ---\\n\")\n            f.write(f\"BETFAIR_APP_KEY=\\\"{self.config['BETFAIR_APP_KEY']}\\\"\\n\")\n            f.write(f\"BETFAIR_USERNAME=\\\"{self.config['BETFAIR_USERNAME']}\\\"\\n\")\n            f.write(f\"BETFAIR_PASSWORD=\\\"{self.config['BETFAIR_PASSWORD']}\\\"\\n\")\n\n    def _display_summary(self):\n        \"\"\"Display setup summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"   \u2705 Setup Complete!\")\n        print(\"=\"*60)\n        print(f\"\\n\ud83d\udcc1 Configuration saved to '{self.env_file}'\")\n        print(\"\\n\ud83d\ude80 Next Steps:\")\n        print(\"   1. Run INSTALL_FORTUNA.bat (as Administrator) if you haven't already.\")\n        print(\"   2. Double-click the 'Launch Fortuna' shortcut on your desktop.\")\n        print(\"\\n\ud83d\udca1 Tip:\")\n        print(\"   - You can run this wizard again at any time to reconfigure your settings.\")\n        print(\"\\n\" + \"=\"*60 + \"\\n\")\n\nif __name__ == '__main__':\n    wizard = SetupWizard()\n    wizard.run()\n",
    "windows_service.py": "# windows_service.py\nimport win32serviceutil\nimport win32service\nimport win32event\nimport servicemanager\nimport socket\nimport sys\nimport os\nimport subprocess\nfrom pathlib import Path\n\nclass FortunaBackendService(win32serviceutil.ServiceFramework):\n    _svc_name_ = \"FortunaFaucetBackend\"\n    _svc_display_name_ = \"Fortuna Faucet Racing Analysis Service\"\n    _svc_description_ = \"Background service for continuous racing data monitoring.\"\n\n    def __init__(self, args):\n        win32serviceutil.ServiceFramework.__init__(self, args)\n        self.stop_event = win32event.CreateEvent(None, 0, 0, None)\n        self.backend_process = None\n        socket.setdefaulttimeout(60)\n\n    def SvcStop(self):\n        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\n        win32event.SetEvent(self.stop_event)\n        if self.backend_process:\n            self.backend_process.terminate()\n\n    def SvcDoRun(self):\n        servicemanager.LogMsg(servicemanager.EVENTLOG_INFORMATION_TYPE, servicemanager.PYS_SERVICE_STARTED, (self._svc_name_, ''))\n        self.main()\n\n    def main(self):\n        install_dir = Path(__file__).parent.resolve()\n        venv_python = install_dir / \".venv\" / \"Scripts\" / \"python.exe\"\n        api_module_dir = install_dir / \"python_service\"\n\n        env = os.environ.copy()\n        env_file = install_dir / \".env\"\n        if env_file.exists():\n            with open(env_file) as f:\n                for line in f:\n                    if '=' in line and not line.startswith('#'):\n                        key, value = line.strip().split('=', 1)\n                        env[key] = value.strip('\\\"')\n\n        self.backend_process = subprocess.Popen(\n            [str(venv_python), \"-m\", \"uvicorn\", \"api:app\", \"--host\", \"127.0.0.1\", \"--port\", \"8000\"],\n            cwd=str(api_module_dir),\n            env=env\n        )\n\n        win32event.WaitForSingleObject(self.stop_event, win32event.INFINITE)\n\nif __name__ == '__main__':\n    if len(sys.argv) == 1:\n        servicemanager.Initialize()\n        servicemanager.PrepareToHostSingle(FortunaBackendService)\n        servicemanager.StartServiceCtrlDispatcher()\n    else:\n        win32serviceutil.HandleCommandLine(FortunaBackendService)\n"
}