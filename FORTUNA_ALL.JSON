{
    "python_service/adapters/at_the_races_adapter.py": "# python_service/adapters/at_the_races_adapter.py\n\nimport asyncio, structlog, httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass AtTheRacesAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"AtTheRaces\", base_url=\"https://www.attheraces.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/racecards')\n        if not response_html: return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.race-time-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if not response_html: return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            header = soup.select_one(\"h1.heading-racecard-title\").get_text()\n            track_name, race_time = [p.strip() for p in header.split(\"|\")[:2]]\n            active_link = soup.select_one(\"a.race-time-link.active\")\n            race_number = active_link.find_parent(\"div\", \"races\").select(\"a.race-time-link\").index(active_link) + 1\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time}\", \"%Y-%m-%d %H:%M\")\n            runners = [self._parse_runner(row) for row in soup.select(\"div.card-horse\")]\n            return Race(id=f\"atr_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception: return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"h3.horse-name a\").get_text())\n            num_str = _clean_text(row.select_one(\"span.horse-number\").get_text())\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"button.best-odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except: return None\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool, error_message: str = None) -> Dict[str, Any]:\n        return {'races': races, 'source_info': {'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED', 'races_fetched': len(races), 'error_message': error_message, 'fetch_duration': (datetime.now() - start_time).total_seconds()}}",
    "python_service/adapters/betfair_greyhound_adapter.py": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Betfair Greyhound API Adapter\n# ==============================================================================\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairGreyhoundAdapter(BaseAdapter):\n    \"\"\"API client for the Betfair Exchange, specifically for Greyhound markets.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairGreyhound\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n        self.session_token: Optional[str] = None\n        self.token_expiry: Optional[datetime] = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > (datetime.now() + timedelta(minutes=5)):\n            return\n        if not all([self.app_key, self.config.BETFAIR_USERNAME, self.config.BETFAIR_PASSWORD]):\n            raise ValueError(\"Betfair credentials not fully configured.\")\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.config.BETFAIR_USERNAME}&password={self.config.BETFAIR_PASSWORD}'\n\n        log.info(\"BetfairGreyhoundAdapter: Authenticating...\")\n        response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == 'SUCCESS':\n            self.session_token = data.get('token')\n            self.token_expiry = datetime.now() + timedelta(hours=3)\n        else:\n            raise ConnectionError(f\"Betfair authentication failed: {data.get('error')}\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            market_filter = {\"eventTypeIds\": [\"4339\"], \"marketTypeCodes\": [\"WIN\"], \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}}\n\n            market_catalogue = await self.make_request(\n                http_client, 'POST', 'listMarketCatalogue/', headers=headers,\n                json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]}\n            )\n\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No greyhound markets found.\")\n\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"BetfairGreyhoundAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"BetfairGreyhoundAdapter: Failed to fetch races\", exc_info=True, error=str(e))\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        runners = []\n        for runner_data in market.get('runners', []):\n            runners.append(Runner(\n                number=runner_data.get('sortPriority', 99),\n                name=runner_data['runnerName'],\n                selection_id=runner_data['selectionId']\n            ))\n        return Race(\n            id=f\"bfg_{market['marketId']}\",\n            venue=market['event']['venue'],\n            race_number=self._extract_race_number(market.get('marketName')),\n            start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')),\n            runners=runners,\n            source=self.source_name\n        )\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name: return 1\n        match = re.search(r'\\\\bR(\\\\d{1,2})\\\\b', name)\n        return int(match.group(1)) if match else 1\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }",
    "python_service/adapters/pointsbet_greyhound_adapter.py": "# python_service/adapters/pointsbet_greyhound_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass PointsBetGreyhoundAdapter(BaseAdapter):\n    \"\"\"TODO: This is a placeholder adapter. It will not be active until the correct sportId is found.\"\"\"\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"PointsBet Greyhound\",\n            base_url=\"https://api.au.pointsbet.com\"\n        )\n        self.api_key = config.POINTSBET_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        # TODO: This adapter is a placeholder and is not registered in the engine.\n        # To enable, find the correct sportId for Greyhound Racing and register the adapter.\n        log.warning(\"PointsBetGreyhoundAdapter: This adapter is a non-functional placeholder.\")\n        return self._format_response([], start_time, is_success=True, error_message=\"Adapter is a placeholder.\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }",
    "python_service/adapters/racing_and_sports_greyhound_adapter.py": "# python_service/adapters/racing_and_sports_greyhound_adapter.py\n\nimport os\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass RacingAndSportsGreyhoundAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"Racing and Sports Greyhound\",\n            base_url=\"https://api.racingandsports.com.au/\"\n        )\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Authorization\": f\"Bearer {self.api_token}\", \"Accept\": \"application/json\"}\n\n        if not self.api_token:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: Token not set\")\n\n        try:\n            # HYPOTHESIS: The greyhound endpoint is parallel to the racing one.\n            meetings_url = \"v1/greyhound/meetings\"\n            params = {\"date\": date, \"jurisdiction\": \"AUS\"} # Jurisdiction may need to be adjusted\n            meetings_data = await self.make_request(http_client, 'GET', meetings_url, headers=headers, params=params)\n\n            if not meetings_data or not meetings_data.get('meetings'):\n                return self._format_response(all_races, start_time, is_success=True, error_message=\"No greyhound meetings found.\")\n\n            for meeting in meetings_data['meetings']:\n                for race_summary in meeting.get('races', []):\n                    try:\n                        parsed_race = self._parse_ras_race(meeting, race_summary)\n                        all_races.append(parsed_race)\n                    except Exception as e:\n                        log.error(\"RacingAndSportsGreyhoundAdapter: Failed to parse race\", meeting=meeting.get('venueName'), error=str(e), exc_info=True)\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"RacingAndSportsGreyhoundAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"RacingAndSportsGreyhoundAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races), 'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('runnerNumber'), name=rd.get('horseName', 'Unknown'), scratched=rd.get('isScratched', False)) for rd in race.get('runners', [])]\n\n        return Race(\n            id=f\"rasg_{race.get('raceId')}\",\n            venue=meeting.get('venueName', 'Unknown Venue'),\n            race_number=race.get('raceNumber'),\n            start_time=datetime.fromisoformat(race.get('startTime')),\n            runners=runners,\n            source=self.source_name\n        )",
    "python_service/adapters/sporting_life_adapter.py": "# python_service/adapters/sporting_life_adapter.py\n\nimport asyncio, structlog, httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass SportingLifeAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"SportingLife\", base_url=\"https://www.sportinglife.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/horse-racing/racecards')\n        if not response_html: return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.hr-race-card-meeting__race-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if not response_html: return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            track_name = _clean_text(soup.select_one(\"a.hr-race-header-course-name__link\").get_text())\n            race_time_str = _clean_text(soup.select_one(\"span.hr-race-header-time__time\").get_text())\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            active_link = soup.select_one(\"a.hr-race-header-navigation-link--active\")\n            race_number = soup.select(\"a.hr-race-header-navigation-link\").index(active_link) + 1 if active_link else 1\n            runners = [self._parse_runner(row) for row in soup.select(\"div.hr-racing-runner-card\")]\n            return Race(id=f\"sl_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception: return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"a.hr-racing-runner-horse-name\").get_text())\n            num_str = _clean_text(row.select_one(\"span.hr-racing-runner-saddle-cloth-no\").get_text())\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"span.hr-racing-runner-odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except: return None\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool, error_message: str = None) -> Dict[str, Any]:\n        return {'races': races, 'source_info': {'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED', 'races_fetched': len(races), 'error_message': error_message, 'fetch_duration': (datetime.now() - start_time).total_seconds()}}",
    "python_service/adapters/the_racing_api_adapter.py": "# python_service/adapters/theracingapi_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass TheRacingApiAdapter(BaseAdapter):\n    \"\"\"Adapter for the high-value JSON-based The Racing API.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"TheRacingAPI\",\n            base_url=\"https://api.theracingapi.com/v1/\"\n        )\n        self.api_key = config.THE_RACING_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        if not self.api_key:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: THE_RACING_API_KEY not set\")\n\n        try:\n            endpoint = f\"racecards?date={date}&course=all&region=gb,ire\"\n            headers = {\"Authorization\": f\"Bearer {self.api_key}\"}\n            response_json = await self.make_request(http_client, 'GET', endpoint, headers=headers)\n\n            if not response_json or not response_json.get('racecards'):\n                return self._format_response([], start_time, is_success=True, error_message=\"No racecards found in API response.\")\n\n            all_races = self._parse_races(response_json['racecards'])\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(f\"{self.source_name}: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(f\"{self.source_name}: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _parse_races(self, racecards: List[Dict[str, Any]]) -> List[Race]:\n        races = []\n        for race_data in racecards:\n            try:\n                start_time = datetime.fromisoformat(race_data['off_time'].replace('Z', '+00:00'))\n                \n                race = Race(\n                    id=f\"tra_{race_data['race_id']}\",\n                    venue=race_data['course'],\n                    race_number=race_data['race_no'],\n                    start_time=start_time,\n                    runners=self._parse_runners(race_data.get('runners', [])),\n                    source=self.source_name,\n                    race_name=race_data.get('race_name'),\n                    distance=race_data.get('distance_f'),\n                )\n                races.append(race)\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing race\", race_id=race_data.get('race_id'), error=str(e))\n        return races\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for i, runner_data in enumerate(runners_data):\n            try:\n                odds_data = {}\n                if runner_data.get('odds'):\n                    win_odds = Decimal(str(runner_data['odds'][0]['odds_decimal']))\n                    odds_data[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=runner_data.get('number', i + 1),\n                    name=runner_data['horse'],\n                    odds=odds_data,\n                    jockey=runner_data.get('jockey'),\n                    trainer=runner_data.get('trainer'),\n                ))\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing runner\", runner_name=runner_data.get('horse'), error=str(e))\n        return runners\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': (datetime.now() - start_time).total_seconds()\n            }\n        }",
    "python_service/adapters/timeform_adapter.py": "# python_service/adapters/timeform_adapter.py\n\nimport asyncio, structlog, httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass TimeformAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"Timeform\", base_url=\"https://www.timeform.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/horse-racing/racecards')\n        if not response_html: return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.rp-racecard-off-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if not response_html: return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            track_name = _clean_text(soup.select_one(\"h1.rp-raceTimeCourseName_name\").get_text())\n            race_time_str = _clean_text(soup.select_one(\"span.rp-raceTimeCourseName_time\").get_text())\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            all_times = [_clean_text(a.get_text()) for a in soup.select('a.rp-racecard-off-link')]\n            race_number = all_times.index(race_time_str) + 1 if race_time_str in all_times else 1\n            runners = [self._parse_runner(row) for row in soup.select(\"div.rp-horseTable_mainRow\")]\n            return Race(id=f\"tf_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception: return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"a.rp-horseTable_horse-name\").get_text())\n            num_str = _clean_text(row.select_one(\"span.rp-horseTable_horse-number\").get_text()).strip(\"()\")\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"button.rp-bet-placer-btn__odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except: return None\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool, error_message: str = None) -> Dict[str, Any]:\n        return {'races': races, 'source_info': {'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED', 'races_fetched': len(races), 'error_message': error_message, 'fetch_duration': (datetime.now() - start_time).total_seconds()}}"
}