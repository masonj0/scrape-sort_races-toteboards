{
    "python_service/adapters/at_the_races_adapter.py": "# python_service/adapters/at_the_races_adapter.py\n\nimport asyncio\nimport structlog\nimport httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass AtTheRacesAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"AtTheRaces\", base_url=\"https://www.attheraces.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/racecards')\n        if not response_html:\n            return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.race-time-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if response_html is None:\n                return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            header = soup.select_one(\"h1.heading-racecard-title\").get_text()\n            track_name, race_time = [p.strip() for p in header.split(\"|\")[:2]]\n            active_link = soup.select_one(\"a.race-time-link.active\")\n            race_number = active_link.find_parent(\"div\", \"races\").select(\"a.race-time-link\").index(active_link) + 1\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time}\", \"%Y-%m-%d %H:%M\")\n            runners = [self._parse_runner(row) for row in soup.select(\"div.card-horse\")]\n            return Race(id=f\"atr_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception as e:\n            log.error(\"Error parsing race from AtTheRaces\", url=url, exc_info=e)\n            return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"h3.horse-name a\").get_text())\n            num_str = _clean_text(row.select_one(\"span.horse-number\").get_text())\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"button.best-odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str is not None else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except Exception as e:\n            log.warning(\"Failed to parse runner\", exc_info=e)\n            return None\n",
    "python_service/adapters/base_v3.py": "# python_service/adapters/base_v3.py\n# Defines the base class for the V3 adapter architecture.\n\nfrom abc import ABC, abstractmethod\nimport structlog\n\nfrom ..models_v3 import NormalizedRace\n\nclass BaseAdapterV3(ABC):\n    def __init__(self, name: str, enabled: bool = True, priority: int = 100):\n        self._name = name\n        self._enabled = enabled\n        self._priority = priority\n        self.logger = structlog.get_logger(adapter_name=self.get_name())\n\n    def get_name(self) -> str:\n        return self._name\n\n    def is_enabled(self) -> bool:\n        return self._enabled\n\n    @abstractmethod\n    def fetch_and_normalize(self) -> list[NormalizedRace]:\n        raise NotImplementedError\n",
    "python_service/adapters/betfair_auth_mixin.py": "# python_service/adapters/betfair_auth_mixin.py\n\nimport httpx\nimport structlog\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairAuthMixin:\n    \"\"\"Encapsulates Betfair authentication logic for reuse across adapters.\"\"\"\n    session_token: Optional[str] = None\n    token_expiry: Optional[datetime] = None\n\n    async def _authenticate(self, http_client: httpx.AsyncClient):\n        if self.session_token and self.token_expiry and self.token_expiry > (datetime.now() + timedelta(minutes=5)):\n            return\n        if not all([self.app_key, self.config.BETFAIR_USERNAME, self.config.BETFAIR_PASSWORD]):\n            raise ValueError(\"Betfair credentials not fully configured.\")\n\n        auth_url = \"https://identitysso.betfair.com/api/login\"\n        headers = {'X-Application': self.app_key, 'Content-Type': 'application/x-www-form-urlencoded'}\n        payload = f'username={self.config.BETFAIR_USERNAME}&password={self.config.BETFAIR_PASSWORD}'\n\n        log.info(f\"{self.__class__.__name__}: Authenticating...\")\n        response = await http_client.post(auth_url, headers=headers, content=payload, timeout=20)\n        response.raise_for_status()\n        data = response.json()\n        if data.get('status') == 'SUCCESS':\n            self.session_token = data.get('token')\n            self.token_expiry = datetime.now() + timedelta(hours=3)\n        else:\n            raise ConnectionError(f\"Betfair authentication failed: {data.get('error')}\")",
    "python_service/adapters/betfair_datascientist_adapter.py": "# python_service/adapters/betfair_datascientist_adapter.py\n\nimport pandas as pd\nimport requests\nfrom datetime import datetime\nfrom io import StringIO\n\nfrom ..models_v3 import NormalizedRace, NormalizedRunner\nfrom .base_v3 import BaseAdapterV3\nfrom .utils import normalize_course_name\n\nclass BetfairDataScientistAdapter(BaseAdapterV3):\n    ADAPTER_NAME = \"BetfairDataScientist\"\n\n    def __init__(self, model_name: str, url: str, enabled: bool = True, priority: int = 100):\n        super().__init__(f\"{self.ADAPTER_NAME}_{model_name}\", enabled, priority)\n        self.model_name = model_name\n        self.url = url\n        self.logger.info(f\"Initialized BetfairDataScientistAdapter for model: {self.model_name}\")\n\n    def fetch_and_normalize(self) -> list[NormalizedRace]:\n        if not self.is_enabled():\n            self.logger.debug(f\"Adapter '{self.get_name()}' is disabled. Skipping.\")\n            return []\n\n        try:\n            full_url = self._build_url()\n            self.logger.info(f\"Fetching data from {full_url}\")\n            response = requests.get(full_url)\n            response.raise_for_status()\n            df = pd.read_csv(StringIO(response.text))\n            return self._normalize_df(df)\n        except Exception as e:\n            self.logger.error(f\"An unexpected error in {self.get_name()}: {e}\", exc_info=True)\n            return []\n\n    def _normalize_df(self, df: pd.DataFrame) -> list[NormalizedRace]:\n        df = df.rename(columns={\n            \"meetings.races.bfExchangeMarketId\": \"market_id\",\n            \"meetings.races.runners.bfExchangeSelectionId\": \"selection_id\",\n            \"meetings.races.runners.ratedPrice\": \"rated_price\",\n            \"meetings.races.raceName\": \"race_name\",\n            \"meetings.name\": \"meeting_name\",\n            \"meetings.races.raceNumber\": \"race_number\",\n            \"meetings.races.runners.runnerName\": \"runner_name\",\n            \"meetings.races.runners.clothNumber\": \"saddle_cloth\"\n        })\n        normalized_races = []\n        for market_id, group in df.groupby(\"market_id\"):\n            race_info = group.iloc[0]\n            runners = [\n                NormalizedRunner(\n                    runner_id=str(row.get('selection_id')),\n                    name=str(row.get('runner_name')),\n                    saddle_cloth=str(row.get('saddle_cloth', '')),\n                    odds_decimal=float(row.get('rated_price', 0.0))\n                ) for _, row in group.iterrows()\n            ]\n            race = NormalizedRace(\n                race_key=str(market_id),\n                track_key=normalize_course_name(str(race_info.get('meeting_name', ''))),\n                start_time_iso=datetime.now().isoformat(),\n                race_name=str(race_info.get('race_name', '')),\n                runners=runners,\n                source_ids=[self.get_name()],\n            )\n            normalized_races.append(race)\n        self.logger.info(f\"Normalized {len(normalized_races)} races from {self.model_name}.\")\n        return normalized_races\n\n    def _build_url(self) -> str:\n        todays_date = datetime.now().strftime(\"%Y-%m-%d\")\n        return f\"{self.url}{todays_date}&presenter=RatingsPresenter&csv=true\"\n",
    "python_service/adapters/betfair_greyhound_adapter.py": "# python_service/adapters/betfair_greyhound_adapter.py\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nfrom .base import BaseAdapter\nfrom .betfair_auth_mixin import BetfairAuthMixin\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairGreyhoundAdapter(BetfairAuthMixin, BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairGreyhound\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            market_filter = {\"eventTypeIds\": [\"4339\"], \"marketTypeCodes\": [\"WIN\"], \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}}\n            market_catalogue = await self.make_request(http_client, 'POST', 'listMarketCatalogue/', headers=headers, json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]})\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('sortPriority', 99), name=rd['runnerName'], selection_id=rd['selectionId']) for rd in market.get('runners', [])]\n        return Race(id=f\"bfg_{market['marketId']}\", venue=market['event']['venue'], race_number=self._extract_race_number(market.get('marketName')), start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')), runners=runners, source=self.source_name)\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name:\n            return 1\n        match = re.search(r'\\bR(\\d{1,2})\\b', name)\n        return int(match.group(1)) if match else 1",
    "python_service/adapters/fanduel_adapter.py": "# python_service/adapters/fanduel_adapter.py\n\nimport httpx\nimport structlog\nfrom datetime import datetime, timedelta, timezone\nfrom decimal import Decimal\nfrom typing import List, Dict, Any\n\nfrom ..models import Race, Runner, OddsData\nfrom .base import BaseAdapter\n\nlog = structlog.get_logger()\n\nclass FanDuelAdapter(BaseAdapter):\n    \"\"\"Adapter for fetching horse racing odds from FanDuel's private API.\"\"\"\n\n    source_name = \"FanDuel\"\n    API_URL = \"https://sb-api.nj.sportsbook.fanduel.com/api/markets?_ak=Fh2e68s832c41d4b&eventId=\"\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> List[Race]:\n        \"\"\"Fetches races for a given date. Note: FanDuel API is event-based, not date-based.\"\"\"\n        # This is a placeholder for a more robust event discovery mechanism.\n        # For now, we'll use a known event ID for a major race day as a proof of concept.\n        # A full implementation would need to first find the relevant event IDs for the day.\n        event_id = \"38183.3\" # Example: A major race event\n\n        log.info(\"Fetching races from FanDuel\", event_id=event_id)\n        start_time = datetime.now()\n        try:\n            response = await http_client.get(self.API_URL + event_id)\n            response.raise_for_status()\n            data = response.json()\n            races = self._parse_races(data)\n            return self._format_response(races, start_time, is_success=True)\n        except httpx.HTTPStatusError as e:\n            log.error(\"FanDuel API request failed\", status_code=e.response.status_code, response=e.response.text)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n        except Exception as e:\n            log.error(\"An unexpected error occurred fetching FanDuel data\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_races(self, data: Dict[str, Any]) -> List[Race]:\n        races = []\n        if 'marketGroups' not in data:\n            log.warning(\"FanDuel response missing 'marketGroups' key\")\n            return []\n\n        for group in data['marketGroups']:\n            if group.get('marketGroupName') == 'Win':\n                for market in group.get('markets', []):\n                    try:\n                        race = self._parse_single_race(market)\n                        if race:\n                            races.append(race)\n                    except Exception as e:\n                        log.error(\"Failed to parse a FanDuel market\", market=market, error=str(e), exc_info=True)\n        return races\n\n    def _parse_single_race(self, market: Dict[str, Any]) -> Race | None:\n        market_name = market.get('marketName', '')\n        if not market_name.startswith('Race'):\n            return None\n\n        # Extract race number and track from market name (e.g., \"Race 5 - Churchill Downs\")\n        parts = market_name.split(' - ')\n        if len(parts) < 2:\n            return None\n\n        race_number_str = parts[0].replace('Race ', '')\n        track_name = parts[1]\n\n        # Placeholder for start_time - FanDuel's market API doesn't provide it directly\n        start_time = datetime.now(timezone.utc) + timedelta(hours=int(race_number_str))\n\n        runners = []\n        for runner_data in market.get('runners', []):\n            runner_name = runner_data.get('runnerName')\n            win_odds = runner_data.get('winRunnerOdds', {}).get('currentPrice')\n            if not runner_name or not win_odds:\n                continue\n\n            try:\n                # Price is given as a fraction string, e.g., \"12/5\"\n                numerator, denominator = map(int, win_odds.split('/'))\n                decimal_odds = Decimal(numerator) / Decimal(denominator) + 1\n            except (ValueError, ZeroDivisionError):\n                log.warning(\"Could not parse FanDuel odds\", odds_str=win_odds, runner=runner_name)\n                continue\n\n            odds = OddsData(\n                win=decimal_odds,\n                source=self.source_name,\n                last_updated=datetime.now(timezone.utc)\n            )\n\n            # Placeholder for program number\n            program_number_str = runner_name.split('.')[0].strip()\n\n            runner = Runner(\n                name=runner_name.split('.')[1].strip(),\n                number=int(program_number_str) if program_number_str.isdigit() else None,\n                odds={self.source_name: odds}\n            )\n            runners.append(runner)\n\n        if not runners:\n            return None\n\n        race_id = f\"FD-{track_name.replace(' ', '')[:5].upper()}-{start_time.strftime('%Y%m%d')}-R{race_number_str}\"\n\n        return Race(\n            id=race_id,\n            venue=track_name,\n            race_number=int(race_number_str),\n            start_time=start_time,\n            runners=runners,\n            source=self.source_name\n        )\n",
    "python_service/adapters/gbgb_api_adapter.py": "# python_service/adapters/gbgb_api_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass GbgbApiAdapter(BaseAdapter):\n    \"\"\"Adapter for the undocumented JSON API for the Greyhound Board of Great Britain.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"GBGB\",\n            base_url=\"https://api.gbgb.org.uk/api/\"\n        )\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            # The endpoint appears to be structured by date for all meetings\n            endpoint = f\"results/meeting/{date}\"\n            response_json = await self.make_request(http_client, 'GET', endpoint)\n\n            if not response_json:\n                return self._format_response([], start_time, is_success=True, error_message=\"No meetings found in API response.\")\n\n            all_races = self._parse_meetings(response_json)\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(f\"{self.source_name}: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(f\"{self.source_name}: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _parse_meetings(self, meetings_data: List[Dict[str, Any]]) -> List[Race]:\n        races = []\n        if meetings_data is None:\n            return races\n        for meeting in meetings_data:\n            track_name = meeting.get('trackName')\n            for race_data in meeting.get('races', []):\n                try:\n                    races.append(self._parse_race(race_data, track_name))\n                except Exception as e:\n                    log.error(f\"{self.source_name}: Error parsing race\", race_id=race_data.get('raceId'), error=str(e))\n        return races\n\n    def _parse_race(self, race_data: Dict[str, Any], track_name: str) -> Race:\n        return Race(\n            id=f\"gbgb_{race_data['raceId']}\",\n            venue=track_name,\n            race_number=race_data['raceNumber'],\n            start_time=datetime.fromisoformat(race_data['raceTime'].replace('Z', '+00:00')),\n            runners=self._parse_runners(race_data.get('traps', [])),\n            source=self.source_name,\n            race_name=race_data.get('raceTitle'),\n            distance=f\"{race_data.get('raceDistance')}m\",\n        )\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for runner_data in runners_data:\n            try:\n                # The API provides SP as a fraction, e.g., '5/2'\n                odds_data = {}\n                sp = runner_data.get('sp')\n                if sp:\n                    from .utils import parse_odds # Local import to avoid circular dependency issues at module level\n                    win_odds = Decimal(str(parse_odds(sp)))\n                    if win_odds < 999:\n                        odds_data[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=runner_data['trapNumber'],\n                    name=runner_data['dogName'],\n                    odds=odds_data,\n                ))\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing runner\", runner_name=runner_data.get('dogName'), error=str(e))\n        return runners\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': (datetime.now() - start_time).total_seconds()\n            }\n        }",
    "python_service/adapters/pointsbet_greyhound_adapter.py": "# python_service/adapters/pointsbet_greyhound_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\n\nfrom .base import BaseAdapter\nfrom ..models import Race\n\nlog = structlog.get_logger(__name__)\n\nclass PointsBetGreyhoundAdapter(BaseAdapter):\n    \"\"\"TODO: This is a placeholder adapter. It will not be active until the correct sportId is found.\"\"\"\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"PointsBet Greyhound\",\n            base_url=\"https://api.au.pointsbet.com\"\n        )\n        self.api_key = config.POINTSBET_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        # TODO: This adapter is a placeholder and is not registered in the engine.\n        # To enable, find the correct sportId for Greyhound Racing and register the adapter.\n        log.warning(\"PointsBetGreyhoundAdapter: This adapter is a non-functional placeholder.\")\n        return self._format_response([], start_time, is_success=True, error_message=\"Adapter is a placeholder.\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }",
    "python_service/adapters/base.py": "#!/usr/bin/env python3\n# ==============================================================================\n#  Fortuna Faucet: Base Adapter (v2 - Hardened with Tenacity)\n# ==============================================================================\n\nimport httpx\nimport structlog\nfrom datetime import datetime\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional\nfrom tenacity import stop_after_attempt, wait_exponential, RetryError, AsyncRetrying\n\nlog = structlog.get_logger(__name__)\n\nclass BaseAdapter(ABC):\n    \"\"\"The resilient base class for all data source adapters.\"\"\"\n\n    def __init__(self, source_name: str, base_url: str, timeout: int = 20, max_retries: int = 3):\n        self.source_name = source_name\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n    @abstractmethod\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        raise NotImplementedError\n\n    async def make_request(self, http_client: httpx.AsyncClient, method: str, url: str, **kwargs) -> Optional[Any]:\n        \"\"\"Makes a resilient HTTP request with automatic retries using Tenacity.\"\"\"\n        retryer = AsyncRetrying(\n            stop=stop_after_attempt(self.max_retries),\n            wait=wait_exponential(multiplier=1, min=2, max=10),\n            reraise=True\n        )\n        try:\n            async for attempt in retryer:\n                with attempt:\n                    try:\n                        full_url = url if url.startswith('http') else f\"{self.base_url}{url}\"\n                        log.info(\"Requesting...\", adapter=self.source_name, method=method, url=full_url, attempt=attempt.retry_state.attempt_number)\n                        response = await http_client.request(method, full_url, timeout=self.timeout, **kwargs)\n                        response.raise_for_status()\n                        return response.json()\n                    except (httpx.RequestError, httpx.HTTPStatusError) as e:\n                        log.warning(\"Request failed, tenacity will retry...\", adapter=self.source_name, error=str(e))\n                        raise # Reraise to trigger tenacity's retry mechanism\n        except RetryError as e:\n            log.error(f\"Max retries exceeded for {self.source_name}. Aborting request.\", final_error=str(e))\n            return None # Return None on total failure\n\n    def get_status(self) -> Dict[str, Any]:\n        return {\"adapter_name\": self.source_name, \"status\": \"OK\"}\n\n    def _format_response(self, races: List, start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        \"\"\"Formats the adapter's response consistently.\"\"\"\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }",
    "python_service/adapters/betfair_adapter.py": "# python_service/adapters/betfair_adapter.py\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nfrom .base import BaseAdapter\nfrom .betfair_auth_mixin import BetfairAuthMixin\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairAdapter(BetfairAuthMixin, BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairExchange\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            market_filter = {\"eventTypeIds\": [\"7\"], \"marketTypeCodes\": [\"WIN\"], \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}}\n            market_catalogue = await self.make_request(http_client, 'POST', 'listMarketCatalogue/', headers=headers, json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]})\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race | None:\n        if market is None:\n            return None\n        runners = [Runner(number=rd.get('sortPriority', 99), name=rd['runnerName'], selection_id=rd['selectionId']) for rd in market.get('runners', [])]\n        return Race(id=f\"bf_{market['marketId']}\", venue=market['event']['venue'], race_number=self._extract_race_number(market.get('marketName')), start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')), runners=runners, source=self.source_name)\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name:\n            return 1\n        match = re.search(r'\\bR(\\d{1,2})\\b', name)\n        return int(match.group(1)) if match else 1\n\n    # The duplicated method has been removed.\n    async def close(self):\n        \"\"\"Closes the underlying HTTP client to release resources.\"\"\"\n        if self.http_client:\n            await self.http_client.aclose()\n",
    "python_service/adapters/betfair_greyhound_adapter.py": "# python_service/adapters/betfair_greyhound_adapter.py\n\nimport httpx\nimport structlog\nimport re\nfrom datetime import datetime\nfrom typing import Dict, Any, Optional\n\nfrom .base import BaseAdapter\nfrom .betfair_auth_mixin import BetfairAuthMixin\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass BetfairGreyhoundAdapter(BetfairAuthMixin, BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"BetfairGreyhound\", base_url=\"https://api.betfair.com/exchange/betting/rest/v1.0/\")\n        self.config = config\n        self.app_key = self.config.BETFAIR_APP_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            await self._authenticate(http_client)\n            headers = {\"X-Application\": self.app_key, \"X-Authentication\": self.session_token, \"Content-Type\": \"application/json\"}\n            market_filter = {\"eventTypeIds\": [\"4339\"], \"marketTypeCodes\": [\"WIN\"], \"marketStartTime\": {\"from\": f\"{date}T00:00:00Z\", \"to\": f\"{date}T23:59:59Z\"}}\n            market_catalogue = await self.make_request(http_client, 'POST', 'listMarketCatalogue/', headers=headers, json={\"filter\": market_filter, \"maxResults\": 1000, \"marketProjection\": [\"EVENT\", \"RUNNER_DESCRIPTION\"]})\n            if not market_catalogue:\n                return self._format_response([], start_time, is_success=True, error_message=\"No markets found.\")\n            all_races = [self._parse_race(market) for market in market_catalogue]\n            return self._format_response(all_races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    def _parse_race(self, market: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('sortPriority', 99), name=rd['runnerName'], selection_id=rd['selectionId']) for rd in market.get('runners', [])]\n        return Race(id=f\"bfg_{market['marketId']}\", venue=market['event']['venue'], race_number=self._extract_race_number(market.get('marketName')), start_time=datetime.fromisoformat(market['marketStartTime'].replace('Z', '+00:00')), runners=runners, source=self.source_name)\n\n    def _extract_race_number(self, name: Optional[str]) -> int:\n        if not name:\n            return 1\n        match = re.search(r'\\bR(\\d{1,2})\\b', name)\n        return int(match.group(1)) if match else 1",
    "python_service/adapters/racing_and_sports_adapter.py": "# python_service/adapters/racing_and_sports_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass RacingAndSportsAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"Racing and Sports\",\n            base_url=\"https://api.racingandsports.com.au/\"\n        )\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Authorization\": f\"Bearer {self.api_token}\", \"Accept\": \"application/json\"}\n\n        if not self.api_token:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: Token not set\")\n\n        try:\n            meetings_url = \"v1/racing/meetings\"\n            params = {\"date\": date, \"jurisdiction\": \"AUS\"}\n            meetings_data = await self.make_request(http_client, 'GET', meetings_url, headers=headers, params=params)\n\n            if not meetings_data or not meetings_data.get('meetings'):\n                return self._format_response(all_races, start_time, is_success=True)\n\n            for meeting in meetings_data['meetings']:\n                for race_summary in meeting.get('races', []):\n                    try:\n                        parsed_race = self._parse_ras_race(meeting, race_summary)\n                        all_races.append(parsed_race)\n                    except Exception as e:\n                        log.error(\"RacingAndSportsAdapter: Failed to parse race\", meeting=meeting.get('venueName'), error=str(e), exc_info=True)\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"RacingAndSportsAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"RacingAndSportsAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races), 'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('runnerNumber'), name=rd.get('horseName', 'Unknown'), scratched=rd.get('isScratched', False)) for rd in race.get('runners', [])]\n\n        return Race(\n            id=f\"ras_{race.get('raceId')}\",\n            venue=meeting.get('venueName', 'Unknown Venue'),\n            race_number=race.get('raceNumber'),\n            start_time=datetime.fromisoformat(race.get('startTime')),\n            runners=runners,\n            source=self.source_name\n        )",
    "python_service/adapters/racing_and_sports_greyhound_adapter.py": "# python_service/adapters/racing_and_sports_greyhound_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner\n\nlog = structlog.get_logger(__name__)\n\nclass RacingAndSportsGreyhoundAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"Racing and Sports Greyhound\",\n            base_url=\"https://api.racingandsports.com.au/\"\n        )\n        self.api_token = config.RACING_AND_SPORTS_TOKEN\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        all_races: List[Race] = []\n        headers = {\"Authorization\": f\"Bearer {self.api_token}\", \"Accept\": \"application/json\"}\n\n        if not self.api_token:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: Token not set\")\n\n        try:\n            # HYPOTHESIS: The greyhound endpoint is parallel to the racing one.\n            meetings_url = \"v1/greyhound/meetings\"\n            params = {\"date\": date, \"jurisdiction\": \"AUS\"} # Jurisdiction may need to be adjusted\n            meetings_data = await self.make_request(http_client, 'GET', meetings_url, headers=headers, params=params)\n\n            if not meetings_data or not meetings_data.get('meetings'):\n                return self._format_response(all_races, start_time, is_success=True, error_message=\"No greyhound meetings found.\")\n\n            for meeting in meetings_data['meetings']:\n                for race_summary in meeting.get('races', []):\n                    try:\n                        parsed_race = self._parse_ras_race(meeting, race_summary)\n                        all_races.append(parsed_race)\n                    except Exception as e:\n                        log.error(\"RacingAndSportsGreyhoundAdapter: Failed to parse race\", meeting=meeting.get('venueName'), error=str(e), exc_info=True)\n\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(\"RacingAndSportsGreyhoundAdapter: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(\"RacingAndSportsGreyhoundAdapter: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        fetch_duration = (datetime.now() - start_time).total_seconds()\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races), 'error_message': error_message,\n                'fetch_duration': fetch_duration\n            }\n        }\n\n    def _parse_ras_race(self, meeting: Dict[str, Any], race: Dict[str, Any]) -> Race:\n        runners = [Runner(number=rd.get('runnerNumber'), name=rd.get('horseName', 'Unknown'), scratched=rd.get('isScratched', False)) for rd in race.get('runners', [])]\n\n        return Race(\n            id=f\"rasg_{race.get('raceId')}\",\n            venue=meeting.get('venueName', 'Unknown Venue'),\n            race_number=race.get('raceNumber'),\n            start_time=datetime.fromisoformat(race.get('startTime')),\n            runners=runners,\n            source=self.source_name\n        )",
    "python_service/adapters/sporting_life_adapter.py": "# python_service/adapters/sporting_life_adapter.py\n\nimport asyncio\nimport structlog\nimport asyncio\nimport structlog\nimport httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass SportingLifeAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"SportingLife\", base_url=\"https://www.sportinglife.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/horse-racing/racecards')\n        if not response_html:\n            return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.hr-race-card-meeting__race-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if not response_html:\n                return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            track_name = _clean_text(soup.select_one(\"a.hr-race-header-course-name__link\").get_text())\n            race_time_str = _clean_text(soup.select_one(\"span.hr-race-header-time__time\").get_text())\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            active_link = soup.select_one(\"a.hr-race-header-navigation-link--active\")\n            race_number = soup.select(\"a.hr-race-header-navigation-link\").index(active_link) + 1 if active_link else 1\n            runners = [self._parse_runner(row) for row in soup.select(\"div.hr-racing-runner-card\")]\n            return Race(id=f\"sl_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception as e:\n            log.error(\"Error parsing race from SportingLife\", url=url, exc_info=e)\n            return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"a.hr-racing-runner-horse-name\").get_text())\n            num_str = _clean_text(row.select_one(\"span.hr-racing-runner-saddle-cloth-no\").get_text())\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"span.hr-racing-runner-odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except Exception as e:\n            log.warning(\"Failed to parse runner from SportingLife\", exc_info=e)\n            return None\n",
    "python_service/adapters/the_racing_api_adapter.py": "# python_service/adapters/theracingapi_adapter.py\n\nimport structlog\nfrom datetime import datetime\nfrom typing import Dict, Any, List\nimport httpx\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\n\nlog = structlog.get_logger(__name__)\n\nclass TheRacingApiAdapter(BaseAdapter):\n    \"\"\"Adapter for the high-value JSON-based The Racing API.\"\"\"\n\n    def __init__(self, config):\n        super().__init__(\n            source_name=\"TheRacingAPI\",\n            base_url=\"https://api.theracingapi.com/v1/\"\n        )\n        self.api_key = config.THE_RACING_API_KEY\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        if not self.api_key:\n            return self._format_response([], start_time, is_success=False, error_message=\"ConfigurationError: THE_RACING_API_KEY not set\")\n\n        try:\n            endpoint = f\"racecards?date={date}&course=all&region=gb,ire\"\n            headers = {\"Authorization\": f\"Bearer {self.api_key}\"}\n            response_json = await self.make_request(http_client, 'GET', endpoint, headers=headers)\n\n            if not response_json or not response_json.get('racecards'):\n                return self._format_response([], start_time, is_success=True, error_message=\"No racecards found in API response.\")\n\n            all_races = self._parse_races(response_json['racecards'])\n            return self._format_response(all_races, start_time, is_success=True)\n        except httpx.HTTPError as e:\n            log.error(f\"{self.source_name}: HTTP request failed after retries\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=\"API request failed after multiple retries.\")\n        except Exception as e:\n            log.error(f\"{self.source_name}: An unexpected error occurred\", error=str(e), exc_info=True)\n            return self._format_response([], start_time, is_success=False, error_message=f\"An unexpected error occurred: {e}\")\n\n    def _parse_races(self, racecards: List[Dict[str, Any]]) -> List[Race]:\n        races = []\n        for race_data in racecards:\n            try:\n                start_time = datetime.fromisoformat(race_data['off_time'].replace('Z', '+00:00'))\n\n                race = Race(\n                    id=f\"tra_{race_data['race_id']}\",\n                    venue=race_data['course'],\n                    race_number=race_data['race_no'],\n                    start_time=start_time,\n                    runners=self._parse_runners(race_data.get('runners', [])),\n                    source=self.source_name,\n                    race_name=race_data.get('race_name'),\n                    distance=race_data.get('distance_f'),\n                )\n                races.append(race)\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing race\", race_id=race_data.get('race_id'), error=str(e))\n        return races\n\n    def _parse_runners(self, runners_data: List[Dict[str, Any]]) -> List[Runner]:\n        runners = []\n        for i, runner_data in enumerate(runners_data):\n            try:\n                odds_data = {}\n                if runner_data.get('odds'):\n                    win_odds = Decimal(str(runner_data['odds'][0]['odds_decimal']))\n                    odds_data[self.source_name] = OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())\n\n                runners.append(Runner(\n                    number=runner_data.get('number', i + 1),\n                    name=runner_data['horse'],\n                    odds=odds_data,\n                    jockey=runner_data.get('jockey'),\n                    trainer=runner_data.get('trainer'),\n                ))\n            except Exception as e:\n                log.error(f\"{self.source_name}: Error parsing runner\", runner_name=runner_data.get('horse'), error=str(e))\n        return runners\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool = True, error_message: str = None) -> Dict[str, Any]:\n        return {\n            'races': races,\n            'source_info': {\n                'name': self.source_name,\n                'status': 'SUCCESS' if is_success else 'FAILED',\n                'races_fetched': len(races),\n                'error_message': error_message,\n                'fetch_duration': (datetime.now() - start_time).total_seconds()\n            }\n        }",
    "python_service/adapters/timeform_adapter.py": "# python_service/adapters/timeform_adapter.py\n\nimport asyncio\nimport structlog\nimport asyncio\nimport structlog\nimport httpx\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nfrom bs4 import BeautifulSoup, Tag\nfrom decimal import Decimal\n\nfrom .base import BaseAdapter\nfrom ..models import Race, Runner, OddsData\nfrom .utils import parse_odds\n\nlog = structlog.get_logger(__name__)\n\ndef _clean_text(text: Optional[str]) -> Optional[str]:\n    return ' '.join(text.strip().split()) if text else None\n\nclass TimeformAdapter(BaseAdapter):\n    def __init__(self, config):\n        super().__init__(source_name=\"Timeform\", base_url=\"https://www.timeform.com\")\n\n    async def fetch_races(self, date: str, http_client: httpx.AsyncClient) -> Dict[str, Any]:\n        start_time = datetime.now()\n        try:\n            race_links = await self._get_race_links(http_client)\n            tasks = [self._fetch_and_parse_race(link, http_client) for link in race_links]\n            races = [race for race in await asyncio.gather(*tasks) if race]\n            return self._format_response(races, start_time, is_success=True)\n        except Exception as e:\n            return self._format_response([], start_time, is_success=False, error_message=str(e))\n\n    async def _get_race_links(self, http_client: httpx.AsyncClient) -> List[str]:\n        response_html = await self.make_request(http_client, 'GET', '/horse-racing/racecards')\n        if not response_html:\n            return []\n        soup = BeautifulSoup(response_html, \"html.parser\")\n        links = {a['href'] for a in soup.select(\"a.rp-racecard-off-link[href]\")}\n        return [f\"{self.base_url}{link}\" for link in links]\n\n    async def _fetch_and_parse_race(self, url: str, http_client: httpx.AsyncClient) -> Optional[Race]:\n        try:\n            response_html = await self.make_request(http_client, 'GET', url)\n            if not response_html:\n                return None\n            soup = BeautifulSoup(response_html, \"html.parser\")\n            track_name = _clean_text(soup.select_one(\"h1.rp-raceTimeCourseName_name\").get_text())\n            race_time_str = _clean_text(soup.select_one(\"span.rp-raceTimeCourseName_time\").get_text())\n            start_time = datetime.strptime(f\"{datetime.now().date()} {race_time_str}\", \"%Y-%m-%d %H:%M\")\n            all_times = [_clean_text(a.get_text()) for a in soup.select('a.rp-racecard-off-link')]\n            race_number = all_times.index(race_time_str) + 1 if race_time_str in all_times else 1\n            runners = [self._parse_runner(row) for row in soup.select(\"div.rp-horseTable_mainRow\")]\n            return Race(id=f\"tf_{track_name.replace(' ', '')}_{start_time.strftime('%Y%m%d')}_R{race_number}\", venue=track_name, race_number=race_number, start_time=start_time, runners=[r for r in runners if r], source=self.source_name)\n        except Exception as e:\n            log.error(\"Error parsing race from Timeform\", url=url, exc_info=e)\n            return None\n\n    def _parse_runner(self, row: Tag) -> Optional[Runner]:\n        try:\n            name = _clean_text(row.select_one(\"a.rp-horseTable_horse-name\").get_text())\n            num_str = _clean_text(row.select_one(\"span.rp-horseTable_horse-number\").get_text()).strip(\"()\")\n            number = int(''.join(filter(str.isdigit, num_str)))\n            odds_str = _clean_text(row.select_one(\"button.rp-bet-placer-btn__odds\").get_text())\n            win_odds = Decimal(str(parse_odds(odds_str))) if odds_str else None\n            odds_data = {self.source_name: OddsData(win=win_odds, source=self.source_name, last_updated=datetime.now())} if win_odds and win_odds < 999 else {}\n            return Runner(number=number, name=name, odds=odds_data)\n        except Exception as e:\n            log.warning(\"Failed to parse runner from Timeform\", exc_info=e)\n            return None\n\n    def _format_response(self, races: List[Race], start_time: datetime, is_success: bool, error_message: str = None) -> Dict[str, Any]:\n        return {'races': races, 'source_info': {'name': self.source_name, 'status': 'SUCCESS' if is_success else 'FAILED', 'races_fetched': len(races), 'error_message': error_message, 'fetch_duration': (datetime.now() - start_time).total_seconds()}}"
}