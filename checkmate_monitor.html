<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Checkmate Live Monitor (Serverless ‚Ä¢ Multi-Source)</title>
<style>
:root{--bg:#f0f2f5;--fg:#333;--card:#fff;--muted:#666;--border:#e6e6e6;--danger:#d9534f;--accent:#2b7cff;--ok:#1bb14c;--warn:#ffb200}
*{box-sizing:border-box}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg);margin:0}
.container{max-width:1200px;margin:auto;padding:16px}
h1{text-align:center;font-size:1.6rem;margin:8px 0 12px}
#status{text-align:center;font-style:italic;margin:8px 0 16px;color:var(--muted)}
.controls{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap;margin-bottom:12px}
button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:6px;cursor:pointer;font-weight:600}
button.secondary{background:#777}
button.warning{background:var(--warn);color:#222}
button:disabled{opacity:.6;cursor:not-allowed}
select, label{font-size:.95rem}
#sourceBadge{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;background:#eef3ff;color:#1746a2;border:1px solid #cfdcff;font-size:.8rem}
#opportunities{border:2px solid var(--danger);background:#fff7f7;border-radius:8px;padding:12px;margin-bottom:16px;display:none}
#opportunities h3{margin:0 0 8px;color:var(--danger)}
table{width:100%;border-collapse:collapse}
th,td{text-align:left;padding:8px;border-bottom:1px solid var(--border);font-size:.95rem}
.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px}
.card{background:var(--card);border-radius:8px;padding:12px;box-shadow:0 2px 4px rgba(0,0,0,.06)}
.card h3{margin:0 0 8px;border-bottom:1px solid var(--border);padding-bottom:8px}
.list{display:grid;gap:8px}
.item{display:grid;gap:6px;padding:8px;border:1px solid var(--border);border-radius:6px;background:#fff}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between}
.meta{color:var(--muted);font-size:.9rem}
.badge{display:inline-block;padding:2px 6px;font-size:.8rem;border-radius:999px;background:#eee;color:#333}
.badge.danger{background:#ffe4e4;color:var(--danger);border:1px solid #ffc6c6}
.badge.ok{background:#e8f8ee;color:var(--ok);border:1px solid #c9f0d7}
.muted{color:var(--muted)}
.small{font-size:.85rem}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.hint{text-align:center;color:var(--muted);font-size:.9rem;margin-top:6px}
.ticker{margin:12px 0;padding:8px;border:1px dashed var(--border);border-radius:6px;background:#fcfcff}
.ticker h4{margin:0 0 8px}
.initial-state{text-align:center;color:var(--muted);margin:40px 0;padding:20px;border:2px dashed var(--border);border-radius:8px;background:#fafafa}
#logContainer h3{border-bottom:none;padding-bottom:0;margin-bottom:0}
@media (max-width:380px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <h1>üèá Checkmate Live Monitor (Serverless ‚Ä¢ Multi-Source) <span id="sourceBadge">Source: Auto (None)</span></h1>
  <div id="status">Click "Start Monitoring" to begin‚Ä¶</div>
  <div class="controls">
    <button id="monitorBtn">Start Monitoring</button>
    <button id="refreshBtn" class="secondary" disabled>Refresh Now</button>
    <label>Source:
      <select id="sourceSelect" title="Choose source or Auto">
        <option value="auto" selected>Auto (Waterfall)</option>
        <option value="TwinSpires">TwinSpires (Gold)</option>
        <option value="RPB2B">RPB2B (Silver)</option>
        <option value="PointsBet">PointsBet (Contender)</option>
      </select>
    </label>
    <label><input type="checkbox" id="testModeToggle"> Test Mode</label>
    <label><input type="checkbox" id="wsToggle"> Live Ticker (FanDuel)</label>
  </div>
  <div id="opportunities"></div>
  <div class="grid" id="raceGrid">
    <div class="initial-state">
      <h3>Welcome to Checkmate Monitor</h3>
      <p>Start monitoring to see live racing data and checkmate opportunities.</p>
    </div>
  </div>
  <div class="ticker" id="liveTicker" style="display:none;">
    <h4>Live Ticker (FanDuel)</h4>
    <div id="tickerFeed" class="small mono muted">No live messages yet‚Ä¶</div>
  </div>
  <div class="hint" id="proxyHint">
    If nothing loads, the public CORS proxy may be rate-limited. You might need to request temporary access at cors-anywhere.herokuapp.com/corsdemo, or configure your own proxy endpoint.
  </div>

  <div id="logContainer" class="card" style="display: none; margin-top: 16px;">
    <div class="row">
      <h3>Opportunity Log</h3>
      <button id="clearLogBtn" class="secondary small">Clear Log</button>
    </div>
    <div id="logContent"></div>
  </div>
</div>
<script>
// =============================
// Config & Feature Flags
// =============================
const USE_TEST_DATA = false; // Toggle or use the UI checkbox
const ENABLE_FANDUEL_TICKER = false; // Toggle or use the UI checkbox
const DEFAULT_FANDUEL_EVENT_ID = 'demo-event-123'; // Replace with known id to see real messages

// Elements
const monitorBtn = document.getElementById('monitorBtn');
const refreshBtn = document.getElementById('refreshBtn');
const statusDiv = document.getElementById('status');
const raceGrid = document.getElementById('raceGrid');
const opportunitiesDiv = document.getElementById('opportunities');
const proxyHint = document.getElementById('proxyHint');
const sourceBadge = document.getElementById('sourceBadge');
const sourceSelect = document.getElementById('sourceSelect');
const testModeToggle = document.getElementById('testModeToggle');
const wsToggle = document.getElementById('wsToggle');
const liveTicker = document.getElementById('liveTicker');
const tickerFeed = document.getElementById('tickerFeed');
const logContainer = document.getElementById('logContainer');
const logContent = document.getElementById('logContent');
const clearLogBtn = document.getElementById('clearLogBtn');

// State
let isMonitoring = false;
let intervalId = null;
let currentSource = 'None';
let ws = null;

// Network Config
const CORS_PROXY = "https://cors-anywhere.herokuapp.com/";
const UPDATE_MS = 60_000; // 1 minute
const FETCH_TIMEOUT_MS = 15_000;
const MAX_CONCURRENCY = 6;
const RETRIES = 1;

// =============================
// Utilities
// =============================
function setBadge(source){
  currentSource = source;
  sourceBadge.textContent = `Source: ${source}`;
}
function fetchWithTimeout(resource, options = {}, timeout = FETCH_TIMEOUT_MS){
  return new Promise((resolve, reject) => {
    const ctrl = new AbortController();
    const id = setTimeout(() => ctrl.abort(), timeout);
    fetch(resource, { ...options, signal: ctrl.signal })
      .then(res => { clearTimeout(id); resolve(res); })
      .catch(err => { clearTimeout(id); reject(err); });
  });
}
async function fetchTextWithRetry(url, tries = RETRIES + 1){
  let lastErr;
  for (let i = 0; i < tries; i++){
    try {
      const res = await fetchWithTimeout(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.text();
    } catch (e){
      lastErr = e;
      await new Promise(r => setTimeout(r, (i + 1) * 400));
    }
  }
  throw lastErr;
}
function parseOdds(oddsStrRaw){
  if (!oddsStrRaw) return null;
  const s = String(oddsStrRaw).trim().toUpperCase();
  if (!s || s === '-' || s === '--' || s === 'SCR' || s === 'SCRATCHED') return null;
  if (s.includes('ML')) return null; // ignore morning line
  if (s === 'EVS' || s === 'EVEN' || s === 'EVEN MONEY' || s === 'EVEN/MONEY') return 1.0;
  const frac = s.match(/^(\d+)\s*\/\s*(\d+)$/);
  if (frac){
    const num = parseFloat(frac[1]); const den = parseFloat(frac[2]);
    if (den === 0) return null;
    return num / den;
  }
  const dec = parseFloat(s.replace(/[^\d.]/g, ''));
  if (!isNaN(dec)) return dec;
  return null;
}
function keyOf(r){ return `${r.track}#${r.raceNumber}`; }
function fmtOdds(x){ return (typeof x === 'number' && isFinite(x)) ? x.toFixed(2) : '--'; }
function escapeHtml(s){
  return String(s ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// =============================
// Adapters
// =============================
// Gold ‚Äì TwinSpires (HTML scrape)
const TS_BASE = 'https://www.twinspires.com';
const TS_INDEX_URL = `${CORS_PROXY}${TS_BASE}/adw/todays-tracks?sortOrder=nextUp`;
function extractRaceLinks(indexHtml){
  const parser = new DOMParser();
  const doc = parser.parseFromString(indexHtml, 'text/html');
  const links = new Set();
  doc.querySelectorAll('a[href]').forEach(a => {
    const href = a.getAttribute('href');
    if (!href) return;
    if (/\/race\/\d+/i.test(href) && !/\/results\//i.test(href)){
      const abs = href.startsWith('http') ? href : `${TS_BASE}${href}`;
      links.add(`${CORS_PROXY}${abs}`);
    }
  });
  return Array.from(links);
}
function parseTwinspiresDetail(html){
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  const header = doc.querySelector('.race-title');
  if (!header) return null;
  const trackNode = header.querySelector('a');
  const strong = header.querySelector('strong');
  const trackName = trackNode ? trackNode.textContent.trim() : 'Unknown';
  const raceNumber = strong ? parseInt(strong.textContent.replace(/\D/g, '')) : null;
  let discipline = 'Thoroughbred';
  const text = html;
  if (/Harness/i.test(text)) discipline = 'Harness';
  if (/Greyhound/i.test(text)) discipline = 'Greyhound';
  let raceTime = null;
  const timeEl = doc.querySelector('[data-testid*="post-time"], .post-time, .race-time');
  if (timeEl){ raceTime = timeEl.textContent.trim() || null; }
  const runners = [];
  const nodes = doc.querySelectorAll('#program .runner-wrapper, .runner-wrapper, [data-testid*="runner"]');
  nodes.forEach(el => {
    const nameEl = el.querySelector('.runner-name, [data-testid*="runner-name"]');
    const oddsEl = el.querySelector('.odds, [data-testid*="odds"]');
    const name = nameEl ? nameEl.textContent.trim() : null;
    const odds = parseOdds(oddsEl ? oddsEl.textContent.trim() : null);
    if (name && odds !== null) runners.push({ name, odds });
  });
  if (!runners.length || !raceNumber) return null;
  return { discipline, track: trackName, raceNumber, runners, raceTime };
}
async function fetchTwinspiresData(){
  try{
    const indexHtml = await fetchTextWithRetry(TS_INDEX_URL);
    const links = extractRaceLinks(indexHtml);
    if (!links.length) return [];
    const out = [];
    let i = 0;
    const workers = Math.min(MAX_CONCURRENCY, Math.max(1, links.length));
    async function worker(){
      while(i < links.length){
        const url = links[i++];
        try{
          const html = await fetchTextWithRetry(url);
          const parsed = parseTwinspiresDetail(html);
          if (parsed) out.push(parsed);
        }catch(e){ console.warn('TS detail failed:', e?.message || e); }
      }
    }
    await Promise.all(Array.from({length: workers}, () => worker()));
    return out;
  }catch(e){ console.error('TwinSpires fetch failed:', e); return []; }
}

// Silver ‚Äì RPB2B (JSON API, Thoroughbred only)
async function fetchRpb2bData(){
  console.log('Attempting fallback to RPB2B API...');
  const BASE_URL = 'https://backend-us-racecards.widget.rpb2b.com/v2';
  const dateStr = new Date().toISOString().split('T')[0];
  const dailyUrl = `${CORS_PROXY}${BASE_URL}/racecards/daily/${dateStr}`;
  let allRaces = [];
  try{
    const indexResponse = await fetchTextWithRetry(dailyUrl);
    const daily = JSON.parse(indexResponse);
    const raceIds = [];
    (daily.courses || []).forEach(course => {
      (course.races || []).forEach(r => raceIds.push(r.id));
    });
    if (!raceIds.length) return [];
    const requests = raceIds.map(id => fetchTextWithRetry(`${CORS_PROXY}${BASE_URL}/racecards/${id}?include=odds`));
    const results = await Promise.allSettled(requests);
    results.forEach(res => {
      if (res.status !== 'fulfilled') return;
      try{
        const raceData = JSON.parse(res.value);
        const runners = (raceData.runners || []).map(rr => ({ name: rr.name, odds: parseFloat(rr.odds?.decimal) }))
          .filter(x => x.name && !isNaN(x.odds));
        if (runners.length){
          allRaces.push({
            discipline: 'Thoroughbred',
            track: raceData.course?.name || 'Unknown',
            raceNumber: raceData.raceNumber,
            runners,
            raceTime: raceData.startTime ? new Date(raceData.startTime).toLocaleString() : null
          });
        }
      }catch(e){ /* skip parse errors */ }
    });
  }catch(e){ console.error('RPB2B fallback failed:', e); return []; }
  return allRaces;
}

// Contender ‚Äì PointsBet (JSON API)
async function fetchPointsBetData(){
  console.log('Attempting fetch from PointsBet API...');
  const API_URL = `${CORS_PROXY}https://api.au.pointsbet.com/api/v2/racing/races/today`;
  let allRaces = [];
  try{
    const text = await fetchTextWithRetry(API_URL);
    const data = JSON.parse(text);
    (data.events || []).forEach(ev => {
      if (!ev.runners || !ev.meetingName) return;
      const runners = (ev.runners || []).map(r => ({ name: r.name, odds: parseFloat(r.fixedWinOdds?.price) }))
        .filter(x => x.name && !isNaN(x.odds));
      if (runners.length){
        allRaces.push({
          discipline: 'Thoroughbred',
          track: ev.meetingName,
          raceNumber: ev.raceNumber,
          runners,
          raceTime: ev.startTime ? new Date(ev.startTime).toLocaleString() : null
        });
      }
    });
  }catch(e){ console.error('PointsBet fetch failed:', e); return []; }
  return allRaces;
}

// Bronze ‚Äì FanDuel WebSocket (listener)
function listenFanDuelSocket(raceEventId, onUpdate){
  const WEBSOCKET_URI = 'wss://api.dub.fanduel.com/v1/subscription';
  const subscriptionMessage = JSON.stringify({
    type: 'subscribe', channel: 'market_changes', id: raceEventId, data: { marketId: raceEventId }
  });
  let opened = false;
  let socket;
  try{
    socket = new WebSocket(WEBSOCKET_URI);
  }catch(e){ appendTicker(`WS Error: ${e?.message || e}`); return null; }
  socket.onopen = () => { opened = true; appendTicker('WebSocket connected. Subscribing...'); socket.send(subscriptionMessage); };
  socket.onmessage = (event) => {
    try{
      const data = JSON.parse(event.data);
      if (data.type === 'market_change' && data.data?.runners){
        const runners = data.data.runners.map(r => ({ name: r.runnerName, odds: parseFloat(r.win?.trueOdds?.decimal) }))
          .filter(x => x.name && !isNaN(x.odds));
        if (runners.length){ onUpdate({ discipline: 'Thoroughbred', track: 'FanDuel Live', raceNumber: 0, runners });
          appendTicker(`Update: ${runners.slice(0,3).map(r=>`${r.name} ${fmtOdds(r.odds)}`).join(', ')} ...`);
        }
      }
    }catch(e){ appendTicker(`WS Parse error: ${e?.message || e}`); }
  };
  socket.onerror = err => appendTicker(`WS Error: ${err?.message || 'unknown'}`);
  socket.onclose = () => appendTicker('WebSocket closed.');
  return socket;
}
function appendTicker(msg){
  const ts = new Date().toLocaleTimeString();
  // Fixed: Properly escape the message and use innerHTML to handle line breaks
  const escapedMsg = escapeHtml(msg);
  const currentContent = tickerFeed.innerHTML;
  tickerFeed.innerHTML = `[${ts}] ${escapedMsg}<br>` + currentContent;
}

// =============================
// Checkmate Scoring
// =============================
function getDynamicOddsThresholds(fieldSize){
  if (fieldSize <= 4) return { fav: 0.5, secondFav: 2.0 };
  if (fieldSize === 5) return { fav: 0.8, secondFav: 3.0 };
  if (fieldSize === 6) return { fav: 1.0, secondFav: 3.5 };
  return { fav: 1.0, secondFav: 4.0 };
}
function findCheckmateOpportunities(races){
  return races.filter(race => {
    if (race.discipline !== 'Thoroughbred') return false;
    if (!race.runners || race.runners.length < 2 || race.runners.length >= 7) return false;
    const sorted = [...race.runners].sort((a,b)=>a.odds - b.odds);
    const { fav: favT, secondFav: secondT } = getDynamicOddsThresholds(sorted.length);
    const fav = sorted[0], second = sorted[1];
    return fav && second && fav.odds > favT && second.odds > secondT;
  });
}

// =============================
// UI
// =============================
function displayOpportunities(opps){
  if (opps.length > 0) {
    opps.forEach(opp => opportunityLog.add(opp));
  }

  if (!opps.length){ opportunitiesDiv.style.display = 'none'; opportunitiesDiv.innerHTML = ''; return; }
  let html = '<h3>üö® Checkmate Opportunities</h3>';
  html += '<table><thead><tr><th>Track</th><th>Race</th><th>Fav Odds</th><th>2nd Fav Odds</th><th>Field</th></tr></thead><tbody>';
  opps.forEach(r => {
    const sorted = [...r.runners].sort((a,b)=>a.odds-b.odds);
    html += `<tr><td>${escapeHtml(r.track)}</td><td>${r.raceNumber ?? '--'}</td><td class="mono">${fmtOdds(sorted[0]?.odds)}</td><td class="mono">${fmtOdds(sorted[1]?.odds)}</td><td>${r.runners.length}</td></tr>`;
  });
  html += '</tbody></table>';
  opportunitiesDiv.style.display = 'block';
  opportunitiesDiv.innerHTML = html;
}
function renderDisciplineCard(title, races, highlightSet){
  const items = races.sort((a,b)=> (a.track===b.track? (a.raceNumber||0)-(b.raceNumber||0) : a.track.localeCompare(b.track)))
    .map(r => {
      const sorted = [...r.runners].sort((a,b)=>a.odds - b.odds);
      const fav = sorted[0], second = sorted[1];
      const isCM = highlightSet.has(keyOf(r));
      return `
        <div class="item">
          <div class="row">
            <div><strong>${escapeHtml(r.track)}</strong> ‚Ä¢ R${r.raceNumber ?? '?'}</div>
            <div>${r.raceTime ? `<span class="meta">${escapeHtml(String(r.raceTime))}</span>` : ''}</div>
          </div>
          <div class="row small">
            <div>Fav: <span class="mono">${fmtOdds(fav?.odds)}</span> ‚Äì ${escapeHtml(fav?.name || '')}</div>
            <div>2nd: <span class="mono">${fmtOdds(second?.odds)}</span> ‚Äì ${escapeHtml(second?.name || '')}</div>
          </div>
          <div class="row">
            <span class="meta">Field: ${r.runners.length}</span>
            ${isCM ? '<span class="badge danger">Checkmate</span>' : '<span class="badge">Monitoring</span>'}
          </div>
        </div>`;
    }).join('');
  return `<div class="card"><h3>${title} (${races.length})</h3><div class="list">${races.length?items:'<div class="muted small">No races found.</div>'}</div></div>`;
}
function displayRaces(all){
  const t = all.filter(r => r.discipline === 'Thoroughbred');
  const h = all.filter(r => r.discipline === 'Harness');
  const g = all.filter(r => r.discipline === 'Greyhound');
  const checkmates = findCheckmateOpportunities(t);
  const keys = new Set(checkmates.map(keyOf));
  raceGrid.innerHTML = [
    renderDisciplineCard('Thoroughbreds', t, keys),
    renderDisciplineCard('Harness', h, new Set()),
    renderDisciplineCard('Greyhounds', g, new Set()),
  ].join('');
  displayOpportunities(checkmates);
}
function setLoading(loading){
  refreshBtn.disabled = loading || !isMonitoring;
  monitorBtn.disabled = loading && isMonitoring;
}

// =============================
// Opportunity Log
// =============================
const opportunityLog = {
    STORAGE_KEY: 'checkmate_opportunity_log',
    _log: [],

    init() {
        this.load();
        this.render();
        clearLogBtn.addEventListener('click', () => this.clear());
    },

    load() {
        try {
            const storedLog = localStorage.getItem(this.STORAGE_KEY);
            this._log = storedLog ? JSON.parse(storedLog) : [];
        } catch (e) {
            console.error("Failed to load opportunity log from localStorage", e);
            this._log = [];
        }
    },

    save() {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this._log));
        } catch (e) {
            console.error("Failed to save opportunity log to localStorage", e);
        }
    },

    add(opportunity) {
        const sortedRunners = [...opportunity.runners].sort((a, b) => a.odds - b.odds);
        const opportunityId = `${keyOf(opportunity)}-${sortedRunners[0].odds}-${sortedRunners[1].odds}`;

        if (!this._log.some(item => item.id === opportunityId)) {
            const logEntry = {
                id: opportunityId,
                track: opportunity.track,
                raceNumber: opportunity.raceNumber,
                timestamp: new Date().toISOString(),
                favOdds: sortedRunners[0].odds,
                secondFavOdds: sortedRunners[1].odds,
                fieldSize: opportunity.runners.length
            };
            this._log.unshift(logEntry);
            this.save();
            this.render();
        }
    },

    clear() {
        if (confirm("Are you sure you want to clear the entire opportunity log?")) {
            this._log = [];
            this.save();
            this.render();
        }
    },

    render() {
        if (this._log.length === 0) {
            logContainer.style.display = 'none';
            return;
        }
        logContainer.style.display = 'block';

        let html = '<table><thead><tr><th>Logged</th><th>Track</th><th>Race</th><th>Fav Odds</th><th>2nd Fav Odds</th><th>Field</th></tr></thead><tbody>';
        this._log.forEach(entry => {
            html += `
                <tr>
                    <td class="small muted">${new Date(entry.timestamp).toLocaleString()}</td>
                    <td>${escapeHtml(entry.track)}</td>
                    <td>${entry.raceNumber}</td>
                    <td class="mono">${fmtOdds(entry.favOdds)}</td>
                    <td class="mono">${fmtOdds(entry.secondFavOdds)}</td>
                    <td>${entry.fieldSize}</td>
                </tr>
            `;
        });
        html += '</tbody></table>';
        logContent.innerHTML = html;
    }
};

// =============================
// Test Data
// =============================
function getTestData(){
  return [
    { discipline:'Thoroughbred', track:'Test Park', raceNumber:1, raceTime:'2:15 PM', runners:[
      {name:'Alpha', odds:1.2},{name:'Bravo', odds:3.8},{name:'Charlie', odds:5.0},{name:'Delta', odds:7.0}
    ]},
    { discipline:'Thoroughbred', track:'Demo Downs', raceNumber:3, raceTime:'3:05 PM', runners:[
      {name:'Echo', odds:0.6},{name:'Foxtrot', odds:2.8},{name:'Golf', odds:9.0}
    ]},
    { discipline:'Harness', track:'HarnessVille', raceNumber:2, raceTime:'2:45 PM', runners:[
      {name:'H1', odds:2.0},{name:'H2', odds:3.0}
    ]}
  ];
}

// =============================
// Waterfall Runner
// =============================
async function runWaterfall(selected){
  // Returns { races, source }
  const attempt = async (fn, label) => {
    try{ const data = await fn(); return Array.isArray(data) ? data : []; }catch(_){ return []; }
  };
  if (selected === 'TwinSpires'){
    const ts = await attempt(fetchTwinspiresData, 'TwinSpires'); if (ts.length) return { races: ts, source: 'TwinSpires' };
    return { races: [], source: 'TwinSpires (empty)' };
  }
  if (selected === 'RPB2B'){
    const rp = await attempt(fetchRpb2bData, 'RPB2B'); if (rp.length) return { races: rp, source: 'RPB2B' };
    return { races: [], source: 'RPB2B (empty)' };
  }
  if (selected === 'PointsBet'){
    const pb = await attempt(fetchPointsBetData, 'PointsBet'); if (pb.length) return { races: pb, source: 'PointsBet' };
    return { races: [], source: 'PointsBet (empty)' };
  }
  // Auto waterfall: Gold ‚Üí Silver ‚Üí Contender
  const ts = await attempt(fetchTwinspiresData, 'TwinSpires'); if (ts.length) return { races: ts, source: 'TwinSpires' };
  const rp = await attempt(fetchRpb2bData, 'RPB2B'); if (rp.length) return { races: rp, source: 'RPB2B' };
  const pb = await attempt(fetchPointsBetData, 'PointsBet'); if (pb.length) return { races: pb, source: 'PointsBet' };
  return { races: [], source: 'None' };
}

// =============================
// App Cycle
// =============================
async function runUpdate(){
  setLoading(true);
  const started = Date.now();
  let races = [];
  let source = 'None';

  const testMode = testModeToggle.checked || USE_TEST_DATA;
  if (testMode){
    races = getTestData();
    source = 'Test Data';
  } else {
    const selected = sourceSelect.value;
    const result = await runWaterfall(selected);
    races = result.races; source = result.source;
  }

  displayRaces(races);
  setBadge(sourceSelect.value === 'auto' ? `Auto (${source})` : source);
  const took = Math.round((Date.now() - started)/1000);
  statusDiv.textContent = `Last update: ${new Date().toLocaleTimeString()} ‚Ä¢ ${races.length} races ‚Ä¢ ${took}s`;
  setLoading(false);
}

function startMonitoring(){
  isMonitoring = true;
  monitorBtn.textContent = 'Stop Monitoring';
  proxyHint.style.display = 'block';
  refreshBtn.disabled = true;
  runUpdate().then(()=>{ refreshBtn.disabled = false; });
  intervalId = setInterval(runUpdate, UPDATE_MS);
}
function stopMonitoring(){
  isMonitoring = false;
  monitorBtn.textContent = 'Start Monitoring';
  statusDiv.textContent = 'Monitoring stopped.';
  clearInterval(intervalId);
  refreshBtn.disabled = true;

  // Clear the grid and show initial state
  raceGrid.innerHTML = `
    <div class="initial-state">
      <h3>Welcome to Checkmate Monitor</h3>
      <p>Start monitoring to see live racing data and checkmate opportunities.</p>
    </div>`;
}

// Initialize display on page load
document.addEventListener('DOMContentLoaded', () => {
  // Show initial welcome message
  raceGrid.innerHTML = `
    <div class="initial-state">
      <h3>Welcome to Checkmate Monitor</h3>
      <p>Start monitoring to see live racing data and checkmate opportunities.</p>
    </div>`;

  opportunityLog.init();
});

// =============================
// Events
// =============================
monitorBtn.addEventListener('click', () => {
  if (isMonitoring) stopMonitoring(); else startMonitoring();
});
refreshBtn.addEventListener('click', () => { if (isMonitoring) runUpdate(); });
sourceSelect.addEventListener('change', () => { if (isMonitoring) runUpdate(); });
testModeToggle.addEventListener('change', () => { if (isMonitoring) runUpdate(); });
wsToggle.addEventListener('change', () => {
  const enable = wsToggle.checked || ENABLE_FANDUEL_TICKER;
  liveTicker.style.display = enable ? 'block' : 'none';
  if (!enable && ws){ try{ ws.close(); }catch{} ws = null; return; }
  if (enable && !ws){ ws = listenFanDuelSocket(DEFAULT_FANDUEL_EVENT_ID, (update) => { /* push-only ticker; does not alter main list */ }); }
});
</script>
</body>
</html>
