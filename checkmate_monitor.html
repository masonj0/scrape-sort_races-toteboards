<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8" />\n<meta name="viewport" content="width=device-width, initial-scale=1.0"/>\n<title>Checkmate Live Monitor (Serverless ‚Ä¢ Multi-Source)</title>\n<style>\n:root{--bg:#f0f2f5;--fg:#333;--card:#fff;--muted:#666;--border:#e6e6e6;--danger:#d9534f;--accent:#2b7cff;--ok:#1bb14c;--warn:#ffb200}\n*{box-sizing:border-box}\nbody{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg);margin:0}\n.container{max-width:1200px;margin:auto;padding:16px}\nh1{text-align:center;font-size:1.6rem;margin:8px 0 12px}\n#status{text-align:center;font-style:italic;margin:8px 0 16px;color:var(--muted)}\n.controls{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap;margin-bottom:12px}\nbutton{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:6px;cursor:pointer;font-weight:600}\nbutton.secondary{background:#777}\nbutton.warning{background:var(--warn);color:#222}\nbutton:disabled{opacity:.6;cursor:not-allowed}\nselect, label{font-size:.95rem}\n#sourceBadge{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;background:#eef3ff;color:#1746a2;border:1px solid #cfdcff;font-size:.8rem}\n#opportunities{border:2px solid var(--danger);background:#fff7f7;border-radius:8px;padding:12px;margin-bottom:16px;display:none}\n#opportunities h3{margin:0 0 8px;color:var(--danger)}\ntable{width:100%;border-collapse:collapse}\nth,td{text-align:left;padding:8px;border-bottom:1px solid var(--border);font-size:.95rem}\n.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px}\n.card{background:var(--card);border-radius:8px;padding:12px;box-shadow:0 2px 4px rgba(0,0,0,.06)}\n.card h3{margin:0 0 8px;border-bottom:1px solid var(--border);padding-bottom:8px}\n.list{display:grid;gap:8px}\n.item{display:grid;gap:6px;padding:8px;border:1px solid var(--border);border-radius:6px;background:#fff}\n.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between}\n.meta{color:var(--muted);font-size:.9rem}\n.badge{display:inline-block;padding:2px 6px;font-size:.8rem;border-radius:999px;background:#eee;color:#333}\n.badge.danger{background:#ffe4e4;color:var(--danger);border:1px solid #ffc6c6}\n.badge.ok{background:#e8f8ee;color:var(--ok);border:1px solid #c9f0d7}\n.muted{color:var(--muted)}\n.small{font-size:.85rem}\n.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}\n.hint{text-align:center;color:var(--muted);font-size:.9rem;margin-top:6px}\n.ticker{margin:12px 0;padding:8px;border:1px dashed var(--border);border-radius:6px;background:#fcfcff}\n.ticker h4{margin:0 0 8px}\n@media (max-width:380px){.grid{grid-template-columns:1fr}}\n</style>\n</head>\n<body>\n<div class="container">\n  <h1>üèá Checkmate Live Monitor (Serverless ‚Ä¢ Multi-Source) <span id="sourceBadge">Source: Auto (None)</span></h1>\n  <div id="status">Click ‚ÄúStart Monitoring‚Äù to begin‚Ä¶</div>\n  <div class="controls">\n    <button id="monitorBtn">Start Monitoring</button>\n    <button id="refreshBtn" class="secondary" disabled>Refresh Now</button>\n    <label>Source:\n      <select id="sourceSelect" title="Choose source or Auto">\n        <option value="auto" selected>Auto (Waterfall)</option>\n        <option value="TwinSpires">TwinSpires (Gold)</option>\n        <option value="RPB2B">RPB2B (Silver)</option>\n        <option value="PointsBet">PointsBet (Contender)</option>\n      </select>\n    </label>\n    <label><input type="checkbox" id="testModeToggle"> Test Mode</label>\n    <label><input type="checkbox" id="wsToggle"> Live Ticker (FanDuel)</label>\n  </div>\n  <div id="opportunities"></div>\n  <div class="grid" id="raceGrid"></div>\n  <div class="ticker" id="liveTicker" style="display:none;">\n    <h4>Live Ticker (FanDuel)</h4>\n    <div id="tickerFeed" class="small mono muted">No live messages yet‚Ä¶</div>\n  </div>\n  <div class="hint" id="proxyHint">\n    If nothing loads, the public CORS proxy may be rate-limited. You might need to request temporary access at cors-anywhere.herokuapp.com/corsdemo, or configure your own proxy endpoint.\n  </div>\n</div>\n<script>\n// =============================\n// Config & Feature Flags\n// =============================\nconst USE_TEST_DATA = false; // Toggle or use the UI checkbox\nconst ENABLE_FANDUEL_TICKER = false; // Toggle or use the UI checkbox\nconst DEFAULT_FANDUEL_EVENT_ID = 'demo-event-123'; // Replace with known id to see real messages\n\n// Elements\nconst monitorBtn = document.getElementById('monitorBtn');\nconst refreshBtn = document.getElementById('refreshBtn');\nconst statusDiv = document.getElementById('status');\nconst raceGrid = document.getElementById('raceGrid');\nconst opportunitiesDiv = document.getElementById('opportunities');\nconst proxyHint = document.getElementById('proxyHint');\nconst sourceBadge = document.getElementById('sourceBadge');\nconst sourceSelect = document.getElementById('sourceSelect');\nconst testModeToggle = document.getElementById('testModeToggle');\nconst wsToggle = document.getElementById('wsToggle');\nconst liveTicker = document.getElementById('liveTicker');\nconst tickerFeed = document.getElementById('tickerFeed');\n\n// State\nlet isMonitoring = false;\nlet intervalId = null;\nlet currentSource = 'None';\nlet ws = null;\n\n// Network Config\nconst CORS_PROXY = \"https://cors-anywhere.herokuapp.com/\";\nconst UPDATE_MS = 60_000; // 1 minute\nconst FETCH_TIMEOUT_MS = 15_000;\nconst MAX_CONCURRENCY = 6;\nconst RETRIES = 1;\n\n// =============================\n// Utilities\n// =============================\nfunction setBadge(source){\n  currentSource = source;\n  sourceBadge.textContent = `Source: ${source}`;\n}\nfunction fetchWithTimeout(resource, options = {}, timeout = FETCH_TIMEOUT_MS){\n  return new Promise((resolve, reject) => {\n    const ctrl = new AbortController();\n    const id = setTimeout(() => ctrl.abort(), timeout);\n    fetch(resource, { ...options, signal: ctrl.signal })\n      .then(res => { clearTimeout(id); resolve(res); })\n      .catch(err => { clearTimeout(id); reject(err); });\n  });\n}\nasync function fetchTextWithRetry(url, tries = RETRIES + 1){\n  let lastErr;\n  for (let i = 0; i < tries; i++){\n    try {\n      const res = await fetchWithTimeout(url);\n      if (!res.ok) throw new Error(`HTTP ${res.status}`);\n      return await res.text();\n    } catch (e){\n      lastErr = e;\n      await new Promise(r => setTimeout(r, (i + 1) * 400));\n    }\n  }\n  throw lastErr;\n}\nfunction parseOdds(oddsStrRaw){\n  if (!oddsStrRaw) return null;\n  const s = String(oddsStrRaw).trim().toUpperCase();\n  if (!s || s === '-' || s === '--' || s === 'SCR' || s === 'SCRATCHED') return null;\n  if (s.includes('ML')) return null; // ignore morning line\n  if (s === 'EVS' || s === 'EVEN' || s === 'EVEN MONEY' || s === 'EVEN/MONEY') return 1.0;\n  const frac = s.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/);\n  if (frac){\n    const num = parseFloat(frac[1]); const den = parseFloat(frac[2]);\n    if (den === 0) return null;\n    return num / den;\n  }\n  const dec = parseFloat(s.replace(/[^\\d.]/g, ''));\n  if (!isNaN(dec)) return dec;\n  return null;\n}\nfunction keyOf(r){ return `${r.track}#${r.raceNumber}`; }\nfunction fmtOdds(x){ return (typeof x === 'number' && isFinite(x)) ? x.toFixed(2) : '--'; }\nfunction escapeHtml(s){\n  return String(s ?? '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n// =============================\n// Adapters\n// =============================\n// Gold ‚Äî TwinSpires (HTML scrape)\nconst TS_BASE = 'https://www.twinspires.com';\nconst TS_INDEX_URL = `${CORS_PROXY}${TS_BASE}/adw/todays-tracks?sortOrder=nextUp`;\nfunction extractRaceLinks(indexHtml){\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(indexHtml, 'text/html');\n  const links = new Set();\n  doc.querySelectorAll('a[href]').forEach(a => {\n    const href = a.getAttribute('href');\n    if (!href) return;\n    if (/\\/race\\/\\d+/i.test(href) && !/\\/results\\//i.test(href)){\n      const abs = href.startsWith('http') ? href : `${TS_BASE}${href}`;\n      links.add(`${CORS_PROXY}${abs}`);\n    }\n  });\n  return Array.from(links);\n}\nfunction parseTwinspiresDetail(html){\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(html, 'text/html');\n  const header = doc.querySelector('.race-title');\n  if (!header) return null;\n  const trackNode = header.querySelector('a');\n  const strong = header.querySelector('strong');\n  const trackName = trackNode ? trackNode.textContent.trim() : 'Unknown';\n  const raceNumber = strong ? parseInt(strong.textContent.replace(/\\D/g, '')) : null;\n  let discipline = 'Thoroughbred';\n  const text = html;\n  if (/Harness/i.test(text)) discipline = 'Harness';\n  if (/Greyhound/i.test(text)) discipline = 'Greyhound';\n  let raceTime = null;\n  const timeEl = doc.querySelector('[data-testid*=\"post-time\"], .post-time, .race-time');\n  if (timeEl){ raceTime = timeEl.textContent.trim() || null; }\n  const runners = [];\n  const nodes = doc.querySelectorAll('#program .runner-wrapper, .runner-wrapper, [data-testid*=\"runner\"]');\n  nodes.forEach(el => {\n    const nameEl = el.querySelector('.runner-name, [data-testid*=\"runner-name\"]');\n    const oddsEl = el.querySelector('.odds, [data-testid*=\"odds\"]');\n    const name = nameEl ? nameEl.textContent.trim() : null;\n    const odds = parseOdds(oddsEl ? oddsEl.textContent.trim() : null);\n    if (name && odds !== null) runners.push({ name, odds });\n  });\n  if (!runners.length || !raceNumber) return null;\n  return { discipline, track: trackName, raceNumber, runners, raceTime };\n}\nasync function fetchTwinspiresData(){\n  try{\n    const indexHtml = await fetchTextWithRetry(TS_INDEX_URL);\n    const links = extractRaceLinks(indexHtml);\n    if (!links.length) return [];\n    const out = [];\n    let i = 0;\n    const workers = Math.min(MAX_CONCURRENCY, Math.max(1, links.length));\n    async function worker(){\n      while(i < links.length){\n        const url = links[i++];\n        try{\n          const html = await fetchTextWithRetry(url);\n          const parsed = parseTwinspiresDetail(html);\n          if (parsed) out.push(parsed);\n        }catch(e){ console.warn('TS detail failed:', e?.message || e); }\n      }\n    }\n    await Promise.all(Array.from({length: workers}, () => worker()));\n    return out;\n  }catch(e){ console.error('TwinSpires fetch failed:', e); return []; }\n}\n\n// Silver ‚Äî RPB2B (JSON API, Thoroughbred only)\nasync function fetchRpb2bData(){\n  console.log('Attempting fallback to RPB2B API...');\n  const BASE_URL = 'https://backend-us-racecards.widget.rpb2b.com/v2';\n  const dateStr = new Date().toISOString().split('T')[0];\n  const dailyUrl = `${CORS_PROXY}${BASE_URL}/racecards/daily/${dateStr}`;\n  let allRaces = [];\n  try{\n    const indexResponse = await fetchTextWithRetry(dailyUrl);\n    const daily = JSON.parse(indexResponse);\n    const raceIds = [];\n    (daily.courses || []).forEach(course => {\n      (course.races || []).forEach(r => raceIds.push(r.id));\n    });\n    if (!raceIds.length) return [];\n    const requests = raceIds.map(id => fetchTextWithRetry(`${CORS_PROXY}${BASE_URL}/racecards/${id}?include=odds`));\n    const results = await Promise.allSettled(requests);\n    results.forEach(res => {\n      if (res.status !== 'fulfilled') return;\n      try{\n        const raceData = JSON.parse(res.value);\n        const runners = (raceData.runners || []).map(rr => ({ name: rr.name, odds: parseFloat(rr.odds?.decimal) }))\n          .filter(x => x.name && !isNaN(x.odds));\n        if (runners.length){\n          allRaces.push({\n            discipline: 'Thoroughbred',\n            track: raceData.course?.name || 'Unknown',\n            raceNumber: raceData.raceNumber,\n            runners,\n            raceTime: raceData.startTime ? new Date(raceData.startTime).toLocaleString() : null\n          });\n        }\n      }catch(e){ /* skip parse errors */ }\n    });\n  }catch(e){ console.error('RPB2B fallback failed:', e); return []; }\n  return allRaces;\n}\n\n// Contender ‚Äî PointsBet (JSON API)\nasync function fetchPointsBetData(){\n  console.log('Attempting fetch from PointsBet API...');\n  const API_URL = `${CORS_PROXY}https://api.au.pointsbet.com/api/v2/racing/races/today`;\n  let allRaces = [];\n  try{\n    const text = await fetchTextWithRetry(API_URL);\n    const data = JSON.parse(text);\n    (data.events || []).forEach(ev => {\n      if (!ev.runners || !ev.meetingName) return;\n      const runners = (ev.runners || []).map(r => ({ name: r.name, odds: parseFloat(r.fixedWinOdds?.price) }))\n        .filter(x => x.name && !isNaN(x.odds));\n      if (runners.length){\n        allRaces.push({\n          discipline: 'Thoroughbred',\n          track: ev.meetingName,\n          raceNumber: ev.raceNumber,\n          runners,\n          raceTime: ev.startTime ? new Date(ev.startTime).toLocaleString() : null\n        });\n      }\n    });\n  }catch(e){ console.error('PointsBet fetch failed:', e); return []; }\n  return allRaces;\n}\n\n// Bronze ‚Äî FanDuel WebSocket (listener)\nfunction listenFanDuelSocket(raceEventId, onUpdate){\n  const WEBSOCKET_URI = 'wss://api.dub.fanduel.com/v1/subscription';\n  const subscriptionMessage = JSON.stringify({\n    type: 'subscribe', channel: 'market_changes', id: raceEventId, data: { marketId: raceEventId }\n  });\n  let opened = false;\n  let socket;\n  try{\n    socket = new WebSocket(WEBSOCKET_URI);\n  }catch(e){ appendTicker(`WS Error: ${e?.message || e}`); return null; }\n  socket.onopen = () => { opened = true; appendTicker('WebSocket connected. Subscribing...'); socket.send(subscriptionMessage); };\n  socket.onmessage = (event) => {\n    try{\n      const data = JSON.parse(event.data);\n      if (data.type === 'market_change' && data.data?.runners){\n        const runners = data.data.runners.map(r => ({ name: r.runnerName, odds: parseFloat(r.win?.trueOdds?.decimal) }))\n          .filter(x => x.name && !isNaN(x.odds));\n        if (runners.length){ onUpdate({ discipline: 'Thoroughbred', track: 'FanDuel Live', raceNumber: 0, runners });\n          appendTicker(`Update: ${runners.slice(0,3).map(r=>`${r.name} ${fmtOdds(r.odds)}`).join(', ')} ...`);\n        }\n      }\n    }catch(e){ appendTicker(`WS Parse error: ${e?.message || e}`); }\n  };\n  socket.onerror = err => appendTicker(`WS Error: ${err?.message || 'unknown'}`);\n  socket.onclose = () => appendTicker('WebSocket closed.');\n  return socket;\n}\nfunction appendTicker(msg){\n  const ts = new Date().toLocaleTimeString();\n  tickerFeed.textContent = `[${ts}] ${msg}\\n` + tickerFeed.textContent;\n}\n\n// =============================\n// Checkmate Scoring\n// =============================\nfunction getDynamicOddsThresholds(fieldSize){\n  if (fieldSize <= 4) return { fav: 0.5, secondFav: 2.0 };\n  if (fieldSize === 5) return { fav: 0.8, secondFav: 3.0 };\n  if (fieldSize === 6) return { fav: 1.0, secondFav: 3.5 };\n  return { fav: 1.0, secondFav: 4.0 };\n}\nfunction findCheckmateOpportunities(races){\n  return races.filter(race => {\n    if (race.discipline !== 'Thoroughbred') return false;\n    if (!race.runners || race.runners.length < 2 || race.runners.length >= 7) return false;\n    const sorted = [...race.runners].sort((a,b)=>a.odds - b.odds);\n    const { fav: favT, secondFav: secondT } = getDynamicOddsThresholds(sorted.length);\n    const fav = sorted[0], second = sorted[1];\n    return fav && second && fav.odds > favT && second.odds > secondT;\n  });\n}\n\n// =============================\n// UI\n// =============================\nfunction displayOpportunities(opps){\n  if (!opps.length){ opportunitiesDiv.style.display = 'none'; opportunitiesDiv.innerHTML = ''; return; }\n  let html = '<h3>üö® Checkmate Opportunities</h3>';\n  html += '<table><thead><tr><th>Track</th><th>Race</th><th>Fav Odds</th><th>2nd Fav Odds</th><th>Field</th></tr></thead><tbody>';\n  opps.forEach(r => {\n    const sorted = [...r.runners].sort((a,b)=>a.odds-b.odds);\n    html += `<tr><td>${escapeHtml(r.track)}</td><td>${r.raceNumber ?? '--'}</td><td class=\"mono\">${fmtOdds(sorted[0]?.odds)}</td><td class=\"mono\">${fmtOdds(sorted[1]?.odds)}</td><td>${r.runners.length}</td></tr>`;\n  });\n  html += '</tbody></table>';\n  opportunitiesDiv.style.display = 'block';\n  opportunitiesDiv.innerHTML = html;\n}\nfunction renderDisciplineCard(title, races, highlightSet){\n  const items = races.sort((a,b)=> (a.track===b.track? (a.raceNumber||0)-(b.raceNumber||0) : a.track.localeCompare(b.track)))\n    .map(r => {\n      const sorted = [...r.runners].sort((a,b)=>a.odds - b.odds);\n      const fav = sorted[0], second = sorted[1];\n      const isCM = highlightSet.has(keyOf(r));\n      return `\n        <div class=\"item\">\n          <div class=\"row\">\n            <div><strong>${escapeHtml(r.track)}</strong> ‚Ä¢ R${r.raceNumber ?? '?'}</div>\n            <div>${r.raceTime ? `<span class=\"meta\">${escapeHtml(String(r.raceTime))}</span>` : ''}</div>\n          </div>\n          <div class=\"row small\">\n            <div>Fav: <span class=\"mono\">${fmtOdds(fav?.odds)}</span> ‚Äî ${escapeHtml(fav?.name || '')}</div>\n            <div>2nd: <span class=\"mono\">${fmtOdds(second?.odds)}</span> ‚Äî ${escapeHtml(second?.name || '')}</div>\n          </div>\n          <div class=\"row\">\n            <span class=\"meta\">Field: ${r.runners.length}</span>\n            ${isCM ? '<span class=\"badge danger\">Checkmate</span>' : '<span class=\"badge\">Monitoring</span>'}\n          </div>\n        </div>`;\n    }).join('');\n  return `<div class=\"card\"><h3>${title} (${races.length})</h3><div class=\"list\">${races.length?items:'<div class=\"muted small\">No races found.</div>'}</div></div>`;\n}\nfunction displayRaces(all){\n  const t = all.filter(r => r.discipline === 'Thoroughbred');\n  const h = all.filter(r => r.discipline === 'Harness');\n  const g = all.filter(r => r.discipline === 'Greyhound');\n  const checkmates = findCheckmateOpportunities(t);\n  const keys = new Set(checkmates.map(keyOf));\n  raceGrid.innerHTML = [\n    renderDisciplineCard('Thoroughbreds', t, keys),\n    renderDisciplineCard('Harness', h, new Set()),\n    renderDisciplineCard('Greyhounds', g, new Set()),\n  ].join('');\n  displayOpportunities(checkmates);\n}\nfunction setLoading(loading){\n  refreshBtn.disabled = loading || !isMonitoring;\n  monitorBtn.disabled = loading && isMonitoring;\n}\n\n// =============================\n// Test Data\n// =============================\nfunction getTestData(){\n  return [\n    { discipline:'Thoroughbred', track:'Test Park', raceNumber:1, raceTime:'2:15 PM', runners:[\n      {name:'Alpha', odds:1.2},{name:'Bravo', odds:3.8},{name:'Charlie', odds:5.0},{name:'Delta', odds:7.0}\n    ]},\n    { discipline:'Thoroughbred', track:'Demo Downs', raceNumber:3, raceTime:'3:05 PM', runners:[\n      {name:'Echo', odds:0.6},{name:'Foxtrot', odds:2.8},{name:'Golf', odds:9.0}\n    ]},\n    { discipline:'Harness', track:'HarnessVille', raceNumber:2, raceTime:'2:45 PM', runners:[\n      {name:'H1', odds:2.0},{name:'H2', odds:3.0}\n    ]}\n  ];\n}\n\n// =============================\n// Waterfall Runner\n// =============================\nasync function runWaterfall(selected){\n  // Returns { races, source }\n  const attempt = async (fn, label) => {\n    try{ const data = await fn(); return Array.isArray(data) ? data : []; }catch(_){ return []; }\n  };\n  if (selected === 'TwinSpires'){\n    const ts = await attempt(fetchTwinspiresData, 'TwinSpires'); if (ts.length) return { races: ts, source: 'TwinSpires' };\n    return { races: [], source: 'TwinSpires (empty)' };\n  }\n  if (selected === 'RPB2B'){\n    const rp = await attempt(fetchRpb2bData, 'RPB2B'); if (rp.length) return { races: rp, source: 'RPB2B' };\n    return { races: [], source: 'RPB2B (empty)' };\n  }\n  if (selected === 'PointsBet'){\n    const pb = await attempt(fetchPointsBetData, 'PointsBet'); if (pb.length) return { races: pb, source: 'PointsBet' };\n    return { races: [], source: 'PointsBet (empty)' };\n  }\n  // Auto waterfall: Gold ‚Üí Silver ‚Üí Contender\n  const ts = await attempt(fetchTwinspiresData, 'TwinSpires'); if (ts.length) return { races: ts, source: 'TwinSpires' };\n  const rp = await attempt(fetchRpb2bData, 'RPB2B'); if (rp.length) return { races: rp, source: 'RPB2B' };\n  const pb = await attempt(fetchPointsBetData, 'PointsBet'); if (pb.length) return { races: pb, source: 'PointsBet' };\n  return { races: [], source: 'None' };\n}\n\n// =============================\n// App Cycle\n// =============================\nasync function runUpdate(){\n  setLoading(true);\n  const started = Date.now();\n  let races = [];\n  let source = 'None';\n\n  const testMode = testModeToggle.checked || USE_TEST_DATA;\n  if (testMode){\n    races = getTestData();\n    source = 'Test Data';\n  } else {\n    const selected = sourceSelect.value;\n    const result = await runWaterfall(selected);\n    races = result.races; source = result.source;\n  }\n\n  displayRaces(races);\n  setBadge(sourceSelect.value === 'auto' ? `Auto (${source})` : source);\n  const took = Math.round((Date.now() - started)/1000);\n  statusDiv.textContent = `Last update: ${new Date().toLocaleTimeString()} ‚Ä¢ ${races.length} races ‚Ä¢ ${took}s`;\n  setLoading(false);\n}\n\nfunction startMonitoring(){\n  isMonitoring = true;\n  monitorBtn.textContent = 'Stop Monitoring';\n  proxyHint.style.display = 'block';\n  refreshBtn.disabled = true;\n  runUpdate().then(()=>{ refreshBtn.disabled = false; });\n  intervalId = setInterval(runUpdate, UPDATE_MS);\n}\nfunction stopMonitoring(){\n  isMonitoring = false;\n  monitorBtn.textContent = 'Start Monitoring';\n  statusDiv.textContent = 'Monitoring stopped.';\n  clearInterval(intervalId);\n  refreshBtn.disabled = true;\n}\n\n// =============================\n// Events\n// =============================\nmonitorBtn.addEventListener('click', () => {\n  if (isMonitoring) stopMonitoring(); else startMonitoring();\n});\nrefreshBtn.addEventListener('click', () => { if (isMonitoring) runUpdate(); });\nsourceSelect.addEventListener('change', () => { if (isMonitoring) runUpdate(); });\ntestModeToggle.addEventListener('change', () => { if (isMonitoring) runUpdate(); });\nwsToggle.addEventListener('change', () => {\n  const enable = wsToggle.checked || ENABLE_FANDUEL_TICKER;\n  liveTicker.style.display = enable ? 'block' : 'none';\n  if (!enable && ws){ try{ ws.close(); }catch{} ws = null; return; }\n  if (enable && !ws){ ws = listenFanDuelSocket(DEFAULT_FANDUEL_EVENT_ID, (update) => { /* push-only ticker; does not alter main list */ }); }\n});\n</script>\n</body>\n</html>